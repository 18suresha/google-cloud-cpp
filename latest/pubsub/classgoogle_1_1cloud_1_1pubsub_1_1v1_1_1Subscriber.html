<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google Cloud Pub/Sub C++ Client: google::cloud::pubsub::v1::Subscriber Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Google Cloud Pub/Sub C++ Client
   &#160;<span id="projectnumber">1.20.0(Beta)</span>
   </div>
   <div id="projectbrief">A C++ Client Library for Google Cloud Pub/Sub</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegoogle.html">google</a></li><li class="navelem"><a class="el" href="namespacegoogle_1_1cloud.html">cloud</a></li><li class="navelem"><a class="el" href="namespacegoogle_1_1cloud_1_1pubsub.html">pubsub</a></li><li class="navelem"><a class="el" href="namespacegoogle_1_1cloud_1_1pubsub_1_1v1.html">v1</a></li><li class="navelem"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1Subscriber.html">Subscriber</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1Subscriber-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">google::cloud::pubsub::v1::Subscriber Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Receive messages from the Cloud Pub/Sub service.  
 <a href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1Subscriber.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="subscriber_8h_source.html">google/cloud/pubsub/subscriber.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2475af1f53fa45304228aeb6b79027fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1Subscriber.html#a2475af1f53fa45304228aeb6b79027fa">Subscriber</a> (std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberConnection.html">SubscriberConnection</a> &gt; connection)</td></tr>
<tr class="separator:a2475af1f53fa45304228aeb6b79027fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cc9e1d2af829a9864589d3e0b87241"><td class="memTemplParams" colspan="2">template&lt;typename Callable &gt; </td></tr>
<tr class="memitem:af1cc9e1d2af829a9864589d3e0b87241"><td class="memTemplItemLeft" align="right" valign="top">future&lt; Status &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1Subscriber.html#af1cc9e1d2af829a9864589d3e0b87241">Subscribe</a> (Callable &amp;&amp;cb)</td></tr>
<tr class="memdesc:af1cc9e1d2af829a9864589d3e0b87241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new session to receive messages from <code>subscription</code>.  <a href="#af1cc9e1d2af829a9864589d3e0b87241">More...</a><br /></td></tr>
<tr class="separator:af1cc9e1d2af829a9864589d3e0b87241"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Receive messages from the Cloud Pub/Sub service. </p>
<p>This class is used to receive message from a given subscription, with a fixed configuration such as credentials, and background threads. Applications that receive messages from multiple subscriptions need to create separate instances of this class. Applications wanting to receive events with configuration parameters also need to create separate instances.</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://cloud.google.com/pubsub">https://cloud.google.com/pubsub</a> for an overview of the Cloud Pub/Sub service.</dd></dl>
<dl class="section user"><dt>Example: subscriber quickstart</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1pubsub.html">pubsub</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1pubsub.html">google::cloud::pubsub</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](pubsub::Subscriber subscriber) {</div><div class="line">    std::mutex mu;</div><div class="line">    std::condition_variable cv;</div><div class="line">    <span class="keywordtype">int</span> message_count = 0;</div><div class="line">    <span class="keyword">auto</span> session = subscriber.Subscribe(</div><div class="line">        [&amp;](pubsub::Message <span class="keyword">const</span>&amp; m, pubsub::AckHandler h) {</div><div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot;Received message &quot;</span> &lt;&lt; m &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">          std::unique_lock&lt;std::mutex&gt; lk(mu);</div><div class="line">          ++message_count;</div><div class="line">          lk.unlock();</div><div class="line">          cv.notify_one();</div><div class="line">          std::move(h).ack();</div><div class="line">        });</div><div class="line">    <span class="comment">// Wait until at least one message has been received.</span></div><div class="line">    std::unique_lock&lt;std::mutex&gt; lk(mu);</div><div class="line">    cv.wait(lk, [&amp;message_count] { <span class="keywordflow">return</span> message_count &gt; 0; });</div><div class="line">    lk.unlock();</div><div class="line">    <span class="comment">// Cancel the subscription session.</span></div><div class="line">    session.cancel();</div><div class="line">    <span class="comment">// Wait for the session to complete, no more callbacks can happen after this</span></div><div class="line">    <span class="comment">// point.</span></div><div class="line">    <span class="keyword">auto</span> status = session.get();</div><div class="line">    <span class="comment">// Report any final status, blocking.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Message count: &quot;</span> &lt;&lt; message_count &lt;&lt; <span class="stringliteral">&quot;, status: &quot;</span> &lt;&lt; status</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Performance</dt><dd></dd></dl>
<p><code><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1Subscriber.html" title="Receive messages from the Cloud Pub/Sub service.">Subscriber</a></code> objects are relatively cheap to create, copy, and move. However, each <code><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1Subscriber.html" title="Receive messages from the Cloud Pub/Sub service.">Subscriber</a></code> object must be created with a <code>std::shared_ptr&lt;<a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberConnection.html" title="A connection to the Cloud Pub/Sub service to receive events.">SubscriberConnection</a>&gt;</code>, which itself is relatively expensive to create. Therefore, connection instances should be shared when possible. See the <code><a class="el" href="namespacegoogle_1_1cloud_1_1pubsub_1_1v1.html#af308a1dfac23f26b3f2c6c2a1096a743" title="Returns a SubscriberConnection object to work with Cloud Pub/Sub subscriber APIs.">MakeSubscriberConnection()</a></code> function and the <code><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberConnection.html" title="A connection to the Cloud Pub/Sub service to receive events.">SubscriberConnection</a></code> interface for more details.</p>
<dl class="section user"><dt>Thread Safety</dt><dd></dd></dl>
<p>Instances of this class created via copy-construction or copy-assignment share the underlying pool of connections. Access to these copies via multiple threads is guaranteed to work. Two threads operating on the same instance of this class is not guaranteed to work.</p>
<dl class="section user"><dt>Background Threads</dt><dd></dd></dl>
<p>This class uses the background threads configured via <code>ConnectionOptions</code>. Applications can create their own pool of background threads by (a) creating their own <a class="elRef" doxygen="/v/cmake-out/ci-fedora-install-31-clang-tidy/google/cloud/cloud.tag:https://googleapis.dev/google-cloud-common/master/" href="https://googleapis.dev/google-cloud-common/master/classgoogle_1_1cloud_1_1v1_1_1CompletionQueue.html">google::cloud::v1::CompletionQueue</a>, (b) setting this completion queue in <code>pubsub::ConnectionOptions::DisableBackgroundThreads()</code>, and (c) attaching any number of threads to the completion queue.</p>
<dl class="section user"><dt>Example: using a custom thread pool</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1pubsub.html">pubsub</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1pubsub.html">google::cloud::pubsub</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](std::string project_id, std::string subscription_id) {</div><div class="line">    <span class="comment">// Create our own completion queue to run the background activity, such as</span></div><div class="line">    <span class="comment">// flushing the publisher.</span></div><div class="line">    google::cloud::CompletionQueue cq;</div><div class="line">    <span class="comment">// Setup one or more of threads to service this completion queue. These must</span></div><div class="line">    <span class="comment">// remain running until all the work is done.</span></div><div class="line">    std::vector&lt;std::thread&gt; tasks;</div><div class="line">    std::generate_n(std::back_inserter(tasks), 4, [&amp;cq] {</div><div class="line">      <span class="keywordflow">return</span> std::thread([cq]() <span class="keyword">mutable</span> { cq.Run(); });</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> subscriber = pubsub::Subscriber(<a class="code" href="namespacegoogle_1_1cloud_1_1pubsub_1_1v1.html#af308a1dfac23f26b3f2c6c2a1096a743">pubsub::MakeSubscriberConnection</a>(</div><div class="line">        pubsub::Subscription(std::move(project_id), std::move(subscription_id)),</div><div class="line">        pubsub::SubscriptionOptions{},</div><div class="line">        <a class="code" href="namespacegoogle_1_1cloud_1_1pubsub_1_1v1.html#a6833bef0c593e2cfde6e1c9f2d745b94">pubsub::ConnectionOptions</a>{}.DisableBackgroundThreads(cq)));</div><div class="line"></div><div class="line">    <span class="comment">// Because this is an example we want to exit eventually, use a mutex and</span></div><div class="line">    <span class="comment">// condition variable to notify the current thread and stop the example.</span></div><div class="line">    std::mutex mu;</div><div class="line">    std::condition_variable cv;</div><div class="line">    <span class="keywordtype">int</span> count = 0;</div><div class="line">    <span class="keyword">auto</span> await_count = [&amp;] {</div><div class="line">      std::unique_lock&lt;std::mutex&gt; lk(mu);</div><div class="line">      cv.wait(lk, [&amp;] { <span class="keywordflow">return</span> count &gt;= 4; });</div><div class="line">    };</div><div class="line">    <span class="keyword">auto</span> increase_count = [&amp;] {</div><div class="line">      std::unique_lock&lt;std::mutex&gt; lk(mu);</div><div class="line">      <span class="keywordflow">if</span> (++count &gt;= 4) cv.notify_one();</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// Receive messages in the previously allocated thread pool.</span></div><div class="line">    <span class="keyword">auto</span> result = subscriber.Subscribe(</div><div class="line">        [&amp;](pubsub::Message <span class="keyword">const</span>&amp; m, pubsub::AckHandler h) {</div><div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot;Received message &quot;</span> &lt;&lt; m &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">          increase_count();</div><div class="line">          std::move(h).ack();</div><div class="line">        });</div><div class="line">    await_count();</div><div class="line">    result.cancel();</div><div class="line">    <span class="comment">// Report any final status, blocking until the subscription loop completes,</span></div><div class="line">    <span class="comment">// either with a failure or because it was canceled.</span></div><div class="line">    <span class="keyword">auto</span> status = result.get();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Message count=&quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot;, status=&quot;</span> &lt;&lt; status &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Shutdown the completion queue and join the threads</span></div><div class="line">    cq.Shutdown();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; t : tasks) <a class="codeRef" doxygen="/v/cmake-out/ci-fedora-install-31-clang-tidy/google/cloud/cloud.tag:https://googleapis.dev/google-cloud-common/master/" href="https://googleapis.dev/google-cloud-common/master/log_8cc.html#abc5627fb346314b5f14b10bdb6542da7">t</a>.join();</div><div class="line">  }</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Asynchronous Functions</dt><dd></dd></dl>
<p>Some of the member functions in this class return a <code>future&lt;T&gt;</code> (or <code>future&lt;StatusOr&lt;T&gt;&gt;</code>) object. Readers are probably familiar with <a href="https://en.cppreference.com/w/cpp/thread/future"><code>std::future&lt;T&gt;</code></a>. Our version adds a <code>.then()</code> function to attach a callback to the future, which is invoked when the future is satisfied. This function returns a <code>future&lt;U&gt;</code> where <code>U</code> is the return value of the attached function. More details in the <a class="elRef" doxygen="/v/cmake-out/ci-fedora-install-31-clang-tidy/google/cloud/cloud.tag:https://googleapis.dev/google-cloud-common/master/" href="https://googleapis.dev/google-cloud-common/master/classgoogle_1_1cloud_1_1v1_1_1future.html">google::cloud::v1::future</a> documentation.</p>
<dl class="section user"><dt>Error Handling</dt><dd></dd></dl>
<p>This class uses <code>StatusOr&lt;T&gt;</code> to report errors. When an operation fails to perform its work the returned <code>StatusOr&lt;T&gt;</code> contains the error details. If the <code>ok()</code> member function in the <code>StatusOr&lt;T&gt;</code> returns <code>true</code> then it contains the expected result. Please consult the <a class="elRef" doxygen="/v/cmake-out/ci-fedora-install-31-clang-tidy/google/cloud/cloud.tag:https://googleapis.dev/google-cloud-common/master/" href="https://googleapis.dev/google-cloud-common/master/classgoogle_1_1cloud_1_1v1_1_1StatusOr.html">google::cloud::v1::StatusOr</a> documentation for more details.</p>
<dl class="section user"><dt>Changing Retry Parameters Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1pubsub.html">pubsub</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1pubsub.html">google::cloud::pubsub</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](std::string project_id, std::string subscription_id) {</div><div class="line">    <span class="comment">// By default a subscriber will retry for 60 seconds, with an initial</span></div><div class="line">    <span class="comment">// backoff of 100ms, a maximum backoff of 60 seconds, and the backoff will</span></div><div class="line">    <span class="comment">// grow by 30% after each attempt. This changes those defaults.</span></div><div class="line">    <span class="keyword">auto</span> subscriber = pubsub::Subscriber(<a class="code" href="namespacegoogle_1_1cloud_1_1pubsub_1_1v1.html#af308a1dfac23f26b3f2c6c2a1096a743">pubsub::MakeSubscriberConnection</a>(</div><div class="line">        pubsub::Subscription(std::move(project_id), std::move(subscription_id)),</div><div class="line">        pubsub::SubscriptionOptions{}, <a class="code" href="namespacegoogle_1_1cloud_1_1pubsub_1_1v1.html#a6833bef0c593e2cfde6e1c9f2d745b94">pubsub::ConnectionOptions</a>{},</div><div class="line">        <a class="code" href="namespacegoogle_1_1cloud_1_1pubsub_1_1v1.html#a838db478485c19cba0f1e0e08ea30332">pubsub::LimitedTimeRetryPolicy</a>(</div><div class="line">            <span class="comment">/*maximum_duration=*/</span>std::chrono::minutes(1))</div><div class="line">            .clone(),</div><div class="line">        pubsub::ExponentialBackoffPolicy(</div><div class="line">            <span class="comment">/*initial_delay=*/</span>std::chrono::milliseconds(200),</div><div class="line">            <span class="comment">/*maximum_delay=*/</span>std::chrono::seconds(10),</div><div class="line">            <span class="comment">/*scaling=*/</span>2.0)</div><div class="line">            .clone()));</div><div class="line"></div><div class="line">    std::mutex mu;</div><div class="line">    std::condition_variable cv;</div><div class="line">    <span class="keywordtype">int</span> count = 0;</div><div class="line">    <span class="keyword">auto</span> constexpr kExpectedMessageCount = 1;</div><div class="line">    <span class="keyword">auto</span> handler = [&amp;](pubsub::Message <span class="keyword">const</span>&amp; m, pubsub::AckHandler h) {</div><div class="line">      std::move(h).ack();</div><div class="line">      {</div><div class="line">        std::lock_guard&lt;std::mutex&gt; lk(mu);</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Received message &quot;</span> &lt;&lt; m &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">        <span class="keywordflow">if</span> (++count &lt; kExpectedMessageCount) <span class="keywordflow">return</span>;</div><div class="line">      }</div><div class="line">      cv.notify_one();</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> session = subscriber.Subscribe(std::move(handler));</div><div class="line">    {</div><div class="line">      std::unique_lock&lt;std::mutex&gt; lk(mu);</div><div class="line">      cv.wait(lk, [&amp;] { <span class="keywordflow">return</span> count &gt;= kExpectedMessageCount; });</div><div class="line">    }</div><div class="line">    session.cancel();</div><div class="line">    <span class="keyword">auto</span> status = session.get();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Message count: &quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot;, status: &quot;</span> &lt;&lt; status &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriber_8h_source.html#l00094">94</a> of file <a class="el" href="subscriber_8h_source.html">subscriber.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2475af1f53fa45304228aeb6b79027fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2475af1f53fa45304228aeb6b79027fa">&#9670;&nbsp;</a></span>Subscriber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::cloud::pubsub::v1::Subscriber::Subscriber </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberConnection.html">SubscriberConnection</a> &gt;&#160;</td>
          <td class="paramname"><em>connection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="subscriber_8h_source.html#l00096">96</a> of file <a class="el" href="subscriber_8h_source.html">subscriber.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af1cc9e1d2af829a9864589d3e0b87241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1cc9e1d2af829a9864589d3e0b87241">&#9670;&nbsp;</a></span>Subscribe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Callable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">future&lt;Status&gt; google::cloud::pubsub::v1::Subscriber::Subscribe </td>
          <td>(</td>
          <td class="paramtype">Callable &amp;&amp;&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new session to receive messages from <code>subscription</code>. </p>
<dl class="section note"><dt>Note</dt><dd>Callable must be <code>CopyConstructible</code>, as <code>cb</code> will be stored in a <a href="https://en.cppreference.com/w/cpp/utility/functional/function"><code>std::function&lt;&gt;</code></a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>the callable invoked when messages are received. This must be usable to construct a <code>std::function&lt;void(pubsub::Message, pubsub::AckHandler)&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future that is satisfied when the session will no longer receive messages. For example because there was an unrecoverable error trying to receive data. Calling <code>.cancel()</code> in this object will (eventually) terminate the session too. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriber_8h_source.html#l00117">117</a> of file <a class="el" href="subscriber_8h_source.html">subscriber.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
