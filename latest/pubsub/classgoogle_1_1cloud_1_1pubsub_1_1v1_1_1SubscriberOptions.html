<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google Cloud Pub/Sub C++ Client: google::cloud::pubsub::v1::SubscriberOptions Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Google Cloud Pub/Sub C++ Client
   &#160;<span id="projectnumber">1.20.0(Beta)</span>
   </div>
   <div id="projectbrief">A C++ Client Library for Google Cloud Pub/Sub</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegoogle.html">google</a></li><li class="navelem"><a class="el" href="namespacegoogle_1_1cloud.html">cloud</a></li><li class="navelem"><a class="el" href="namespacegoogle_1_1cloud_1_1pubsub.html">pubsub</a></li><li class="navelem"><a class="el" href="namespacegoogle_1_1cloud_1_1pubsub_1_1v1.html">v1</a></li><li class="navelem"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html">SubscriberOptions</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">google::cloud::pubsub::v1::SubscriberOptions Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Configure how a <code><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1Subscriber.html" title="Receive messages from the Cloud Pub/Sub service.">Subscriber</a></code> handles incoming messages.  
 <a href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="subscriber__options_8h_source.html">google/cloud/pubsub/subscriber_options.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7c8ab95e93fad15eebbe158d5ba2da68"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html#a7c8ab95e93fad15eebbe158d5ba2da68">SubscriberOptions</a> ()=default</td></tr>
<tr class="separator:a7c8ab95e93fad15eebbe158d5ba2da68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708a826c38534f4d49ce617fee8ee4cc"><td class="memItemLeft" align="right" valign="top">std::chrono::seconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html#a708a826c38534f4d49ce617fee8ee4cc">max_deadline_time</a> () const</td></tr>
<tr class="memdesc:a708a826c38534f4d49ce617fee8ee4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum deadline for each incoming message.  <a href="#a708a826c38534f4d49ce617fee8ee4cc">More...</a><br /></td></tr>
<tr class="separator:a708a826c38534f4d49ce617fee8ee4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1aea2802611c50d6063ff0e77fc15c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html">SubscriberOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html#ae1aea2802611c50d6063ff0e77fc15c4">set_max_deadline_time</a> (std::chrono::seconds d)</td></tr>
<tr class="memdesc:ae1aea2802611c50d6063ff0e77fc15c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum deadline for incoming messages.  <a href="#ae1aea2802611c50d6063ff0e77fc15c4">More...</a><br /></td></tr>
<tr class="separator:ae1aea2802611c50d6063ff0e77fc15c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c99d2b94c9925c6674aa787460e87d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html">SubscriberOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html#a3c99d2b94c9925c6674aa787460e87d8">set_max_outstanding_messages</a> (std::int64_t <a class="el" href="subscription__message__queue__test_8cc.html#a21d557fb1a24b78862f142e9ee2b3324">message_count</a>)</td></tr>
<tr class="memdesc:a3c99d2b94c9925c6674aa787460e87d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of outstanding messages per streaming pull.  <a href="#a3c99d2b94c9925c6674aa787460e87d8">More...</a><br /></td></tr>
<tr class="separator:a3c99d2b94c9925c6674aa787460e87d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf14a2e78ff949630606ea726f6997e1"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html#acf14a2e78ff949630606ea726f6997e1">max_outstanding_messages</a> () const</td></tr>
<tr class="separator:acf14a2e78ff949630606ea726f6997e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987b45e8ac4cc5c8b62e4b126d3abe5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html">SubscriberOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html#a987b45e8ac4cc5c8b62e4b126d3abe5b">set_max_outstanding_bytes</a> (std::int64_t bytes)</td></tr>
<tr class="memdesc:a987b45e8ac4cc5c8b62e4b126d3abe5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of outstanding bytes per streaming pull.  <a href="#a987b45e8ac4cc5c8b62e4b126d3abe5b">More...</a><br /></td></tr>
<tr class="separator:a987b45e8ac4cc5c8b62e4b126d3abe5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe99d5d0718f666f67f056b2891e2c4a"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html#afe99d5d0718f666f67f056b2891e2c4a">max_outstanding_bytes</a> () const</td></tr>
<tr class="separator:afe99d5d0718f666f67f056b2891e2c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb636925ad1d695e7520f305bf66e0de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html">SubscriberOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html#afb636925ad1d695e7520f305bf66e0de">set_concurrency_watermarks</a> (std::size_t lwm, std::size_t hwm)</td></tr>
<tr class="memdesc:afb636925ad1d695e7520f305bf66e0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the high watermark and low watermarks for callback concurrency.  <a href="#afb636925ad1d695e7520f305bf66e0de">More...</a><br /></td></tr>
<tr class="separator:afb636925ad1d695e7520f305bf66e0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d0cf328faf8c25d85c3d54e069e740"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html#ac8d0cf328faf8c25d85c3d54e069e740">concurrency_lwm</a> () const</td></tr>
<tr class="separator:ac8d0cf328faf8c25d85c3d54e069e740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e78f889b7cfa5674d9dd4dc4d277e8b"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html#a0e78f889b7cfa5674d9dd4dc4d277e8b">concurrency_hwm</a> () const</td></tr>
<tr class="separator:a0e78f889b7cfa5674d9dd4dc4d277e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab3e39bb835a7d585f591d40f19f108"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html">SubscriberOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html#a0ab3e39bb835a7d585f591d40f19f108">set_shutdown_polling_period</a> (std::chrono::milliseconds v)</td></tr>
<tr class="memdesc:a0ab3e39bb835a7d585f591d40f19f108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control how often the session polls for automatic shutdowns.  <a href="#a0ab3e39bb835a7d585f591d40f19f108">More...</a><br /></td></tr>
<tr class="separator:a0ab3e39bb835a7d585f591d40f19f108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2012b6a99a59ad75970fb7a0a4c96b59"><td class="memItemLeft" align="right" valign="top">std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html#a2012b6a99a59ad75970fb7a0a4c96b59">shutdown_polling_period</a> () const</td></tr>
<tr class="separator:a2012b6a99a59ad75970fb7a0a4c96b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Configure how a <code><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1Subscriber.html" title="Receive messages from the Cloud Pub/Sub service.">Subscriber</a></code> handles incoming messages. </p>
<p>There are two main algorithms controlled by this function: the dispatching of application callbacks, and requesting more data from the service.</p>
<dl class="section user"><dt>Callback Concurrency Control</dt><dd></dd></dl>
<p>The subscription configuration determines the upper limit (set <code><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html#afb636925ad1d695e7520f305bf66e0de" title="Set the high watermark and low watermarks for callback concurrency.">set_concurrency_watermarks()</a></code>) how many callbacks are <em>scheduled</em> at a time. As long as this limit is not reached the library will continue to schedule callbacks, once the limit is reached the library will wait until the number of executing callbacks goes below the low watermark.</p>
<p>A callback is "executing" until the <code><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1AckHandler.html#ae0cba314ccf75c7e6f048d3dfaec995b" title="Acknowledge the message and return any (unrecoverable) RPC errors.">AckHandler::ack()</a></code> or <code><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1AckHandler.html#af59d345070792526791429611e5a25c8" title="Reject the message and return any (unrecoverable) RPC errors.">AckHandler::nack()</a></code> function is called on the associated <code><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1AckHandler.html" title="Defines the interface to acknowledge and reject messages.">AckHandler</a></code>. Applications can use this to move long-running computations out of the library internal thread pool.</p>
<p>Note that callbacks are "scheduled", but they may not immediately execute. For example, callbacks may be sequenced if the concurrency control parameters are higher than the number of I/O threads configured in the <code><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberConnection.html" title="A connection to the Cloud Pub/Sub service to receive events.">SubscriberConnection</a></code>.</p>
<p>The default value for the concurrency high watermarks is set to the value returned by <code>std::thread::hardware_concurrency()</code> (or 4 if your standard library returns <code>0</code> for this parameter).</p>
<dl class="section user"><dt>Message Flow Control</dt><dd></dd></dl>
<p>The subscription will request more messages from the service as long as both the outstanding message count (see <code>set_message_count_watermarks()</code>) and the number of bytes in the outstanding messages (see <code>set_message_size_watermarks()</code>) are below the high watermarks for these values.</p>
<p>Once either of the high watermarks are breached the library will wait until <b>both</b> the values are below their low watermarks before requesting more messages from the service.</p>
<p>In this algorithm a message is outstanding until the <code><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1AckHandler.html#ae0cba314ccf75c7e6f048d3dfaec995b" title="Acknowledge the message and return any (unrecoverable) RPC errors.">AckHandler::ack()</a></code> or <code><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1AckHandler.html#af59d345070792526791429611e5a25c8" title="Reject the message and return any (unrecoverable) RPC errors.">AckHandler::nack()</a></code> function is called on the associated <code><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1AckHandler.html" title="Defines the interface to acknowledge and reject messages.">AckHandler</a></code>. Note that if the concurrency control algorithm has not scheduled a callback this can also put back pressure on the flow control algorithm.</p>
<dl class="section user"><dt>Example: setting the concurrency control parameters</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1pubsub.html">pubsub</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1pubsub.html">google::cloud::pubsub</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](std::string project_id, std::string subscription_id) {</div><div class="line">    <span class="comment">// Create a subscriber with 16 threads handling I/O work, by default the</span></div><div class="line">    <span class="comment">// library creates `std::thread::hardware_concurrency()` threads.</span></div><div class="line">    <span class="keyword">auto</span> subscriber = pubsub::Subscriber(<a class="code" href="namespacegoogle_1_1cloud_1_1pubsub_1_1v1.html#a4d36a0acd0c273b491563d99b7f370fb">pubsub::MakeSubscriberConnection</a>(</div><div class="line">        pubsub::Subscription(std::move(project_id), std::move(subscription_id)),</div><div class="line">        pubsub::SubscriberOptions{}.set_concurrency_watermarks(</div><div class="line">            <span class="comment">/*lwm=*/</span>4, <span class="comment">/*hwm=*/</span>8),</div><div class="line">        <a class="code" href="namespacegoogle_1_1cloud_1_1pubsub_1_1v1.html#a6833bef0c593e2cfde6e1c9f2d745b94">pubsub::ConnectionOptions</a>{}.set_background_thread_pool_size(16)));</div><div class="line"></div><div class="line">    std::mutex mu;</div><div class="line">    std::condition_variable cv;</div><div class="line">    <span class="keywordtype">int</span> count = 0;</div><div class="line">    <span class="keyword">auto</span> constexpr kExpectedMessageCount = 4;</div><div class="line">    <span class="keyword">auto</span> handler = [&amp;](pubsub::Message <span class="keyword">const</span>&amp; m, pubsub::AckHandler h) {</div><div class="line">      <span class="comment">// This handler executes in the I/O threads, applications could use,</span></div><div class="line">      <span class="comment">// std::async(), a thread-pool,</span></div><div class="line">      <span class="comment">// google::cloud::CompletionQueue::RunAsync(), or any other mechanism to</span></div><div class="line">      <span class="comment">// transfer the execution to other threads.</span></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Received message &quot;</span> &lt;&lt; m &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">      std::move(h).ack();</div><div class="line">      {</div><div class="line">        std::lock_guard&lt;std::mutex&gt; lk(mu);</div><div class="line">        <span class="keywordflow">if</span> (++count &lt; kExpectedMessageCount) <span class="keywordflow">return</span>;</div><div class="line">      }</div><div class="line">      cv.notify_one();</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// Create a subscription where up to 8 messages are handled concurrently. By</span></div><div class="line">    <span class="comment">// default the library uses `0` and `std::thread::hardwarde_concurrency()`</span></div><div class="line">    <span class="comment">// for the concurrency watermarks.</span></div><div class="line">    <span class="keyword">auto</span> session = subscriber.Subscribe(std::move(handler));</div><div class="line">    {</div><div class="line">      std::unique_lock&lt;std::mutex&gt; lk(mu);</div><div class="line">      cv.wait(lk, [&amp;] { <span class="keywordflow">return</span> count &gt;= kExpectedMessageCount; });</div><div class="line">    }</div><div class="line">    session.cancel();</div><div class="line">    <span class="keyword">auto</span> status = session.get();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Message count: &quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot;, status: &quot;</span> &lt;&lt; status &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Example: setting the flow control parameters</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1pubsub.html">pubsub</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1pubsub.html">google::cloud::pubsub</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](std::string project_id, std::string subscription_id) {</div><div class="line">    <span class="comment">// Change the flow control watermarks, by default the client library uses</span></div><div class="line">    <span class="comment">// 0 and 1,000 for the message count watermarks, and 0 and 10MiB for the</span></div><div class="line">    <span class="comment">// size watermarks. Recall that the library stops requesting messages if</span></div><div class="line">    <span class="comment">// any of the high watermarks are reached, and the library resumes</span></div><div class="line">    <span class="comment">// requesting messages when *both* low watermarks are reached.</span></div><div class="line">    <span class="keyword">auto</span> constexpr kMiB = 1024 * 1024L;</div><div class="line">    <span class="keyword">auto</span> subscriber = pubsub::Subscriber(<a class="code" href="namespacegoogle_1_1cloud_1_1pubsub_1_1v1.html#a4d36a0acd0c273b491563d99b7f370fb">pubsub::MakeSubscriberConnection</a>(</div><div class="line">        pubsub::Subscription(std::move(project_id), std::move(subscription_id)),</div><div class="line">        pubsub::SubscriberOptions{}</div><div class="line">            .set_max_outstanding_messages(1000)</div><div class="line">            .set_max_outstanding_bytes(8 * kMiB)));</div><div class="line"></div><div class="line">    std::mutex mu;</div><div class="line">    std::condition_variable cv;</div><div class="line">    <span class="keywordtype">int</span> count = 0;</div><div class="line">    <span class="keyword">auto</span> constexpr kExpectedMessageCount = 4;</div><div class="line">    <span class="keyword">auto</span> handler = [&amp;](pubsub::Message <span class="keyword">const</span>&amp; m, pubsub::AckHandler h) {</div><div class="line">      std::move(h).ack();</div><div class="line">      {</div><div class="line">        std::lock_guard&lt;std::mutex&gt; lk(mu);</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Received message [&quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot;] &quot;</span> &lt;&lt; m.data() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">        <span class="keywordflow">if</span> (++count &lt; kExpectedMessageCount) <span class="keywordflow">return</span>;</div><div class="line">      }</div><div class="line">      cv.notify_one();</div><div class="line">    };</div><div class="line">    <span class="keyword">auto</span> session = subscriber.Subscribe(std::move(handler));</div><div class="line">    {</div><div class="line">      std::unique_lock&lt;std::mutex&gt; lk(mu);</div><div class="line">      cv.wait(lk, [&amp;] { <span class="keywordflow">return</span> count &gt;= kExpectedMessageCount; });</div><div class="line">    }</div><div class="line">    session.cancel();</div><div class="line">    <span class="keyword">auto</span> status = session.get();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Message count: &quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot;, status: &quot;</span> &lt;&lt; status &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriber__options_8h_source.html#l00078">78</a> of file <a class="el" href="subscriber__options_8h_source.html">subscriber_options.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7c8ab95e93fad15eebbe158d5ba2da68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8ab95e93fad15eebbe158d5ba2da68">&#9670;&nbsp;</a></span>SubscriberOptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::cloud::pubsub::v1::SubscriberOptions::SubscriberOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0e78f889b7cfa5674d9dd4dc4d277e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e78f889b7cfa5674d9dd4dc4d277e8b">&#9670;&nbsp;</a></span>concurrency_hwm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t google::cloud::pubsub::v1::SubscriberOptions::concurrency_hwm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="subscriber__options_8h_source.html#l00174">174</a> of file <a class="el" href="subscriber__options_8h_source.html">subscriber_options.h</a>.</p>

</div>
</div>
<a id="ac8d0cf328faf8c25d85c3d54e069e740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d0cf328faf8c25d85c3d54e069e740">&#9670;&nbsp;</a></span>concurrency_lwm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t google::cloud::pubsub::v1::SubscriberOptions::concurrency_lwm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="subscriber__options_8h_source.html#l00173">173</a> of file <a class="el" href="subscriber__options_8h_source.html">subscriber_options.h</a>.</p>

</div>
</div>
<a id="a708a826c38534f4d49ce617fee8ee4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708a826c38534f4d49ce617fee8ee4cc">&#9670;&nbsp;</a></span>max_deadline_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::seconds google::cloud::pubsub::v1::SubscriberOptions::max_deadline_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum deadline for each incoming message. </p>
<p>Configure how long does the application have to respond (ACK or NACK) an incoming message. Note that this might be longer, or shorter, than the deadline configured in the server-side subscription.</p>
<p>The value <code>0</code> is reserved to leave the deadline unmodified and just use the server-side configuration.</p>
<dl class="section note"><dt>Note</dt><dd>The deadline applies to each message as it is delivered to the application, thus, if the library receives a batch of N messages their deadline for all the messages is extended repeatedly. Only once the message is delivered to a callback does the deadline become immutable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriber__options_8h_source.html#l00097">97</a> of file <a class="el" href="subscriber__options_8h_source.html">subscriber_options.h</a>.</p>

</div>
</div>
<a id="afe99d5d0718f666f67f056b2891e2c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe99d5d0718f666f67f056b2891e2c4a">&#9670;&nbsp;</a></span>max_outstanding_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t google::cloud::pubsub::v1::SubscriberOptions::max_outstanding_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="subscriber__options_8h_source.html#l00139">139</a> of file <a class="el" href="subscriber__options_8h_source.html">subscriber_options.h</a>.</p>

</div>
</div>
<a id="acf14a2e78ff949630606ea726f6997e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf14a2e78ff949630606ea726f6997e1">&#9670;&nbsp;</a></span>max_outstanding_messages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t google::cloud::pubsub::v1::SubscriberOptions::max_outstanding_messages </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="subscriber__options_8h_source.html#l00120">120</a> of file <a class="el" href="subscriber__options_8h_source.html">subscriber_options.h</a>.</p>

</div>
</div>
<a id="afb636925ad1d695e7520f305bf66e0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb636925ad1d695e7520f305bf66e0de">&#9670;&nbsp;</a></span>set_concurrency_watermarks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html">SubscriberOptions</a> &amp; google::cloud::pubsub::v1::SubscriberOptions::set_concurrency_watermarks </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>lwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>hwm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the high watermark and low watermarks for callback concurrency. </p>
<p>The Cloud Pub/Sub C++ client library will schedule parallel callbacks as long as the number of outstanding callbacks is less than the high watermark. Once the watermark is reached the client will not resume scheduling callbacks until the number of outstanding callbacks is at or below the low watermark. Using hysteresis prevents instability.</p>
<p>Note that this controls the number of callbacks <em>scheduled</em>, not the number of callbacks actually executing at a time. The application needs to create (or configure) the background threads pool with enough parallelism to execute more than one callback at a time.</p>
<p>Some applications many want to share a thread pool across many subscriptions, the additional level of control (scheduled vs. running callbacks) allows applications, for example, to ensure that at most <code>K</code> threads in the pool are used by any given subscription.</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1pubsub.html">pubsub</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1pubsub.html">google::cloud::pubsub</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](std::string project_id, std::string subscription_id) {</div><div class="line">    <span class="comment">// Create a subscriber with 16 threads handling I/O work, by default the</span></div><div class="line">    <span class="comment">// library creates `std::thread::hardware_concurrency()` threads.</span></div><div class="line">    <span class="keyword">auto</span> subscriber = pubsub::Subscriber(<a class="code" href="namespacegoogle_1_1cloud_1_1pubsub_1_1v1.html#a4d36a0acd0c273b491563d99b7f370fb">pubsub::MakeSubscriberConnection</a>(</div><div class="line">        pubsub::Subscription(std::move(project_id), std::move(subscription_id)),</div><div class="line">        pubsub::SubscriberOptions{}.set_concurrency_watermarks(</div><div class="line">            <span class="comment">/*lwm=*/</span>4, <span class="comment">/*hwm=*/</span>8),</div><div class="line">        <a class="code" href="namespacegoogle_1_1cloud_1_1pubsub_1_1v1.html#a6833bef0c593e2cfde6e1c9f2d745b94">pubsub::ConnectionOptions</a>{}.set_background_thread_pool_size(16)));</div><div class="line"></div><div class="line">    std::mutex mu;</div><div class="line">    std::condition_variable cv;</div><div class="line">    <span class="keywordtype">int</span> count = 0;</div><div class="line">    <span class="keyword">auto</span> constexpr kExpectedMessageCount = 4;</div><div class="line">    <span class="keyword">auto</span> handler = [&amp;](pubsub::Message <span class="keyword">const</span>&amp; m, pubsub::AckHandler h) {</div><div class="line">      <span class="comment">// This handler executes in the I/O threads, applications could use,</span></div><div class="line">      <span class="comment">// std::async(), a thread-pool,</span></div><div class="line">      <span class="comment">// google::cloud::CompletionQueue::RunAsync(), or any other mechanism to</span></div><div class="line">      <span class="comment">// transfer the execution to other threads.</span></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Received message &quot;</span> &lt;&lt; m &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">      std::move(h).ack();</div><div class="line">      {</div><div class="line">        std::lock_guard&lt;std::mutex&gt; lk(mu);</div><div class="line">        <span class="keywordflow">if</span> (++count &lt; kExpectedMessageCount) <span class="keywordflow">return</span>;</div><div class="line">      }</div><div class="line">      cv.notify_one();</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// Create a subscription where up to 8 messages are handled concurrently. By</span></div><div class="line">    <span class="comment">// default the library uses `0` and `std::thread::hardwarde_concurrency()`</span></div><div class="line">    <span class="comment">// for the concurrency watermarks.</span></div><div class="line">    <span class="keyword">auto</span> session = subscriber.Subscribe(std::move(handler));</div><div class="line">    {</div><div class="line">      std::unique_lock&lt;std::mutex&gt; lk(mu);</div><div class="line">      cv.wait(lk, [&amp;] { <span class="keywordflow">return</span> count &gt;= kExpectedMessageCount; });</div><div class="line">    }</div><div class="line">    session.cancel();</div><div class="line">    <span class="keyword">auto</span> status = session.get();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Message count: &quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot;, status: &quot;</span> &lt;&lt; status &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>applications that want to have a single outstanding callback can set these parameters to <code>lwm==0</code> and <code>hwm==1</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hwm</td><td>the high watermark, if this parameter is <code>0</code> the high watermark is set to <code>1</code>, to avoid starvation for the callbacks </td></tr>
    <tr><td class="paramname">lwm</td><td>the low watermark, if this parameter greater than <code>hwm</code> then the low watermark is set to the same value as the high watermark </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="subscriber__options_8cc_source.html#l00035">35</a> of file <a class="el" href="subscriber__options_8cc_source.html">subscriber_options.cc</a>.</p>

</div>
</div>
<a id="ae1aea2802611c50d6063ff0e77fc15c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1aea2802611c50d6063ff0e77fc15c4">&#9670;&nbsp;</a></span>set_max_deadline_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html">SubscriberOptions</a>&amp; google::cloud::pubsub::v1::SubscriberOptions::set_max_deadline_time </td>
          <td>(</td>
          <td class="paramtype">std::chrono::seconds&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum deadline for incoming messages. </p>

<p class="definition">Definition at line <a class="el" href="subscriber__options_8h_source.html#l00100">100</a> of file <a class="el" href="subscriber__options_8h_source.html">subscriber_options.h</a>.</p>

</div>
</div>
<a id="a987b45e8ac4cc5c8b62e4b126d3abe5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987b45e8ac4cc5c8b62e4b126d3abe5b">&#9670;&nbsp;</a></span>set_max_outstanding_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html">SubscriberOptions</a> &amp; google::cloud::pubsub::v1::SubscriberOptions::set_max_outstanding_bytes </td>
          <td>(</td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum number of outstanding bytes per streaming pull. </p>
<p>The Cloud Pub/Sub C++ client library uses streaming pull requests to receive messages from the service. The service will stop delivering messages if <code>bytes</code> or more worth of messages have not been acked nor nacked.</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1pubsub.html">pubsub</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1pubsub.html">google::cloud::pubsub</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](std::string project_id, std::string subscription_id) {</div><div class="line">    <span class="comment">// Change the flow control watermarks, by default the client library uses</span></div><div class="line">    <span class="comment">// 0 and 1,000 for the message count watermarks, and 0 and 10MiB for the</span></div><div class="line">    <span class="comment">// size watermarks. Recall that the library stops requesting messages if</span></div><div class="line">    <span class="comment">// any of the high watermarks are reached, and the library resumes</span></div><div class="line">    <span class="comment">// requesting messages when *both* low watermarks are reached.</span></div><div class="line">    <span class="keyword">auto</span> constexpr kMiB = 1024 * 1024L;</div><div class="line">    <span class="keyword">auto</span> subscriber = pubsub::Subscriber(<a class="code" href="namespacegoogle_1_1cloud_1_1pubsub_1_1v1.html#a4d36a0acd0c273b491563d99b7f370fb">pubsub::MakeSubscriberConnection</a>(</div><div class="line">        pubsub::Subscription(std::move(project_id), std::move(subscription_id)),</div><div class="line">        pubsub::SubscriberOptions{}</div><div class="line">            .set_max_outstanding_messages(1000)</div><div class="line">            .set_max_outstanding_bytes(8 * kMiB)));</div><div class="line"></div><div class="line">    std::mutex mu;</div><div class="line">    std::condition_variable cv;</div><div class="line">    <span class="keywordtype">int</span> count = 0;</div><div class="line">    <span class="keyword">auto</span> constexpr kExpectedMessageCount = 4;</div><div class="line">    <span class="keyword">auto</span> handler = [&amp;](pubsub::Message <span class="keyword">const</span>&amp; m, pubsub::AckHandler h) {</div><div class="line">      std::move(h).ack();</div><div class="line">      {</div><div class="line">        std::lock_guard&lt;std::mutex&gt; lk(mu);</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Received message [&quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot;] &quot;</span> &lt;&lt; m.data() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">        <span class="keywordflow">if</span> (++count &lt; kExpectedMessageCount) <span class="keywordflow">return</span>;</div><div class="line">      }</div><div class="line">      cv.notify_one();</div><div class="line">    };</div><div class="line">    <span class="keyword">auto</span> session = subscriber.Subscribe(std::move(handler));</div><div class="line">    {</div><div class="line">      std::unique_lock&lt;std::mutex&gt; lk(mu);</div><div class="line">      cv.wait(lk, [&amp;] { <span class="keywordflow">return</span> count &gt;= kExpectedMessageCount; });</div><div class="line">    }</div><div class="line">    session.cancel();</div><div class="line">    <span class="keyword">auto</span> status = session.get();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Message count: &quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot;, status: &quot;</span> &lt;&lt; status &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>the maximum number of bytes outstanding, use 0 or negative numbers to make the number of bytes unlimited. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="subscriber__options_8cc_source.html#l00029">29</a> of file <a class="el" href="subscriber__options_8cc_source.html">subscriber_options.cc</a>.</p>

</div>
</div>
<a id="a3c99d2b94c9925c6674aa787460e87d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c99d2b94c9925c6674aa787460e87d8">&#9670;&nbsp;</a></span>set_max_outstanding_messages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html">SubscriberOptions</a> &amp; google::cloud::pubsub::v1::SubscriberOptions::set_max_outstanding_messages </td>
          <td>(</td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>message_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum number of outstanding messages per streaming pull. </p>
<p>The Cloud Pub/Sub C++ client library uses streaming pull requests to receive messages from the service. The service will stop delivering messages if <code>message_count</code> or more messages have not been acked nor nacked.</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1pubsub.html">pubsub</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1pubsub.html">google::cloud::pubsub</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](std::string project_id, std::string subscription_id) {</div><div class="line">    <span class="comment">// Change the flow control watermarks, by default the client library uses</span></div><div class="line">    <span class="comment">// 0 and 1,000 for the message count watermarks, and 0 and 10MiB for the</span></div><div class="line">    <span class="comment">// size watermarks. Recall that the library stops requesting messages if</span></div><div class="line">    <span class="comment">// any of the high watermarks are reached, and the library resumes</span></div><div class="line">    <span class="comment">// requesting messages when *both* low watermarks are reached.</span></div><div class="line">    <span class="keyword">auto</span> constexpr kMiB = 1024 * 1024L;</div><div class="line">    <span class="keyword">auto</span> subscriber = pubsub::Subscriber(<a class="code" href="namespacegoogle_1_1cloud_1_1pubsub_1_1v1.html#a4d36a0acd0c273b491563d99b7f370fb">pubsub::MakeSubscriberConnection</a>(</div><div class="line">        pubsub::Subscription(std::move(project_id), std::move(subscription_id)),</div><div class="line">        pubsub::SubscriberOptions{}</div><div class="line">            .set_max_outstanding_messages(1000)</div><div class="line">            .set_max_outstanding_bytes(8 * kMiB)));</div><div class="line"></div><div class="line">    std::mutex mu;</div><div class="line">    std::condition_variable cv;</div><div class="line">    <span class="keywordtype">int</span> count = 0;</div><div class="line">    <span class="keyword">auto</span> constexpr kExpectedMessageCount = 4;</div><div class="line">    <span class="keyword">auto</span> handler = [&amp;](pubsub::Message <span class="keyword">const</span>&amp; m, pubsub::AckHandler h) {</div><div class="line">      std::move(h).ack();</div><div class="line">      {</div><div class="line">        std::lock_guard&lt;std::mutex&gt; lk(mu);</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Received message [&quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot;] &quot;</span> &lt;&lt; m.data() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">        <span class="keywordflow">if</span> (++count &lt; kExpectedMessageCount) <span class="keywordflow">return</span>;</div><div class="line">      }</div><div class="line">      cv.notify_one();</div><div class="line">    };</div><div class="line">    <span class="keyword">auto</span> session = subscriber.Subscribe(std::move(handler));</div><div class="line">    {</div><div class="line">      std::unique_lock&lt;std::mutex&gt; lk(mu);</div><div class="line">      cv.wait(lk, [&amp;] { <span class="keywordflow">return</span> count &gt;= kExpectedMessageCount; });</div><div class="line">    }</div><div class="line">    session.cancel();</div><div class="line">    <span class="keyword">auto</span> status = session.get();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Message count: &quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot;, status: &quot;</span> &lt;&lt; status &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_count</td><td>the maximum number of messages outstanding, use 0 or negative numbers to make the message count unlimited. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="subscriber__options_8cc_source.html#l00023">23</a> of file <a class="el" href="subscriber__options_8cc_source.html">subscriber_options.cc</a>.</p>

</div>
</div>
<a id="a0ab3e39bb835a7d585f591d40f19f108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab3e39bb835a7d585f591d40f19f108">&#9670;&nbsp;</a></span>set_shutdown_polling_period()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgoogle_1_1cloud_1_1pubsub_1_1v1_1_1SubscriberOptions.html">SubscriberOptions</a>&amp; google::cloud::pubsub::v1::SubscriberOptions::set_shutdown_polling_period </td>
          <td>(</td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Control how often the session polls for automatic shutdowns. </p>
<p>Applications can shutdown a session by calling <code>.cancel()</code> on the returned <code>future&lt;Status&gt;</code>. In addition, applications can fire &amp; forget a session, which is only shutdown once the completion queue servicing the session shuts down. In this latter case the session polls periodically to detect if the CQ has shutdown. This controls how often this polling happens. </p>

<p class="definition">Definition at line <a class="el" href="subscriber__options_8h_source.html#l00185">185</a> of file <a class="el" href="subscriber__options_8h_source.html">subscriber_options.h</a>.</p>

</div>
</div>
<a id="a2012b6a99a59ad75970fb7a0a4c96b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2012b6a99a59ad75970fb7a0a4c96b59">&#9670;&nbsp;</a></span>shutdown_polling_period()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::milliseconds google::cloud::pubsub::v1::SubscriberOptions::shutdown_polling_period </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="subscriber__options_8h_source.html#l00189">189</a> of file <a class="el" href="subscriber__options_8h_source.html">subscriber_options.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
