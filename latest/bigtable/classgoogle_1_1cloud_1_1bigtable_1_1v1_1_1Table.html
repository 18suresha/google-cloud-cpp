<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google Cloud Bigtable C++ Client: google::cloud::bigtable::v1::Table Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Google Cloud Bigtable C++ Client
   &#160;<span id="projectnumber">1.22.0</span>
   </div>
   <div id="projectbrief">A C++ Client Library for Google Cloud Bigtable</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegoogle.html">google</a></li><li class="navelem"><a class="el" href="namespacegoogle_1_1cloud.html">cloud</a></li><li class="navelem"><a class="el" href="namespacegoogle_1_1cloud_1_1bigtable.html">bigtable</a></li><li class="navelem"><a class="el" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html">v1</a></li><li class="navelem"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">Table</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">google::cloud::bigtable::v1::Table Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The main interface to interact with data in a Cloud Bigtable table.  
 <a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="table_8h_source.html">google/cloud/bigtable/table.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6f2ea4d0c1c5119ba42d0ba4164f74b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a6f2ea4d0c1c5119ba42d0ba4164f74b3">Table</a> (std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1DataClient.html">DataClient</a> &gt; client, std::string const &amp;<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a83b9f3b405faa95ddb3c57e8e3820fc8">table_id</a>)</td></tr>
<tr class="memdesc:a6f2ea4d0c1c5119ba42d0ba4164f74b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with default policies.  <a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a6f2ea4d0c1c5119ba42d0ba4164f74b3">More...</a><br /></td></tr>
<tr class="separator:a6f2ea4d0c1c5119ba42d0ba4164f74b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798688c85b85cfc68b1349d3da4e11db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a798688c85b85cfc68b1349d3da4e11db">Table</a> (std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1DataClient.html">DataClient</a> &gt; client, std::string <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a02302c69a492b552513bf5e4cf6f1b64">app_profile_id</a>, std::string const &amp;<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a83b9f3b405faa95ddb3c57e8e3820fc8">table_id</a>)</td></tr>
<tr class="memdesc:a798688c85b85cfc68b1349d3da4e11db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with default policies.  <a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a798688c85b85cfc68b1349d3da4e11db">More...</a><br /></td></tr>
<tr class="separator:a798688c85b85cfc68b1349d3da4e11db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfca93418b2ebc85fa417ee9a4dfb07"><td class="memTemplParams" colspan="2">template&lt;typename... Policies, typename std::enable_if&lt; ValidPolicies&lt; Policies... &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:addfca93418b2ebc85fa417ee9a4dfb07"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#addfca93418b2ebc85fa417ee9a4dfb07">Table</a> (std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1DataClient.html">DataClient</a> &gt; client, std::string const &amp;<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a83b9f3b405faa95ddb3c57e8e3820fc8">table_id</a>, Policies &amp;&amp;... policies)</td></tr>
<tr class="memdesc:addfca93418b2ebc85fa417ee9a4dfb07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with explicit policies.  <a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#addfca93418b2ebc85fa417ee9a4dfb07">More...</a><br /></td></tr>
<tr class="separator:addfca93418b2ebc85fa417ee9a4dfb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8fe1f18600a4bb24d11857eadb5cb4"><td class="memTemplParams" colspan="2">template&lt;typename... Policies, typename std::enable_if&lt; ValidPolicies&lt; Policies... &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a1f8fe1f18600a4bb24d11857eadb5cb4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a1f8fe1f18600a4bb24d11857eadb5cb4">Table</a> (std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1DataClient.html">DataClient</a> &gt; client, std::string <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a02302c69a492b552513bf5e4cf6f1b64">app_profile_id</a>, std::string const &amp;<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a83b9f3b405faa95ddb3c57e8e3820fc8">table_id</a>, Policies &amp;&amp;... policies)</td></tr>
<tr class="memdesc:a1f8fe1f18600a4bb24d11857eadb5cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with explicit policies.  <a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a1f8fe1f18600a4bb24d11857eadb5cb4">More...</a><br /></td></tr>
<tr class="separator:a1f8fe1f18600a4bb24d11857eadb5cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8df03de4aae0d013aa2a133631c33b9"><td class="memItemLeft" align="right" valign="top">std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#aa8df03de4aae0d013aa2a133631c33b9">table_name</a> () const</td></tr>
<tr class="separator:aa8df03de4aae0d013aa2a133631c33b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02302c69a492b552513bf5e4cf6f1b64"><td class="memItemLeft" align="right" valign="top">std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a02302c69a492b552513bf5e4cf6f1b64">app_profile_id</a> () const</td></tr>
<tr class="separator:a02302c69a492b552513bf5e4cf6f1b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430b10cee0704099c000f99418676916"><td class="memItemLeft" align="right" valign="top">std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a430b10cee0704099c000f99418676916">project_id</a> () const</td></tr>
<tr class="separator:a430b10cee0704099c000f99418676916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5c8c8c128e5533205d41829753d439"><td class="memItemLeft" align="right" valign="top">std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a7a5c8c8c128e5533205d41829753d439">instance_id</a> () const</td></tr>
<tr class="separator:a7a5c8c8c128e5533205d41829753d439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b9f3b405faa95ddb3c57e8e3820fc8"><td class="memItemLeft" align="right" valign="top">std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a83b9f3b405faa95ddb3c57e8e3820fc8">table_id</a> () const</td></tr>
<tr class="separator:a83b9f3b405faa95ddb3c57e8e3820fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db958030bc117ab00971d196fbd1236"><td class="memItemLeft" align="right" valign="top">Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a6db958030bc117ab00971d196fbd1236">Apply</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1SingleRowMutation.html">SingleRowMutation</a> mut)</td></tr>
<tr class="memdesc:a6db958030bc117ab00971d196fbd1236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to apply the mutation to a row.  <a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a6db958030bc117ab00971d196fbd1236">More...</a><br /></td></tr>
<tr class="separator:a6db958030bc117ab00971d196fbd1236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2241952cb3348bbc524bc6591c593cae"><td class="memItemLeft" align="right" valign="top">future&lt; Status &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a2241952cb3348bbc524bc6591c593cae">AsyncApply</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1SingleRowMutation.html">SingleRowMutation</a> mut, CompletionQueue &amp;cq)</td></tr>
<tr class="memdesc:a2241952cb3348bbc524bc6591c593cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes asynchronous attempts to apply the mutation to a row.  <a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a2241952cb3348bbc524bc6591c593cae">More...</a><br /></td></tr>
<tr class="separator:a2241952cb3348bbc524bc6591c593cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244ced8a939369887e19ad934f0d7644"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1FailedMutation.html">FailedMutation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a244ced8a939369887e19ad934f0d7644">BulkApply</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1BulkMutation.html">BulkMutation</a> mut)</td></tr>
<tr class="memdesc:a244ced8a939369887e19ad934f0d7644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to apply mutations to multiple rows.  <a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a244ced8a939369887e19ad934f0d7644">More...</a><br /></td></tr>
<tr class="separator:a244ced8a939369887e19ad934f0d7644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b2a091eccd88d9762d93f874c98fef"><td class="memItemLeft" align="right" valign="top">future&lt; std::vector&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1FailedMutation.html">FailedMutation</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a16b2a091eccd88d9762d93f874c98fef">AsyncBulkApply</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1BulkMutation.html">BulkMutation</a> mut, CompletionQueue &amp;cq)</td></tr>
<tr class="memdesc:a16b2a091eccd88d9762d93f874c98fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes asynchronous attempts to apply mutations to multiple rows.  <a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a16b2a091eccd88d9762d93f874c98fef">More...</a><br /></td></tr>
<tr class="separator:a16b2a091eccd88d9762d93f874c98fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6306c3f4c31e27be8432b279c12c27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1RowReader.html">RowReader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#adc6306c3f4c31e27be8432b279c12c27">ReadRows</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1RowSet.html">RowSet</a> row_set, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Filter.html">Filter</a> filter)</td></tr>
<tr class="memdesc:adc6306c3f4c31e27be8432b279c12c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a set of rows from the table.  <a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#adc6306c3f4c31e27be8432b279c12c27">More...</a><br /></td></tr>
<tr class="separator:adc6306c3f4c31e27be8432b279c12c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d62110bb365cf0db97a80560302ef1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1RowReader.html">RowReader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a07d62110bb365cf0db97a80560302ef1">ReadRows</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1RowSet.html">RowSet</a> row_set, std::int64_t rows_limit, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Filter.html">Filter</a> filter)</td></tr>
<tr class="memdesc:a07d62110bb365cf0db97a80560302ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a limited set of rows from the table.  <a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a07d62110bb365cf0db97a80560302ef1">More...</a><br /></td></tr>
<tr class="separator:a07d62110bb365cf0db97a80560302ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbbbab420ecee307d1283fcd7d2e1f5"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; std::pair&lt; bool, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Row.html">Row</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a2fbbbab420ecee307d1283fcd7d2e1f5">ReadRow</a> (std::string row_key, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Filter.html">Filter</a> filter)</td></tr>
<tr class="memdesc:a2fbbbab420ecee307d1283fcd7d2e1f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and return a single row from the table.  <a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a2fbbbab420ecee307d1283fcd7d2e1f5">More...</a><br /></td></tr>
<tr class="separator:a2fbbbab420ecee307d1283fcd7d2e1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe1685174cfbc3cab5ccb887451b6ab"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; <a class="el" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#abbf08aae5a3970d83bc10220bd141e71">MutationBranch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a2fe1685174cfbc3cab5ccb887451b6ab">CheckAndMutateRow</a> (std::string row_key, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Filter.html">Filter</a> filter, std::vector&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Mutation.html">Mutation</a> &gt; true_mutations, std::vector&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Mutation.html">Mutation</a> &gt; false_mutations)</td></tr>
<tr class="memdesc:a2fe1685174cfbc3cab5ccb887451b6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic test-and-set for a row using filter expressions.  <a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a2fe1685174cfbc3cab5ccb887451b6ab">More...</a><br /></td></tr>
<tr class="separator:a2fe1685174cfbc3cab5ccb887451b6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71a3d0a41ce3f93948fe324d741a09a"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; <a class="el" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#abbf08aae5a3970d83bc10220bd141e71">MutationBranch</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#aa71a3d0a41ce3f93948fe324d741a09a">AsyncCheckAndMutateRow</a> (std::string row_key, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Filter.html">Filter</a> filter, std::vector&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Mutation.html">Mutation</a> &gt; true_mutations, std::vector&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Mutation.html">Mutation</a> &gt; false_mutations, CompletionQueue &amp;cq)</td></tr>
<tr class="memdesc:aa71a3d0a41ce3f93948fe324d741a09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an asynchronous request to conditionally mutate a row.  <a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#aa71a3d0a41ce3f93948fe324d741a09a">More...</a><br /></td></tr>
<tr class="separator:aa71a3d0a41ce3f93948fe324d741a09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d89ad8f5b46838e38e620f1912b43c3"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; std::vector&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v1_1_1RowKeySample.html">bigtable::RowKeySample</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a7d89ad8f5b46838e38e620f1912b43c3">SampleRows</a> ()</td></tr>
<tr class="memdesc:a7d89ad8f5b46838e38e620f1912b43c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample of the row keys in the table, including approximate data sizes.  <a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a7d89ad8f5b46838e38e620f1912b43c3">More...</a><br /></td></tr>
<tr class="separator:a7d89ad8f5b46838e38e620f1912b43c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76145b69620f01fced8949911d8403a8"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a76145b69620f01fced8949911d8403a8"><td class="memTemplItemLeft" align="right" valign="top">StatusOr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Row.html">Row</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a76145b69620f01fced8949911d8403a8">ReadModifyWriteRow</a> (std::string row_key, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ReadModifyWriteRule.html">bigtable::ReadModifyWriteRule</a> rule, Args &amp;&amp;... rules)</td></tr>
<tr class="memdesc:a76145b69620f01fced8949911d8403a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read and modify the row in the server, returning the resulting row.  <a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a76145b69620f01fced8949911d8403a8">More...</a><br /></td></tr>
<tr class="separator:a76145b69620f01fced8949911d8403a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbbae9a9344ec38cf0987e6433b8191"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:adcbbae9a9344ec38cf0987e6433b8191"><td class="memTemplItemLeft" align="right" valign="top">future&lt; StatusOr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Row.html">Row</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#adcbbae9a9344ec38cf0987e6433b8191">AsyncReadModifyWriteRow</a> (std::string row_key, CompletionQueue &amp;cq, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ReadModifyWriteRule.html">bigtable::ReadModifyWriteRule</a> rule, Args &amp;&amp;... rules)</td></tr>
<tr class="memdesc:adcbbae9a9344ec38cf0987e6433b8191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an asynchronous request to atomically read and modify a row.  <a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#adcbbae9a9344ec38cf0987e6433b8191">More...</a><br /></td></tr>
<tr class="separator:adcbbae9a9344ec38cf0987e6433b8191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954721b66f9ff3cd3ec4d17973707854"><td class="memTemplParams" colspan="2">template&lt;typename RowFunctor , typename FinishFunctor &gt; </td></tr>
<tr class="memitem:a954721b66f9ff3cd3ec4d17973707854"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a954721b66f9ff3cd3ec4d17973707854">AsyncReadRows</a> (CompletionQueue &amp;cq, RowFunctor on_row, FinishFunctor on_finish, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1RowSet.html">RowSet</a> row_set, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Filter.html">Filter</a> filter)</td></tr>
<tr class="memdesc:a954721b66f9ff3cd3ec4d17973707854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously reads a set of rows from the table.  <a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a954721b66f9ff3cd3ec4d17973707854">More...</a><br /></td></tr>
<tr class="separator:a954721b66f9ff3cd3ec4d17973707854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e42e2ed643556538c806a329be5b9fc"><td class="memTemplParams" colspan="2">template&lt;typename RowFunctor , typename FinishFunctor &gt; </td></tr>
<tr class="memitem:a8e42e2ed643556538c806a329be5b9fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a8e42e2ed643556538c806a329be5b9fc">AsyncReadRows</a> (CompletionQueue &amp;cq, RowFunctor on_row, FinishFunctor on_finish, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1RowSet.html">RowSet</a> row_set, std::int64_t rows_limit, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Filter.html">Filter</a> filter)</td></tr>
<tr class="memdesc:a8e42e2ed643556538c806a329be5b9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously reads a set of rows from the table.  <a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a8e42e2ed643556538c806a329be5b9fc">More...</a><br /></td></tr>
<tr class="separator:a8e42e2ed643556538c806a329be5b9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a554020b661f68d4bb1929a2a0b9a2"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; std::pair&lt; bool, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Row.html">Row</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a73a554020b661f68d4bb1929a2a0b9a2">AsyncReadRow</a> (CompletionQueue &amp;cq, std::string row_key, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Filter.html">Filter</a> filter)</td></tr>
<tr class="memdesc:a73a554020b661f68d4bb1929a2a0b9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously read and return a single row from the table.  <a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a73a554020b661f68d4bb1929a2a0b9a2">More...</a><br /></td></tr>
<tr class="separator:a73a554020b661f68d4bb1929a2a0b9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Helper functions to implement constructors with changed policies.</h2></td></tr>
<tr class="memitem:a26c8f6be2070a3f5d8c01acabb3ad719"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a26c8f6be2070a3f5d8c01acabb3ad719">MutationBatcher</a></td></tr>
<tr class="separator:a26c8f6be2070a3f5d8c01acabb3ad719"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main interface to interact with data in a Cloud Bigtable table. </p>
<p>This class provides member functions to:</p><ul>
<li>read specific rows: <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a2fbbbab420ecee307d1283fcd7d2e1f5" title="Read and return a single row from the table.">Table::ReadRow()</a></code></li>
<li>scan a ranges of rows: <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#adc6306c3f4c31e27be8432b279c12c27" title="Reads a set of rows from the table.">Table::ReadRows()</a></code></li>
<li>update or create a single row: <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a6db958030bc117ab00971d196fbd1236" title="Attempts to apply the mutation to a row.">Table::Apply()</a></code></li>
<li>update or modify multiple rows: <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a244ced8a939369887e19ad934f0d7644" title="Attempts to apply mutations to multiple rows.">Table::BulkApply()</a></code></li>
<li>update a row based on previous values: <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a2fe1685174cfbc3cab5ccb887451b6ab" title="Atomic test-and-set for a row using filter expressions.">Table::CheckAndMutateRow()</a></code></li>
<li>to atomically append data and/or increment multiple values in a row: <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a76145b69620f01fced8949911d8403a8" title="Atomically read and modify the row in the server, returning the resulting row.">Table::ReadModifyWriteRow()</a></code></li>
<li>to sample the row keys: <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a7d89ad8f5b46838e38e620f1912b43c3" title="Sample of the row keys in the table, including approximate data sizes.">Table::SampleRows()</a></code>.</li>
</ul>
<p>The class deals with the most common transient failures, and retries the underlying RPC calls subject to the policies configured by the application. These policies are documented in <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a6f2ea4d0c1c5119ba42d0ba4164f74b3" title="Constructor with default policies.">Table::Table()</a></code>.</p>
<dl class="section user"><dt>Thread-safety</dt><dd>Instances of this class created via copy-construction or copy-assignment share the underlying pool of connections. Access to these copies via multiple threads is guaranteed to work. Two threads operating concurrently on the same instance of this class is not guaranteed to work.</dd></dl>
<dl class="section user"><dt>Cost</dt><dd>Creating a new object of type <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html" title="The main interface to interact with data in a Cloud Bigtable table.">Table</a></code> is comparable to creating a few objects of type <code>std::string</code> or a few objects of type <code>std::shared_ptr&lt;int&gt;</code>. The class represents a shallow handle to a remote object.</dd></dl>
<dl class="section user"><dt>Error Handling</dt><dd>This class uses <code>StatusOr&lt;T&gt;</code> to report errors. When an operation fails to perform its work the returned <code>StatusOr&lt;T&gt;</code> contains the error details. If the <code>ok()</code> member function in the <code>StatusOr&lt;T&gt;</code> returns <code>true</code> then it contains the expected result. Operations that do not return a value simply return a <code>google::cloud::Status</code> indicating success or the details of the error Please consult the <a href="#google::cloud::v1::StatusOr"><code>StatusOr&lt;T&gt;</code> documentation</a> for more details.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div>
<div class="line"><a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">cbt::Table</a> = ...;</div>
<div class="line">google::cloud::StatusOr&lt;std::pair&lt;bool, cbt::Row&gt;&gt; row = table.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a2fbbbab420ecee307d1283fcd7d2e1f5">ReadRow</a>(...);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (!row) {</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;Error reading row\n&quot;</span>;</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use &quot;row&quot; as a smart pointer here, e.g.:</span></div>
<div class="line"><span class="keywordflow">if</span> (!row-&gt;first) {</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Contacting the server was successful, but the row does not&quot;</span></div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; exist\n&quot;</span>;</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The row has &quot;</span> &lt;&lt; row-&gt;second.cells().size() &lt;&lt; <span class="stringliteral">&quot; cells\n&quot;</span>;</div>
</div><!-- fragment --><p>In addition, the <a class="el" href="index.html">main page</a> contains examples using <code>StatusOr&lt;T&gt;</code> to handle errors.</p>
<dl class="section user"><dt>Retry, Backoff, and Idempotency Policies</dt><dd>The library automatically retries requests that fail with transient errors, and uses <a href="https://cloud.google.com/storage/docs/exponential-backoff">truncated exponential backoff</a> to backoff between retries. The default policies are to continue retrying for up to 10 minutes. On each transient failure the backoff period is doubled, starting with an initial backoff of 100 milliseconds. The backoff period growth is truncated at 60 seconds. The default idempotency policy is to only retry idempotent operations. Note that most operations that change state are <b>not</b> idempotent.</dd></dl>
<p>The application can override these policies when constructing objects of this class. The documentation for the constructors show examples of this in action.</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://cloud.google.com/bigtable/">https://cloud.google.com/bigtable/</a> for an overview of Cloud Bigtable.</dd>
<dd>
<a href="https://cloud.google.com/bigtable/docs/overview">https://cloud.google.com/bigtable/docs/overview</a> for an overview of the Cloud Bigtable data model.</dd>
<dd>
<a href="https://cloud.google.com/bigtable/docs/instances-clusters-nodes">https://cloud.google.com/bigtable/docs/instances-clusters-nodes</a> for an introduction of the <a class="el" href="quickstart_8cc.html#a0ddf1224851353fc92bfbff6f499fa97">main</a> APIs into Cloud Bigtable.</dd>
<dd>
<a href="https://cloud.google.com/bigtable/docs/reference/service-apis-overview">https://cloud.google.com/bigtable/docs/reference/service-apis-overview</a> for an overview of the underlying Cloud Bigtable API.</dd>
<dd>
<a class="elRef" href="https://googleapis.dev/cpp/google-cloud-common/latest/classgoogle_1_1cloud_1_1v1_1_1StatusOr.html">google::cloud::v1::StatusOr</a> for a description of the error reporting class used by this library.</dd>
<dd>
<code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1LimitedTimeRetryPolicy.html" title="Implement a simple &quot;keep trying for this time&quot; retry policy.">LimitedTimeRetryPolicy</a></code> and <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1LimitedErrorCountRetryPolicy.html" title="Implement a simple &quot;count errors and then stop&quot; retry policy.">LimitedErrorCountRetryPolicy</a></code> for alternative retry policies.</dd>
<dd>
<code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ExponentialBackoffPolicy.html" title="Implement a simple exponential backoff policy.">ExponentialBackoffPolicy</a></code> to configure different parameters for the exponential backoff policy.</dd>
<dd>
<code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1SafeIdempotentMutationPolicy.html" title="Implements a policy that only accepts truly idempotent mutations.">SafeIdempotentMutationPolicy</a></code> and <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1AlwaysRetryMutationPolicy.html" title="Implements a policy that retries all mutations.">AlwaysRetryMutationPolicy</a></code> for alternative idempotency policies. </dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00165">165</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6f2ea4d0c1c5119ba42d0ba4164f74b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2ea4d0c1c5119ba42d0ba4164f74b3">&#9670;&nbsp;</a></span>Table() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::cloud::bigtable::v1::Table::Table </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1DataClient.html">DataClient</a> &gt;&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>table_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with default policies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>how to communicate with Cloud Bigtable, including credentials, the project id, and the instance id. </td></tr>
    <tr><td class="paramname">table_id</td><td>the table id within the instance defined by client. The full table name is &lsquo;client-&gt;instance_name() + &rsquo;/tables/' + table_id`. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00190">190</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a798688c85b85cfc68b1349d3da4e11db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798688c85b85cfc68b1349d3da4e11db">&#9670;&nbsp;</a></span>Table() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::cloud::bigtable::v1::Table::Table </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1DataClient.html">DataClient</a> &gt;&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>app_profile_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>table_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with default policies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>how to communicate with Cloud Bigtable, including credentials, the project id, and the instance id. </td></tr>
    <tr><td class="paramname">app_profile_id</td><td>the app_profile_id needed for using the replication API. </td></tr>
    <tr><td class="paramname">table_id</td><td>the table id within the instance defined by client. The full table name is &lsquo;client-&gt;instance_name() + &rsquo;/tables/' + table_id`.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Example Using AppProfile</dt><dd><div class="fragment"><div class="line">  <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">cbt::Table</a> read(data_client, profile_id, <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a83b9f3b405faa95ddb3c57e8e3820fc8">table_id</a>);</div>
<div class="line"> </div>
<div class="line">  google::cloud::StatusOr&lt;std::pair&lt;bool, cbt::Row&gt;&gt; result =</div>
<div class="line">      read.ReadRow(<span class="stringliteral">&quot;key-0&quot;</span>, cbt::Filter::ColumnRangeClosed(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;c0&quot;</span>, <span class="stringliteral">&quot;c0&quot;</span>));</div>
<div class="line">  <span class="keywordflow">if</span> (!result) <span class="keywordflow">throw</span> std::runtime_error(result.status().message());</div>
<div class="line">  <span class="keywordflow">if</span> (!result-&gt;first) <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;missing row with key = key-0&quot;</span>);</div>
<div class="line">  <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Cell.html">cbt::Cell</a> <span class="keyword">const</span>&amp; cell = result-&gt;second.cells().front();</div>
<div class="line">  std::cout &lt;&lt; cell.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Cell.html#a5d48f337d1c9d2234541beecbf11915c">family_name</a>() &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; cell.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Cell.html#a68f9e5cd687662c1a5ea8b3bbc8ef2b8">column_qualifier</a>() &lt;&lt; <span class="stringliteral">&quot;    @ &quot;</span></div>
<div class="line">            &lt;&lt; cell.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Cell.html#ad669a9bdafb01565e743cb646260792e">timestamp</a>().count() &lt;&lt; <span class="stringliteral">&quot;us\n&quot;</span></div>
<div class="line">            &lt;&lt; <span class="charliteral">&#39;&quot;&#39;</span> &lt;&lt; cell.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Cell.html#a6d01e22c1f3531142e18170d825bd8d0">value</a>() &lt;&lt; <span class="charliteral">&#39;&quot;&#39;</span> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00209">209</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="addfca93418b2ebc85fa417ee9a4dfb07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfca93418b2ebc85fa417ee9a4dfb07">&#9670;&nbsp;</a></span>Table() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Policies, typename std::enable_if&lt; ValidPolicies&lt; Policies... &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::cloud::bigtable::v1::Table::Table </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1DataClient.html">DataClient</a> &gt;&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>table_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Policies &amp;&amp;...&#160;</td>
          <td class="paramname"><em>policies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with explicit policies. </p>
<p>The policies are passed by value, because this makes it easy for applications to create them.</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">using namespace </span>std::chrono_literals; <span class="comment">// assuming C++14.</span></div>
<div class="line"><span class="keyword">auto</span> client = bigtable::CreateDefaultClient(...); <span class="comment">// details omitted</span></div>
<div class="line">bigtable::Table table(client, <span class="stringliteral">&quot;my-table&quot;</span>,</div>
<div class="line">                      <span class="comment">// Allow up to 20 minutes to retry operations</span></div>
<div class="line">                      bigtable::LimitedTimeRetryPolicy(20min),</div>
<div class="line">                      <span class="comment">// Start with 50 milliseconds backoff, grow</span></div>
<div class="line">                      <span class="comment">// exponentially to 5 minutes.</span></div>
<div class="line">                      bigtable::ExponentialBackoffPolicy(50ms, 5min),</div>
<div class="line">                      <span class="comment">// Only retry idempotent mutations.</span></div>
<div class="line">                      bigtable::SafeIdempotentMutationPolicy());</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>how to communicate with Cloud Bigtable, including credentials, the project id, and the instance id. </td></tr>
    <tr><td class="paramname">table_id</td><td>the table id within the instance defined by client. The full table name is <code>client-&gt;instance_name() + "/tables/" + table_id</code>. </td></tr>
    <tr><td class="paramname">policies</td><td>the set of policy overrides for this object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Policies</td><td>the types of the policies to override, the types must derive from one of the following types:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1IdempotentMutationPolicy.html" title="Defines the interface to control which mutations are idempotent and therefore can be re-tried.">IdempotentMutationPolicy</a></code> which mutations are retried. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1SafeIdempotentMutationPolicy.html" title="Implements a policy that only accepts truly idempotent mutations.">SafeIdempotentMutationPolicy</a></code> to only retry idempotent operations, use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1AlwaysRetryMutationPolicy.html" title="Implements a policy that retries all mutations.">AlwaysRetryMutationPolicy</a></code> to retry all operations. Read the caveats in the class definition to understand the downsides of the latter. You can also create your own policies that decide which mutations to retry.</li>
<li><code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1RPCBackoffPolicy.html" title="Define the interface for controlling how the Bigtable client backsoff from failed RPC operations.">RPCBackoffPolicy</a></code> how to backoff from a failed RPC. Currently only <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ExponentialBackoffPolicy.html" title="Implement a simple exponential backoff policy.">ExponentialBackoffPolicy</a></code> is implemented. You can also create your own policies that backoff using a different algorithm.</li>
<li><code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1RPCRetryPolicy.html" title="Define the interface for controlling how the Bigtable client retries RPC operations.">RPCRetryPolicy</a></code> for how long to retry failed RPCs. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1LimitedErrorCountRetryPolicy.html" title="Implement a simple &quot;count errors and then stop&quot; retry policy.">LimitedErrorCountRetryPolicy</a></code> to limit the number of failures allowed. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1LimitedTimeRetryPolicy.html" title="Implement a simple &quot;keep trying for this time&quot; retry policy.">LimitedTimeRetryPolicy</a></code> to bound the time for any request. You can also create your own policies that combine time and error counts.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1SafeIdempotentMutationPolicy.html" title="Implements a policy that only accepts truly idempotent mutations.">SafeIdempotentMutationPolicy</a>, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1AlwaysRetryMutationPolicy.html" title="Implements a policy that retries all mutations.">AlwaysRetryMutationPolicy</a>, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ExponentialBackoffPolicy.html" title="Implement a simple exponential backoff policy.">ExponentialBackoffPolicy</a>, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1LimitedErrorCountRetryPolicy.html" title="Implement a simple &quot;count errors and then stop&quot; retry policy.">LimitedErrorCountRetryPolicy</a>, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1LimitedTimeRetryPolicy.html" title="Implement a simple &quot;keep trying for this time&quot; retry policy.">LimitedTimeRetryPolicy</a>.</dd></dl>
<dl class="section user"><dt>Idempotency Policy Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div>
<div class="line">  [](std::string <span class="keyword">const</span>&amp; <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a430b10cee0704099c000f99418676916">project_id</a>, std::string <span class="keyword">const</span>&amp; <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a7a5c8c8c128e5533205d41829753d439">instance_id</a>,</div>
<div class="line">     std::string <span class="keyword">const</span>&amp; <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a83b9f3b405faa95ddb3c57e8e3820fc8">table_id</a>, std::string <span class="keyword">const</span>&amp; row_key) {</div>
<div class="line">    <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">cbt::Table</a> table(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#a0fa701b519d83686c5ffcdd4cbb24e3d">cbt::CreateDefaultDataClient</a>(<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a430b10cee0704099c000f99418676916">project_id</a>, <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a7a5c8c8c128e5533205d41829753d439">instance_id</a>,</div>
<div class="line">                                                  <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ClientOptions.html">cbt::ClientOptions</a>()),</div>
<div class="line">                     <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a83b9f3b405faa95ddb3c57e8e3820fc8">table_id</a>, <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1AlwaysRetryMutationPolicy.html">cbt::AlwaysRetryMutationPolicy</a>());</div>
<div class="line">    <span class="comment">// Normally this is not retried on transient failures, because the operation</span></div>
<div class="line">    <span class="comment">// is not idempotent (each retry would set a different timestamp), in this</span></div>
<div class="line">    <span class="comment">// case it would, because the table is setup to always retry.</span></div>
<div class="line">    <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1SingleRowMutation.html">cbt::SingleRowMutation</a> mutation(</div>
<div class="line">        row_key, <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;some-column&quot;</span>, <span class="stringliteral">&quot;some-value&quot;</span>));</div>
<div class="line">    google::cloud::Status status = table.Apply(std::move(mutation));</div>
<div class="line">    <span class="keywordflow">if</span> (!status.ok()) <span class="keywordflow">throw</span> std::runtime_error(status.message());</div>
<div class="line">  }</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Modified Retry Policy Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div>
<div class="line">  [](std::string <span class="keyword">const</span>&amp; <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a430b10cee0704099c000f99418676916">project_id</a>, std::string <span class="keyword">const</span>&amp; <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a7a5c8c8c128e5533205d41829753d439">instance_id</a>,</div>
<div class="line">     std::string <span class="keyword">const</span>&amp; <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a83b9f3b405faa95ddb3c57e8e3820fc8">table_id</a>, std::string <span class="keyword">const</span>&amp; row_key) {</div>
<div class="line">    <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">cbt::Table</a> table(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#a0fa701b519d83686c5ffcdd4cbb24e3d">cbt::CreateDefaultDataClient</a>(<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a430b10cee0704099c000f99418676916">project_id</a>, <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a7a5c8c8c128e5533205d41829753d439">instance_id</a>,</div>
<div class="line">                                                  <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ClientOptions.html">cbt::ClientOptions</a>()),</div>
<div class="line">                     <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a83b9f3b405faa95ddb3c57e8e3820fc8">table_id</a>, <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1LimitedErrorCountRetryPolicy.html">cbt::LimitedErrorCountRetryPolicy</a>(7));</div>
<div class="line">    <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1SingleRowMutation.html">cbt::SingleRowMutation</a> mutation(</div>
<div class="line">        row_key, <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;some-column&quot;</span>,</div>
<div class="line">                              std::chrono::milliseconds(0), <span class="stringliteral">&quot;some-value&quot;</span>));</div>
<div class="line">    google::cloud::Status status = table.Apply(std::move(mutation));</div>
<div class="line">    <span class="keywordflow">if</span> (!status.ok()) <span class="keywordflow">throw</span> std::runtime_error(status.message());</div>
<div class="line">  }</div>
</div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00281">281</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a1f8fe1f18600a4bb24d11857eadb5cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8fe1f18600a4bb24d11857eadb5cb4">&#9670;&nbsp;</a></span>Table() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Policies, typename std::enable_if&lt; ValidPolicies&lt; Policies... &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::cloud::bigtable::v1::Table::Table </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1DataClient.html">DataClient</a> &gt;&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>app_profile_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>table_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Policies &amp;&amp;...&#160;</td>
          <td class="paramname"><em>policies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with explicit policies. </p>
<p>The policies are passed by value, because this makes it easy for applications to create them.</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">using namespace </span>std::chrono_literals; <span class="comment">// assuming C++14.</span></div>
<div class="line"><span class="keyword">auto</span> client = bigtable::CreateDefaultClient(...); <span class="comment">// details omitted</span></div>
<div class="line">bigtable::Table table(client, <span class="stringliteral">&quot;app_id&quot;</span>, <span class="stringliteral">&quot;my-table&quot;</span>,</div>
<div class="line">                      <span class="comment">// Allow up to 20 minutes to retry operations</span></div>
<div class="line">                      bigtable::LimitedTimeRetryPolicy(20min),</div>
<div class="line">                      <span class="comment">// Start with 50 milliseconds backoff, grow</span></div>
<div class="line">                      <span class="comment">// exponentially to 5 minutes.</span></div>
<div class="line">                      bigtable::ExponentialBackoffPolicy(50ms, 5min),</div>
<div class="line">                      <span class="comment">// Only retry idempotent mutations.</span></div>
<div class="line">                      bigtable::SafeIdempotentMutationPolicy());</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>how to communicate with Cloud Bigtable, including credentials, the project id, and the instance id. </td></tr>
    <tr><td class="paramname">app_profile_id</td><td>the app_profile_id needed for using the replication API. </td></tr>
    <tr><td class="paramname">table_id</td><td>the table id within the instance defined by client. The full table name is <code>client-&gt;instance_name() + "/tables/" + table_id</code>. </td></tr>
    <tr><td class="paramname">policies</td><td>the set of policy overrides for this object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Policies</td><td>the types of the policies to override, the types must derive from one of the following types:<ul>
<li><code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1IdempotentMutationPolicy.html" title="Defines the interface to control which mutations are idempotent and therefore can be re-tried.">IdempotentMutationPolicy</a></code> which mutations are retried. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1SafeIdempotentMutationPolicy.html" title="Implements a policy that only accepts truly idempotent mutations.">SafeIdempotentMutationPolicy</a></code> to only retry idempotent operations, use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1AlwaysRetryMutationPolicy.html" title="Implements a policy that retries all mutations.">AlwaysRetryMutationPolicy</a></code> to retry all operations. Read the caveats in the class definition to understand the downsides of the latter. You can also create your own policies that decide which mutations to retry.</li>
<li><code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1RPCBackoffPolicy.html" title="Define the interface for controlling how the Bigtable client backsoff from failed RPC operations.">RPCBackoffPolicy</a></code> how to backoff from a failed RPC. Currently only <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ExponentialBackoffPolicy.html" title="Implement a simple exponential backoff policy.">ExponentialBackoffPolicy</a></code> is implemented. You can also create your own policies that backoff using a different algorithm.</li>
<li><code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1RPCRetryPolicy.html" title="Define the interface for controlling how the Bigtable client retries RPC operations.">RPCRetryPolicy</a></code> for how long to retry failed RPCs. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1LimitedErrorCountRetryPolicy.html" title="Implement a simple &quot;count errors and then stop&quot; retry policy.">LimitedErrorCountRetryPolicy</a></code> to limit the number of failures allowed. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1LimitedTimeRetryPolicy.html" title="Implement a simple &quot;keep trying for this time&quot; retry policy.">LimitedTimeRetryPolicy</a></code> to bound the time for any request. You can also create your own policies that combine time and error counts.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1SafeIdempotentMutationPolicy.html" title="Implements a policy that only accepts truly idempotent mutations.">SafeIdempotentMutationPolicy</a>, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1AlwaysRetryMutationPolicy.html" title="Implements a policy that retries all mutations.">AlwaysRetryMutationPolicy</a>, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ExponentialBackoffPolicy.html" title="Implement a simple exponential backoff policy.">ExponentialBackoffPolicy</a>, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1LimitedErrorCountRetryPolicy.html" title="Implement a simple &quot;count errors and then stop&quot; retry policy.">LimitedErrorCountRetryPolicy</a>, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1LimitedTimeRetryPolicy.html" title="Implement a simple &quot;keep trying for this time&quot; retry policy.">LimitedTimeRetryPolicy</a>.</dd></dl>
<dl class="section user"><dt>Idempotency Policy Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div>
<div class="line">  [](std::string <span class="keyword">const</span>&amp; <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a430b10cee0704099c000f99418676916">project_id</a>, std::string <span class="keyword">const</span>&amp; <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a7a5c8c8c128e5533205d41829753d439">instance_id</a>,</div>
<div class="line">     std::string <span class="keyword">const</span>&amp; <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a83b9f3b405faa95ddb3c57e8e3820fc8">table_id</a>, std::string <span class="keyword">const</span>&amp; row_key) {</div>
<div class="line">    <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">cbt::Table</a> table(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#a0fa701b519d83686c5ffcdd4cbb24e3d">cbt::CreateDefaultDataClient</a>(<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a430b10cee0704099c000f99418676916">project_id</a>, <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a7a5c8c8c128e5533205d41829753d439">instance_id</a>,</div>
<div class="line">                                                  <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ClientOptions.html">cbt::ClientOptions</a>()),</div>
<div class="line">                     <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a83b9f3b405faa95ddb3c57e8e3820fc8">table_id</a>, <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1AlwaysRetryMutationPolicy.html">cbt::AlwaysRetryMutationPolicy</a>());</div>
<div class="line">    <span class="comment">// Normally this is not retried on transient failures, because the operation</span></div>
<div class="line">    <span class="comment">// is not idempotent (each retry would set a different timestamp), in this</span></div>
<div class="line">    <span class="comment">// case it would, because the table is setup to always retry.</span></div>
<div class="line">    <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1SingleRowMutation.html">cbt::SingleRowMutation</a> mutation(</div>
<div class="line">        row_key, <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;some-column&quot;</span>, <span class="stringliteral">&quot;some-value&quot;</span>));</div>
<div class="line">    google::cloud::Status status = table.Apply(std::move(mutation));</div>
<div class="line">    <span class="keywordflow">if</span> (!status.ok()) <span class="keywordflow">throw</span> std::runtime_error(status.message());</div>
<div class="line">  }</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Modified Retry Policy Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div>
<div class="line">  [](std::string <span class="keyword">const</span>&amp; <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a430b10cee0704099c000f99418676916">project_id</a>, std::string <span class="keyword">const</span>&amp; <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a7a5c8c8c128e5533205d41829753d439">instance_id</a>,</div>
<div class="line">     std::string <span class="keyword">const</span>&amp; <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a83b9f3b405faa95ddb3c57e8e3820fc8">table_id</a>, std::string <span class="keyword">const</span>&amp; row_key) {</div>
<div class="line">    <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">cbt::Table</a> table(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#a0fa701b519d83686c5ffcdd4cbb24e3d">cbt::CreateDefaultDataClient</a>(<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a430b10cee0704099c000f99418676916">project_id</a>, <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a7a5c8c8c128e5533205d41829753d439">instance_id</a>,</div>
<div class="line">                                                  <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ClientOptions.html">cbt::ClientOptions</a>()),</div>
<div class="line">                     <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a83b9f3b405faa95ddb3c57e8e3820fc8">table_id</a>, <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1LimitedErrorCountRetryPolicy.html">cbt::LimitedErrorCountRetryPolicy</a>(7));</div>
<div class="line">    <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1SingleRowMutation.html">cbt::SingleRowMutation</a> mutation(</div>
<div class="line">        row_key, <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;some-column&quot;</span>,</div>
<div class="line">                              std::chrono::milliseconds(0), <span class="stringliteral">&quot;some-value&quot;</span>));</div>
<div class="line">    google::cloud::Status status = table.Apply(std::move(mutation));</div>
<div class="line">    <span class="keywordflow">if</span> (!status.ok()) <span class="keywordflow">throw</span> std::runtime_error(status.message());</div>
<div class="line">  }</div>
</div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00345">345</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a02302c69a492b552513bf5e4cf6f1b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02302c69a492b552513bf5e4cf6f1b64">&#9670;&nbsp;</a></span>app_profile_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string const&amp; google::cloud::bigtable::v1::Table::app_profile_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00352">352</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a6db958030bc117ab00971d196fbd1236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db958030bc117ab00971d196fbd1236">&#9670;&nbsp;</a></span>Apply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Status google::cloud::bigtable::v1::Table::Apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1SingleRowMutation.html">SingleRowMutation</a>&#160;</td>
          <td class="paramname"><em>mut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to apply the mutation to a row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut</td><td>the mutation. Note that this function takes ownership (and then discards) the data in the mutation. In general, a <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1SingleRowMutation.html" title="Represent a single row mutation.">SingleRowMutation</a></code> can be used to modify and/or delete multiple cells, across different columns and column families.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the operation.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is idempotent if the provided mutations are idempotent. Note that <code><a class="el" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394" title="Create a mutation to set a cell value based on a bigtable::Cell.">google::cloud::bigtable::SetCell()</a></code> without an explicit timestamp is <b>not</b> an idempotent operation.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Two threads concurrently calling this member function on the same instance of this class are <b>not</b> guaranteed to work.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div>
<div class="line">  [](<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">cbt::Table</a> table) {</div>
<div class="line">    <span class="keyword">auto</span> timestamp = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">        std::chrono::system_clock::now().time_since_epoch());</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1SingleRowMutation.html">cbt::SingleRowMutation</a> mutation(<span class="stringliteral">&quot;test-key-for-apply&quot;</span>);</div>
<div class="line">    mutation.emplace_back(</div>
<div class="line">        <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;column0&quot;</span>, timestamp, <span class="stringliteral">&quot;value for column0&quot;</span>));</div>
<div class="line">    mutation.emplace_back(</div>
<div class="line">        <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;column1&quot;</span>, timestamp, <span class="stringliteral">&quot;value for column1&quot;</span>));</div>
<div class="line">    <span class="keyword">auto</span> status = table.Apply(std::move(mutation));</div>
<div class="line">    <span class="keywordflow">if</span> (!status.ok()) <span class="keywordflow">throw</span> std::runtime_error(status.message());</div>
<div class="line">  }</div>
</div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8cc_source.html#l00071">71</a> of file <a class="el" href="table_8cc_source.html">table.cc</a>.</p>

</div>
</div>
<a id="a2241952cb3348bbc524bc6591c593cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2241952cb3348bbc524bc6591c593cae">&#9670;&nbsp;</a></span>AsyncApply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; Status &gt; google::cloud::bigtable::v1::Table::AsyncApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1SingleRowMutation.html">SingleRowMutation</a>&#160;</td>
          <td class="paramname"><em>mut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes asynchronous attempts to apply the mutation to a row. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut</td><td>the mutation. Note that this function takes ownership (and then discards) the data in the mutation. In general, a <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1SingleRowMutation.html" title="Represent a single row mutation.">SingleRowMutation</a></code> can be used to modify and/or delete multiple cells, across different columns and column families. </td></tr>
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is idempotent if the provided mutations are idempotent. Note that <code><a class="el" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394" title="Create a mutation to set a cell value based on a bigtable::Cell.">google::cloud::bigtable::SetCell()</a></code> without an explicit timestamp is <b>not</b> an idempotent operation.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div>
<div class="line">  <span class="keyword">using</span> google::cloud::future;</div>
<div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div>
<div class="line">  [](<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">cbt::Table</a> table, cbt::CompletionQueue cq, std::string <span class="keyword">const</span>&amp; row_key) {</div>
<div class="line">    <span class="keyword">auto</span> timestamp = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">        std::chrono::system_clock::now().time_since_epoch());</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1SingleRowMutation.html">cbt::SingleRowMutation</a> mutation(row_key);</div>
<div class="line">    mutation.emplace_back(</div>
<div class="line">        <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;column0&quot;</span>, timestamp, <span class="stringliteral">&quot;value for column0&quot;</span>));</div>
<div class="line">    mutation.emplace_back(</div>
<div class="line">        <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;column1&quot;</span>, timestamp, <span class="stringliteral">&quot;value for column1&quot;</span>));</div>
<div class="line"> </div>
<div class="line">    future&lt;google::cloud::Status&gt; status_future =</div>
<div class="line">        table.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a2241952cb3348bbc524bc6591c593cae">AsyncApply</a>(std::move(mutation), cq);</div>
<div class="line">    <span class="keyword">auto</span> status = status_future.get();</div>
<div class="line">    <span class="keywordflow">if</span> (!status.ok()) <span class="keywordflow">throw</span> std::runtime_error(status.message());</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Successfully applied mutation\n&quot;</span>;</div>
<div class="line">  }</div>
</div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8cc_source.html#l00113">113</a> of file <a class="el" href="table_8cc_source.html">table.cc</a>.</p>

</div>
</div>
<a id="a16b2a091eccd88d9762d93f874c98fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b2a091eccd88d9762d93f874c98fef">&#9670;&nbsp;</a></span>AsyncBulkApply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; std::vector&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1FailedMutation.html">FailedMutation</a> &gt; &gt; google::cloud::bigtable::v1::Table::AsyncBulkApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1BulkMutation.html">BulkMutation</a>&#160;</td>
          <td class="paramname"><em>mut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes asynchronous attempts to apply mutations to multiple rows. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut</td><td>the mutations, note that this function takes ownership (and then discards) the data in the mutation. In general, a <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1BulkMutation.html" title="Represent a set of mutations across multiple rows.">BulkMutation</a></code> can modify multiple rows, and the modifications for each row can change (or create) multiple cells, across different columns and column families. </td></tr>
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is idempotent if the provided mutations are idempotent. Note that <code><a class="el" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394" title="Create a mutation to set a cell value based on a bigtable::Cell.">google::cloud::bigtable::SetCell()</a></code> without an explicit timestamp is <b>not</b> an idempotent operation.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Two threads concurrently calling this member function on the same instance of this class are <b>not</b> guaranteed to work. Consider copying the object and using different copies in each thread.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div>
<div class="line">  <span class="keyword">using</span> google::cloud::future;</div>
<div class="line">  [](<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">cbt::Table</a> table, cbt::CompletionQueue cq) {</div>
<div class="line">    <span class="comment">// Write several rows in a single operation, each row has some trivial data.</span></div>
<div class="line">    <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1BulkMutation.html">cbt::BulkMutation</a> bulk;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != 5000; ++i) {</div>
<div class="line">      <span class="comment">// Note: This example uses sequential numeric IDs for simplicity, but</span></div>
<div class="line">      <span class="comment">// this can result in poor performance in a production application.</span></div>
<div class="line">      <span class="comment">// Since rows are stored in sorted order by key, sequential keys can</span></div>
<div class="line">      <span class="comment">// result in poor distribution of operations across nodes.</span></div>
<div class="line">      <span class="comment">//</span></div>
<div class="line">      <span class="comment">// For more information about how to design a Bigtable schema for the</span></div>
<div class="line">      <span class="comment">// best performance, see the documentation:</span></div>
<div class="line">      <span class="comment">//</span></div>
<div class="line">      <span class="comment">//     https://cloud.google.com/bigtable/docs/schema-design</span></div>
<div class="line">      <span class="keywordtype">char</span> buf[32];</div>
<div class="line">      snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class="stringliteral">&quot;key-%06d&quot;</span>, i);</div>
<div class="line">      <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1SingleRowMutation.html">cbt::SingleRowMutation</a> mutation(buf);</div>
<div class="line">      mutation.emplace_back(</div>
<div class="line">          <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col0&quot;</span>, <span class="stringliteral">&quot;value0-&quot;</span> + std::to_string(i)));</div>
<div class="line">      mutation.emplace_back(</div>
<div class="line">          <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col1&quot;</span>, <span class="stringliteral">&quot;value2-&quot;</span> + std::to_string(i)));</div>
<div class="line">      mutation.emplace_back(</div>
<div class="line">          <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col2&quot;</span>, <span class="stringliteral">&quot;value3-&quot;</span> + std::to_string(i)));</div>
<div class="line">      mutation.emplace_back(</div>
<div class="line">          <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col3&quot;</span>, <span class="stringliteral">&quot;value4-&quot;</span> + std::to_string(i)));</div>
<div class="line">      bulk.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1BulkMutation.html#a6c59856e590279a86154741ab95c218b">emplace_back</a>(std::move(mutation));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    table.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a16b2a091eccd88d9762d93f874c98fef">AsyncBulkApply</a>(std::move(bulk), cq)</div>
<div class="line">        .then([](future&lt;std::vector&lt;cbt::FailedMutation&gt;&gt; ft) {</div>
<div class="line">          <span class="keyword">auto</span> failures = ft.get();</div>
<div class="line">          <span class="keywordflow">if</span> (failures.empty()) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;All the mutations were successful\n&quot;</span>;</div>
<div class="line">            return;</div>
<div class="line">          }</div>
<div class="line">          <span class="comment">// By default, the `table` object uses the</span></div>
<div class="line">          <span class="comment">// `SafeIdempotentMutationPolicy` which does not retry if any of the</span></div>
<div class="line">          <span class="comment">// mutations fails and are not idempotent. In this example we simply</span></div>
<div class="line">          <span class="comment">// print such failures, if any, and ignore them otherwise.</span></div>
<div class="line">          std::cerr &lt;&lt; <span class="stringliteral">&quot;The following mutations failed and were not retried:\n&quot;</span>;</div>
<div class="line">          for (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; f : failures) {</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;index[&quot;</span> &lt;&lt; f.original_index() &lt;&lt; <span class="stringliteral">&quot;]=&quot;</span> &lt;&lt; f.status()</div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">          }</div>
<div class="line">        })</div>
<div class="line">        .get();  <span class="comment">// block to simplify the example</span></div>
<div class="line">  }</div>
</div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8cc_source.html#l00178">178</a> of file <a class="el" href="table_8cc_source.html">table.cc</a>.</p>

</div>
</div>
<a id="aa71a3d0a41ce3f93948fe324d741a09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71a3d0a41ce3f93948fe324d741a09a">&#9670;&nbsp;</a></span>AsyncCheckAndMutateRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; <a class="el" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#abbf08aae5a3970d83bc10220bd141e71">MutationBranch</a> &gt; &gt; google::cloud::bigtable::v1::Table::AsyncCheckAndMutateRow </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>row_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Filter.html">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Mutation.html">Mutation</a> &gt;&#160;</td>
          <td class="paramname"><em>true_mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Mutation.html">Mutation</a> &gt;&#160;</td>
          <td class="paramname"><em>false_mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make an asynchronous request to conditionally mutate a row. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_key</td><td>the row key on which the conditional mutation will be performed </td></tr>
    <tr><td class="paramname">filter</td><td>the condition, depending on which the mutation will be performed </td></tr>
    <tr><td class="paramname">true_mutations</td><td>the mutations which will be performed if <code>filter</code> is true </td></tr>
    <tr><td class="paramname">false_mutations</td><td>the mutations which will be performed if <code>filter</code> is false </td></tr>
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Two threads concurrently calling this member function on the same instance of this class are <b>not</b> guaranteed to work. Consider copying the object and using different copies in each thread.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div>
<div class="line">  <span class="keyword">using</span> google::cloud::future;</div>
<div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div>
<div class="line">  [](<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">cbt::Table</a> table, cbt::CompletionQueue cq, std::string <span class="keyword">const</span>&amp; row_key) {</div>
<div class="line">    <span class="comment">// Check if the latest value of the flip-flop column is &quot;on&quot;.</span></div>
<div class="line">    <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Filter.html">cbt::Filter</a> predicate = cbt::Filter::Chain(</div>
<div class="line">        cbt::Filter::ColumnRangeClosed(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flip-flop&quot;</span>, <span class="stringliteral">&quot;flip-flop&quot;</span>),</div>
<div class="line">        cbt::Filter::Latest(1), cbt::Filter::ValueRegex(<span class="stringliteral">&quot;on&quot;</span>));</div>
<div class="line">    future&lt;StatusOr&lt;cbt::MutationBranch&gt;&gt; branch_future =</div>
<div class="line">        table.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#aa71a3d0a41ce3f93948fe324d741a09a">AsyncCheckAndMutateRow</a>(row_key, std::move(predicate),</div>
<div class="line">                                     {<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flip-flop&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>),</div>
<div class="line">                                      <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flop-flip&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>)},</div>
<div class="line">                                     {<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flip-flop&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>),</div>
<div class="line">                                      <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flop-flip&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>)},</div>
<div class="line">                                     cq);</div>
<div class="line"> </div>
<div class="line">    branch_future</div>
<div class="line">        .then([](future&lt;StatusOr&lt;cbt::MutationBranch&gt;&gt; f) {</div>
<div class="line">          <span class="keyword">auto</span> response = f.get();</div>
<div class="line">          <span class="keywordflow">if</span> (!response) <span class="keywordflow">throw</span> std::runtime_error(response.status().message());</div>
<div class="line">          <span class="keywordflow">if</span> (*response == cbt::MutationBranch::kPredicateMatched) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;The predicate was matched\n&quot;</span>;</div>
<div class="line">          } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;The predicate was not matched\n&quot;</span>;</div>
<div class="line">          }</div>
<div class="line">        })</div>
<div class="line">        .get();  <span class="comment">// block to simplify the example.</span></div>
<div class="line">  }</div>
</div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8cc_source.html#l00256">256</a> of file <a class="el" href="table_8cc_source.html">table.cc</a>.</p>

</div>
</div>
<a id="adcbbae9a9344ec38cf0987e6433b8191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbbae9a9344ec38cf0987e6433b8191">&#9670;&nbsp;</a></span>AsyncReadModifyWriteRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">future&lt;StatusOr&lt;<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Row.html">Row</a>&gt; &gt; google::cloud::bigtable::v1::Table::AsyncReadModifyWriteRow </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>row_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ReadModifyWriteRule.html">bigtable::ReadModifyWriteRule</a>&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rules</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an asynchronous request to atomically read and modify a row. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_key</td><td>the row key on which modification will be performed </td></tr>
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>.</td></tr>
    <tr><td class="paramname">rule</td><td>to modify the row. Two types of rules are applied here AppendValue which will read the existing value and append the text provided to the value. IncrementAmount which will read the existing uint64 big-endian-int and add the value provided. Both rules accept the family and column identifier to modify. </td></tr>
    <tr><td class="paramname">rules</td><td>is the zero or more ReadModifyWriteRules to apply on a row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A future, that becomes satisfied when the operation completes, at that point the future has the contents of all modified cells.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Two threads concurrently calling this member function on the same instance of this class are <b>not</b> guaranteed to work.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div>
<div class="line">  <span class="keyword">using</span> google::cloud::future;</div>
<div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div>
<div class="line">  [](<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">cbt::Table</a> table, cbt::CompletionQueue cq, std::string <span class="keyword">const</span>&amp; row_key) {</div>
<div class="line">    future&lt;StatusOr&lt;cbt::Row&gt;&gt; row_future = table.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#adcbbae9a9344ec38cf0987e6433b8191">AsyncReadModifyWriteRow</a>(</div>
<div class="line">        std::move(row_key), cq,</div>
<div class="line">        cbt::ReadModifyWriteRule::AppendValue(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;list&quot;</span>, <span class="stringliteral">&quot;;element&quot;</span>));</div>
<div class="line"> </div>
<div class="line">    row_future</div>
<div class="line">        .then([](future&lt;StatusOr&lt;cbt::Row&gt;&gt; f) {</div>
<div class="line">          <span class="keyword">auto</span> row = f.get();</div>
<div class="line">          <span class="comment">// As the modify in this example is not idempotent, and this example</span></div>
<div class="line">          <span class="comment">// does not attempt to retry if there is a failure, we simply print</span></div>
<div class="line">          <span class="comment">// such failures, if any, and otherwise ignore them.</span></div>
<div class="line">          <span class="keywordflow">if</span> (!row) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to append row: &quot;</span> &lt;&lt; row.status().message()</div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">          }</div>
<div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot;Successfully appended to &quot;</span> &lt;&lt; row-&gt;row_key() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        })</div>
<div class="line">        .get();  <span class="comment">// block to simplify example.</span></div>
<div class="line">  }</div>
</div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00700">700</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a73a554020b661f68d4bb1929a2a0b9a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a554020b661f68d4bb1929a2a0b9a2">&#9670;&nbsp;</a></span>AsyncReadRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; std::pair&lt; bool, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Row.html">Row</a> &gt; &gt; &gt; google::cloud::bigtable::v1::Table::AsyncReadRow </td>
          <td>(</td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>row_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Filter.html">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously read and return a single row from the table. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">row_key</td><td>the row to read. </td></tr>
    <tr><td class="paramname">filter</td><td>a filter expression, can be used to select a subset of the column families and columns in the row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future satisfied when the operation completes, fails permanently or keeps failing transiently, but the retry policy has been exhausted. The future will return a tuple. The first element is a boolean, with value <code>false</code> if the row does not exist. If the first element is <code>true</code> the second element has the contents of the <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Row.html" title="The in-memory representation of a Bigtable row.">Row</a>. Note that the contents may be empty if the filter expression removes all column families and columns.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This is a read-only operation and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Two threads concurrently calling this member function on the same instance of this class are <b>not</b> guaranteed to work. Consider copying the object and using different copies in each thread.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div>
<div class="line">  <span class="keyword">using</span> google::cloud::future;</div>
<div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div>
<div class="line">  [](cbt::CompletionQueue cq, <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">google::cloud::bigtable::Table</a> table,</div>
<div class="line">     std::string <span class="keyword">const</span>&amp; row_key) {</div>
<div class="line">    <span class="comment">// Filter the results, only include the latest value on each cell.</span></div>
<div class="line">    <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Filter.html">cbt::Filter</a> filter = cbt::Filter::Latest(1);</div>
<div class="line">    table.AsyncReadRow(cq, row_key, std::move(filter))</div>
<div class="line">        .then(</div>
<div class="line">            [row_key](future&lt;StatusOr&lt;std::pair&lt;bool, cbt::Row&gt;&gt;&gt; row_future) {</div>
<div class="line">              <span class="comment">// Read a row, this returns a tuple (bool, row)</span></div>
<div class="line">              <span class="keyword">auto</span> tuple = row_future.get();</div>
<div class="line">              <span class="keywordflow">if</span> (!tuple) <span class="keywordflow">throw</span> std::runtime_error(tuple.status().message());</div>
<div class="line">              if (!tuple-&gt;first) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Row &quot;</span> &lt;&lt; row_key &lt;&lt; <span class="stringliteral">&quot; not found\n&quot;</span>;</div>
<div class="line">                return;</div>
<div class="line">              }</div>
<div class="line">              std::cout &lt;&lt; <span class="stringliteral">&quot;key: &quot;</span> &lt;&lt; tuple-&gt;second.row_key() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">              for (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; cell : tuple-&gt;second.cells()) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; cell.family_name() &lt;&lt; <span class="stringliteral">&quot;:&quot;</span></div>
<div class="line">                          &lt;&lt; cell.column_qualifier() &lt;&lt; <span class="stringliteral">&quot; = &lt;&quot;</span>;</div>
<div class="line">                if (cell.column_qualifier() == <span class="stringliteral">&quot;counter&quot;</span>) {</div>
<div class="line">                  <span class="comment">// This example uses &quot;counter&quot; to store 64-bit numbers in</span></div>
<div class="line">                  <span class="comment">// big-endian format, extract them as follows:</span></div>
<div class="line">                  std::cout</div>
<div class="line">                      &lt;&lt; cell.decode_big_endian_integer&lt;std::int64_t&gt;().value();</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                  std::cout &lt;&lt; cell.value();</div>
<div class="line">                }</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;&gt;\n&quot;</span>;</div>
<div class="line">              }</div>
<div class="line">            })</div>
<div class="line">        .get();  <span class="comment">// block to simplify the example</span></div>
<div class="line">  }</div>
</div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8cc_source.html#l00394">394</a> of file <a class="el" href="table_8cc_source.html">table.cc</a>.</p>

</div>
</div>
<a id="a954721b66f9ff3cd3ec4d17973707854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a954721b66f9ff3cd3ec4d17973707854">&#9670;&nbsp;</a></span>AsyncReadRows() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RowFunctor , typename FinishFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void google::cloud::bigtable::v1::Table::AsyncReadRows </td>
          <td>(</td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RowFunctor&#160;</td>
          <td class="paramname"><em>on_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FinishFunctor&#160;</td>
          <td class="paramname"><em>on_finish</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1RowSet.html">RowSet</a>&#160;</td>
          <td class="paramname"><em>row_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Filter.html">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously reads a set of rows from the table. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">on_row</td><td>the callback to be invoked on each successfully read row; it should be invocable with <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Row.html" title="The in-memory representation of a Bigtable row.">Row</a></code> and return a future&lt;bool&gt;; the returned <code>future&lt;bool&gt;</code> should be satisfied with <code>true</code> when the user is ready to receive the next callback and with <code>false</code> when the user doesn't want any more rows; if <code>on_row</code> throws, the results are undefined </td></tr>
    <tr><td class="paramname">on_finish</td><td>the callback to be invoked when the stream is closed; it should be invocable with <code>Status</code> and not return anything; it will always be called as the last callback; if <code>on_finish</code> throws, the results are undefined </td></tr>
    <tr><td class="paramname">row_set</td><td>the rows to read from. </td></tr>
    <tr><td class="paramname">filter</td><td>is applied on the server-side to data in the rows.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RowFunctor</td><td>the type of the <code>on_row</code> callback. </td></tr>
    <tr><td class="paramname">FinishFunctor</td><td>the type of the <code>on_finish</code> callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Two threads concurrently calling this member function on the same instance of this class are <b>not</b> guaranteed to work. Consider copying the object and using different copies in each thread.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div>
<div class="line">  <span class="keyword">using</span> google::cloud::make_ready_future;</div>
<div class="line">  <span class="keyword">using</span> google::cloud::promise;</div>
<div class="line">  <span class="keyword">using</span> google::cloud::Status;</div>
<div class="line">  [](cbt::CompletionQueue cq, <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">cbt::Table</a> table) {</div>
<div class="line">    <span class="comment">// Create the range of rows to read.</span></div>
<div class="line">    <span class="keyword">auto</span> range = cbt::RowRange::Range(<span class="stringliteral">&quot;key-000010&quot;</span>, <span class="stringliteral">&quot;key-000020&quot;</span>);</div>
<div class="line">    <span class="comment">// Filter the results, only include values from the &quot;col0&quot; column in the</span></div>
<div class="line">    <span class="comment">// &quot;fam&quot; column family, and only get the latest value.</span></div>
<div class="line">    <span class="keyword">auto</span> filter = cbt::Filter::Chain(</div>
<div class="line">        cbt::Filter::ColumnRangeClosed(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col0&quot;</span>, <span class="stringliteral">&quot;col0&quot;</span>),</div>
<div class="line">        cbt::Filter::Latest(1));</div>
<div class="line">    promise&lt;Status&gt; stream_status_promise;</div>
<div class="line">    <span class="comment">// Read and print the rows.</span></div>
<div class="line">    table.AsyncReadRows(</div>
<div class="line">        cq,</div>
<div class="line">        [](<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Row.html">cbt::Row</a> <span class="keyword">const</span>&amp; row) {</div>
<div class="line">          <span class="keywordflow">if</span> (row.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Row.html#a9c86ed8607457b3f3162655c26c54c80">cells</a>().size() != 1) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Unexpected number of cells in &quot;</span> &lt;&lt; row.row_key()</div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">            return make_ready_future(false);</div>
<div class="line">          }</div>
<div class="line">          <span class="keyword">auto</span> <span class="keyword">const</span>&amp; cell = row.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Row.html#a9c86ed8607457b3f3162655c26c54c80">cells</a>().at(0);</div>
<div class="line">          std::cout &lt;&lt; cell.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Cell.html#af73803defe911671a7fe2e01afe446b2">row_key</a>() &lt;&lt; <span class="stringliteral">&quot; = [&quot;</span> &lt;&lt; cell.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Cell.html#a6d01e22c1f3531142e18170d825bd8d0">value</a>() &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line">          <span class="keywordflow">return</span> <a class="codeRef" href="https://googleapis.dev/cpp/google-cloud-common/latest/namespacegoogle_1_1cloud_1_1v1.html#a2421390acdf2c6b05f2f4bb0c3b9549e">make_ready_future</a>(<span class="keyword">true</span>);</div>
<div class="line">        },</div>
<div class="line">        [&amp;stream_status_promise](Status <span class="keyword">const</span>&amp; stream_status) {</div>
<div class="line">          stream_status_promise.set_value(stream_status);</div>
<div class="line">        },</div>
<div class="line">        range, filter);</div>
<div class="line">    Status stream_status = stream_status_promise.get_future().get();</div>
<div class="line">    <span class="keywordflow">if</span> (!stream_status.ok()) <span class="keywordflow">throw</span> std::runtime_error(stream_status.message());</div>
<div class="line">  }</div>
</div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00745">745</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a8e42e2ed643556538c806a329be5b9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e42e2ed643556538c806a329be5b9fc">&#9670;&nbsp;</a></span>AsyncReadRows() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RowFunctor , typename FinishFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void google::cloud::bigtable::v1::Table::AsyncReadRows </td>
          <td>(</td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RowFunctor&#160;</td>
          <td class="paramname"><em>on_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FinishFunctor&#160;</td>
          <td class="paramname"><em>on_finish</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1RowSet.html">RowSet</a>&#160;</td>
          <td class="paramname"><em>row_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>rows_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Filter.html">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously reads a set of rows from the table. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">on_row</td><td>the callback to be invoked on each successfully read row; it should be invocable with <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Row.html" title="The in-memory representation of a Bigtable row.">Row</a></code> and return a future&lt;bool&gt;; the returned <code>future&lt;bool&gt;</code> should be satisfied with <code>true</code> when the user is ready to receive the next callback and with <code>false</code> when the user doesn't want any more rows; if <code>on_row</code> throws, the results are undefined </td></tr>
    <tr><td class="paramname">on_finish</td><td>the callback to be invoked when the stream is closed; it should be invocable with <code>Status</code> and not return anything; it will always be called as the last callback; if <code>on_finish</code> throws, the results are undefined </td></tr>
    <tr><td class="paramname">row_set</td><td>the rows to read from. </td></tr>
    <tr><td class="paramname">rows_limit</td><td>the maximum number of rows to read. Cannot be a negative number or zero. Use <code>AsyncReadRows(CompletionQueue, RowSet, Filter)</code> to read all matching rows. </td></tr>
    <tr><td class="paramname">filter</td><td>is applied on the server-side to data in the rows.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RowFunctor</td><td>the type of the <code>on_row</code> callback. </td></tr>
    <tr><td class="paramname">FinishFunctor</td><td>the type of the <code>on_finish</code> callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Two threads concurrently calling this member function on the same instance of this class are <b>not</b> guaranteed to work. Consider copying the object and using different copies in each thread. The callbacks passed to this function may be executed on any thread running the provided completion queue.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div>
<div class="line">  <span class="keyword">using</span> google::cloud::make_ready_future;</div>
<div class="line">  <span class="keyword">using</span> google::cloud::promise;</div>
<div class="line">  <span class="keyword">using</span> google::cloud::Status;</div>
<div class="line">  [](cbt::CompletionQueue cq, <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">cbt::Table</a> table) {</div>
<div class="line">    <span class="comment">// Create the range of rows to read.</span></div>
<div class="line">    <span class="keyword">auto</span> range = cbt::RowRange::Range(<span class="stringliteral">&quot;key-000010&quot;</span>, <span class="stringliteral">&quot;key-000020&quot;</span>);</div>
<div class="line">    <span class="comment">// Filter the results, only include values from the &quot;col0&quot; column in the</span></div>
<div class="line">    <span class="comment">// &quot;fam&quot; column family, and only get the latest value.</span></div>
<div class="line">    <span class="keyword">auto</span> filter = cbt::Filter::Chain(</div>
<div class="line">        cbt::Filter::ColumnRangeClosed(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col0&quot;</span>, <span class="stringliteral">&quot;col0&quot;</span>),</div>
<div class="line">        cbt::Filter::Latest(1));</div>
<div class="line">    promise&lt;Status&gt; stream_status_promise;</div>
<div class="line">    <span class="comment">// Read and print the rows.</span></div>
<div class="line">    table.AsyncReadRows(</div>
<div class="line">        cq,</div>
<div class="line">        [](<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Row.html">cbt::Row</a> <span class="keyword">const</span>&amp; row) {</div>
<div class="line">          <span class="keywordflow">if</span> (row.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Row.html#a9c86ed8607457b3f3162655c26c54c80">cells</a>().size() != 1) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Unexpected number of cells in &quot;</span> &lt;&lt; row.row_key()</div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">            return make_ready_future(false);</div>
<div class="line">          }</div>
<div class="line">          <span class="keyword">auto</span> <span class="keyword">const</span>&amp; cell = row.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Row.html#a9c86ed8607457b3f3162655c26c54c80">cells</a>().at(0);</div>
<div class="line">          std::cout &lt;&lt; cell.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Cell.html#af73803defe911671a7fe2e01afe446b2">row_key</a>() &lt;&lt; <span class="stringliteral">&quot; = [&quot;</span> &lt;&lt; cell.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Cell.html#a6d01e22c1f3531142e18170d825bd8d0">value</a>() &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line">          <span class="keywordflow">return</span> <a class="codeRef" href="https://googleapis.dev/cpp/google-cloud-common/latest/namespacegoogle_1_1cloud_1_1v1.html#a2421390acdf2c6b05f2f4bb0c3b9549e">make_ready_future</a>(<span class="keyword">true</span>);</div>
<div class="line">        },</div>
<div class="line">        [&amp;stream_status_promise](Status <span class="keyword">const</span>&amp; stream_status) {</div>
<div class="line">          stream_status_promise.set_value(stream_status);</div>
<div class="line">        },</div>
<div class="line">        range, filter);</div>
<div class="line">    Status stream_status = stream_status_promise.get_future().get();</div>
<div class="line">    <span class="keywordflow">if</span> (!stream_status.ok()) <span class="keywordflow">throw</span> std::runtime_error(stream_status.message());</div>
<div class="line">  }</div>
</div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00795">795</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a244ced8a939369887e19ad934f0d7644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244ced8a939369887e19ad934f0d7644">&#9670;&nbsp;</a></span>BulkApply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1FailedMutation.html">FailedMutation</a> &gt; google::cloud::bigtable::v1::Table::BulkApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1BulkMutation.html">BulkMutation</a>&#160;</td>
          <td class="paramname"><em>mut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to apply mutations to multiple rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut</td><td>the mutations, note that this function takes ownership (and then discards) the data in the mutation. In general, a <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1BulkMutation.html" title="Represent a set of mutations across multiple rows.">BulkMutation</a></code> can modify multiple rows, and the modifications for each row can change (or create) multiple cells, across different columns and column families.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is idempotent if the provided mutations are idempotent. Note that <code><a class="el" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394" title="Create a mutation to set a cell value based on a bigtable::Cell.">google::cloud::bigtable::SetCell()</a></code> without an explicit timestamp is <b>not</b> an idempotent operation.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Two threads concurrently calling this member function on the same instance of this class are <b>not</b> guaranteed to work. Consider copying the object and using different copies in each thread.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div>
<div class="line">  [](<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">cbt::Table</a> table) {</div>
<div class="line">    <span class="comment">// Write several rows in a single operation, each row has some trivial data.</span></div>
<div class="line">    <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1BulkMutation.html">cbt::BulkMutation</a> bulk;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != 5000; ++i) {</div>
<div class="line">      <span class="comment">// Note: This example uses sequential numeric IDs for simplicity, but</span></div>
<div class="line">      <span class="comment">// this can result in poor performance in a production application.</span></div>
<div class="line">      <span class="comment">// Since rows are stored in sorted order by key, sequential keys can</span></div>
<div class="line">      <span class="comment">// result in poor distribution of operations across nodes.</span></div>
<div class="line">      <span class="comment">//</span></div>
<div class="line">      <span class="comment">// For more information about how to design a Bigtable schema for the</span></div>
<div class="line">      <span class="comment">// best performance, see the documentation:</span></div>
<div class="line">      <span class="comment">//</span></div>
<div class="line">      <span class="comment">//     https://cloud.google.com/bigtable/docs/schema-design</span></div>
<div class="line">      <span class="keywordtype">char</span> buf[32];</div>
<div class="line">      snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class="stringliteral">&quot;key-%06d&quot;</span>, i);</div>
<div class="line">      <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1SingleRowMutation.html">cbt::SingleRowMutation</a> mutation(buf);</div>
<div class="line">      mutation.emplace_back(</div>
<div class="line">          <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col0&quot;</span>, <span class="stringliteral">&quot;value0-&quot;</span> + std::to_string(i)));</div>
<div class="line">      mutation.emplace_back(</div>
<div class="line">          <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col1&quot;</span>, <span class="stringliteral">&quot;value1-&quot;</span> + std::to_string(i)));</div>
<div class="line">      bulk.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1BulkMutation.html#a6c59856e590279a86154741ab95c218b">emplace_back</a>(std::move(mutation));</div>
<div class="line">    }</div>
<div class="line">    std::vector&lt;cbt::FailedMutation&gt; failures =</div>
<div class="line">        table.BulkApply(std::move(bulk));</div>
<div class="line">    <span class="keywordflow">if</span> (failures.empty()) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;All mutations applied successfully\n&quot;</span>;</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// By default, the `table` object uses the `SafeIdempotentMutationPolicy`</span></div>
<div class="line">    <span class="comment">// which does not retry if any of the mutations fails and are</span></div>
<div class="line">    <span class="comment">// not-idempotent. In this example we simply print such failures, if any,</span></div>
<div class="line">    <span class="comment">// and ignore them otherwise.</span></div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;The following mutations failed and were not retried:\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; f : failures) {</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;index[&quot;</span> &lt;&lt; f.original_index() &lt;&lt; <span class="stringliteral">&quot;]=&quot;</span> &lt;&lt; f.status() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
</div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8cc_source.html#l00151">151</a> of file <a class="el" href="table_8cc_source.html">table.cc</a>.</p>

</div>
</div>
<a id="a2fe1685174cfbc3cab5ccb887451b6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe1685174cfbc3cab5ccb887451b6ab">&#9670;&nbsp;</a></span>CheckAndMutateRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; <a class="el" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#abbf08aae5a3970d83bc10220bd141e71">MutationBranch</a> &gt; google::cloud::bigtable::v1::Table::CheckAndMutateRow </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>row_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Filter.html">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Mutation.html">Mutation</a> &gt;&#160;</td>
          <td class="paramname"><em>true_mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Mutation.html">Mutation</a> &gt;&#160;</td>
          <td class="paramname"><em>false_mutations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic test-and-set for a row using filter expressions. </p>
<p>Atomically check the value of a row using a filter expression. If the expression passes (meaning at least one element is returned by it), one set of mutations is applied. If the filter does not pass, a different set of mutations is applied. The changes are atomically applied in the server.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_key</td><td>the row to modify. </td></tr>
    <tr><td class="paramname">filter</td><td>the filter expression. </td></tr>
    <tr><td class="paramname">true_mutations</td><td>the mutations for the "filter passed" case. </td></tr>
    <tr><td class="paramname">false_mutations</td><td>the mutations for the "filter did not pass" case. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the filter passed.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Two threads concurrently calling this member function on the same instance of this class are <b>not</b> guaranteed to work. Consider copying the object and using different copies in each thread.</dd></dl>
<dl class="section user"><dt>Check for Value Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div>
<div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div>
<div class="line">  [](<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">cbt::Table</a> table, std::string <span class="keyword">const</span>&amp; row_key) {</div>
<div class="line">    <span class="comment">// Check if the latest value of the flip-flop column is &quot;on&quot;.</span></div>
<div class="line">    <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Filter.html">cbt::Filter</a> predicate = cbt::Filter::Chain(</div>
<div class="line">        cbt::Filter::ColumnRangeClosed(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flip-flop&quot;</span>, <span class="stringliteral">&quot;flip-flop&quot;</span>),</div>
<div class="line">        cbt::Filter::Latest(1), cbt::Filter::ValueRegex(<span class="stringliteral">&quot;on&quot;</span>));</div>
<div class="line">    <span class="comment">// If the predicate matches, change the latest value to &quot;off&quot;, otherwise,</span></div>
<div class="line">    <span class="comment">// change the latest value to &quot;on&quot;.  Modify the &quot;flop-flip&quot; column at the</span></div>
<div class="line">    <span class="comment">// same time.</span></div>
<div class="line">    StatusOr&lt;cbt::MutationBranch&gt; branch =</div>
<div class="line">        table.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a2fe1685174cfbc3cab5ccb887451b6ab">CheckAndMutateRow</a>(row_key, std::move(predicate),</div>
<div class="line">                                {<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flip-flop&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>),</div>
<div class="line">                                 <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flop-flip&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>)},</div>
<div class="line">                                {<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flip-flop&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>),</div>
<div class="line">                                 <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flop-flip&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>)});</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!branch) <span class="keywordflow">throw</span> std::runtime_error(branch.status().message());</div>
<div class="line">    <span class="keywordflow">if</span> (*branch == cbt::MutationBranch::kPredicateMatched) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;The predicate was matched\n&quot;</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;The predicate was not matched\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Check for Cell Presence Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div>
<div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div>
<div class="line">  [](<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">cbt::Table</a> table, std::string <span class="keyword">const</span>&amp; row_key) {</div>
<div class="line">    <span class="comment">// Check if the latest value of the &quot;test-column&quot; column is present,</span></div>
<div class="line">    <span class="comment">// regardless of its value.</span></div>
<div class="line">    <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Filter.html">cbt::Filter</a> predicate = cbt::Filter::Chain(</div>
<div class="line">        cbt::Filter::ColumnRangeClosed(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;test-column&quot;</span>, <span class="stringliteral">&quot;test-column&quot;</span>),</div>
<div class="line">        cbt::Filter::Latest(1));</div>
<div class="line">    <span class="comment">// If the predicate matches, do nothing, otherwise set the</span></div>
<div class="line">    <span class="comment">// &quot;had-test-column&quot; to &quot;false&quot;:</span></div>
<div class="line">    StatusOr&lt;cbt::MutationBranch&gt; branch = table.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a2fe1685174cfbc3cab5ccb887451b6ab">CheckAndMutateRow</a>(</div>
<div class="line">        row_key, std::move(predicate), {},</div>
<div class="line">        {<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;had-test-column&quot;</span>, <span class="stringliteral">&quot;false&quot;</span>)});</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!branch) <span class="keywordflow">throw</span> std::runtime_error(branch.status().message());</div>
<div class="line">    <span class="keywordflow">if</span> (*branch == cbt::MutationBranch::kPredicateMatched) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;The predicate was matched\n&quot;</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;The predicate was not matched\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
</div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8cc_source.html#l00226">226</a> of file <a class="el" href="table_8cc_source.html">table.cc</a>.</p>

</div>
</div>
<a id="a7a5c8c8c128e5533205d41829753d439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5c8c8c128e5533205d41829753d439">&#9670;&nbsp;</a></span>instance_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string const&amp; google::cloud::bigtable::v1::Table::instance_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00354">354</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a430b10cee0704099c000f99418676916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430b10cee0704099c000f99418676916">&#9670;&nbsp;</a></span>project_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string const&amp; google::cloud::bigtable::v1::Table::project_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00353">353</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a76145b69620f01fced8949911d8403a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76145b69620f01fced8949911d8403a8">&#9670;&nbsp;</a></span>ReadModifyWriteRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt;<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Row.html">Row</a>&gt; google::cloud::bigtable::v1::Table::ReadModifyWriteRow </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>row_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ReadModifyWriteRule.html">bigtable::ReadModifyWriteRule</a>&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rules</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically read and modify the row in the server, returning the resulting row. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>this is zero or more ReadModifyWriteRules to apply on a row </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_key</td><td>the row to read </td></tr>
    <tr><td class="paramname">rule</td><td>to modify the row. Two types of rules are applied here AppendValue which will read the existing value and append the text provided to the value. IncrementAmount which will read the existing uint64 big-endian-int and add the value provided. Both rules accept the family and column identifier to modify. </td></tr>
    <tr><td class="paramname">rules</td><td>is the zero or more ReadModifyWriteRules to apply on a row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new contents of all modified cells.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Two threads concurrently calling this member function on the same instance of this class are <b>not</b> guaranteed to work. Consider copying the object and using different copies in each thread.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div>
<div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div>
<div class="line">  [](<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">cbt::Table</a> table, std::string <span class="keyword">const</span>&amp; row_key) {</div>
<div class="line">    StatusOr&lt;cbt::Row&gt; row = table.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a76145b69620f01fced8949911d8403a8">ReadModifyWriteRow</a>(</div>
<div class="line">        row_key, cbt::ReadModifyWriteRule::IncrementAmount(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;counter&quot;</span>, 1),</div>
<div class="line">        cbt::ReadModifyWriteRule::AppendValue(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;list&quot;</span>, <span class="stringliteral">&quot;;element&quot;</span>));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// As the modify in this example is not idempotent, and this example</span></div>
<div class="line">    <span class="comment">// does not attempt to retry if there is a failure, we simply print</span></div>
<div class="line">    <span class="comment">// such failures, if any, and otherwise ignore them.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!row) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to append row: &quot;</span> &lt;&lt; row.status().message() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; row-&gt;row_key() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">  }</div>
</div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00646">646</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a2fbbbab420ecee307d1283fcd7d2e1f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbbbab420ecee307d1283fcd7d2e1f5">&#9670;&nbsp;</a></span>ReadRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; std::pair&lt; bool, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Row.html">Row</a> &gt; &gt; google::cloud::bigtable::v1::Table::ReadRow </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>row_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Filter.html">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and return a single row from the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_key</td><td>the row to read. </td></tr>
    <tr><td class="paramname">filter</td><td>a filter expression, can be used to select a subset of the column families and columns in the row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple, the first element is a boolean, with value <code>false</code> if the row does not exist. If the first element is <code>true</code> the second element has the contents of the <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Row.html" title="The in-memory representation of a Bigtable row.">Row</a>. Note that the contents may be empty if the filter expression removes all column families and columns.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This is a read-only operation and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Two threads concurrently calling this member function on the same instance of this class are <b>not</b> guaranteed to work. Consider copying the object and using different copies in each thread.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div>
<div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div>
<div class="line">  [](<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">google::cloud::bigtable::Table</a> table, std::string <span class="keyword">const</span>&amp; row_key) {</div>
<div class="line">    StatusOr&lt;std::pair&lt;bool, cbt::Row&gt;&gt; tuple = table.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a2fbbbab420ecee307d1283fcd7d2e1f5">ReadRow</a>(</div>
<div class="line">        row_key, cbt::Filter::ColumnName(<span class="stringliteral">&quot;stats_summary&quot;</span>, <span class="stringliteral">&quot;os_build&quot;</span>));</div>
<div class="line">    <span class="keywordflow">if</span> (!tuple) <span class="keywordflow">throw</span> std::runtime_error(tuple.status().message());</div>
<div class="line">    <span class="keywordflow">if</span> (!tuple-&gt;first) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Row &quot;</span> &lt;&lt; row_key &lt;&lt; <span class="stringliteral">&quot; not found\n&quot;</span>;</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    PrintRow(tuple-&gt;second);</div>
<div class="line">  }</div>
</div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8cc_source.html#l00204">204</a> of file <a class="el" href="table_8cc_source.html">table.cc</a>.</p>

</div>
</div>
<a id="adc6306c3f4c31e27be8432b279c12c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6306c3f4c31e27be8432b279c12c27">&#9670;&nbsp;</a></span>ReadRows() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1RowReader.html">RowReader</a> google::cloud::bigtable::v1::Table::ReadRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1RowSet.html">RowSet</a>&#160;</td>
          <td class="paramname"><em>row_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Filter.html">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a set of rows from the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_set</td><td>the rows to read from. </td></tr>
    <tr><td class="paramname">filter</td><td>is applied on the server-side to data in the rows.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Idempotency</dt><dd>This is a read-only operation and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Two threads concurrently calling this member function on the same instance of this class are <b>not</b> guaranteed to work. Consider copying the object and using different copies in each thread. The values returned by different calls are independent with respect to thread-safety, please see the <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1RowReader.html" title="Object returned by Table::ReadRows(), enumerates rows in the response.">RowReader</a></code> documentation for more details.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div>
<div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div>
<div class="line">  [](<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">cbt::Table</a> table) {</div>
<div class="line">    <span class="comment">// Read and print the rows.</span></div>
<div class="line">    <span class="keywordflow">for</span> (StatusOr&lt;cbt::Row&gt; <span class="keyword">const</span>&amp; row :</div>
<div class="line">         table.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#adc6306c3f4c31e27be8432b279c12c27">ReadRows</a>(cbt::RowRange::Range(<span class="stringliteral">&quot;phone#4c410523#20190501&quot;</span>,</div>
<div class="line">                                             <span class="stringliteral">&quot;phone#4c410523#201906201&quot;</span>),</div>
<div class="line">                        cbt::Filter::PassAllFilter())) {</div>
<div class="line">      <span class="keywordflow">if</span> (!row) <span class="keywordflow">throw</span> std::runtime_error(row.status().message());</div>
<div class="line">      PrintRow(*row);</div>
<div class="line">    }</div>
<div class="line">  }</div>
</div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8cc_source.html#l00187">187</a> of file <a class="el" href="table_8cc_source.html">table.cc</a>.</p>

</div>
</div>
<a id="a07d62110bb365cf0db97a80560302ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d62110bb365cf0db97a80560302ef1">&#9670;&nbsp;</a></span>ReadRows() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1RowReader.html">RowReader</a> google::cloud::bigtable::v1::Table::ReadRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1RowSet.html">RowSet</a>&#160;</td>
          <td class="paramname"><em>row_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>rows_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Filter.html">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a limited set of rows from the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_set</td><td>the rows to read from. </td></tr>
    <tr><td class="paramname">rows_limit</td><td>the maximum number of rows to read. Cannot be a negative number or zero. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#adc6306c3f4c31e27be8432b279c12c27" title="Reads a set of rows from the table.">ReadRows(RowSet, Filter)</a></code> to read all matching rows. </td></tr>
    <tr><td class="paramname">filter</td><td>is applied on the server-side to data in the rows.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Idempotency</dt><dd>This is a read-only operation and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Two threads concurrently calling this member function on the same instance of this class are <b>not</b> guaranteed to work. Consider copying the object and using different copies in each thread. The values returned by different calls are independent with respect to thread-safety, please see the <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1RowReader.html" title="Object returned by Table::ReadRows(), enumerates rows in the response.">RowReader</a></code> documentation for more details.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div>
<div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div>
<div class="line">  [](<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">cbt::Table</a> table) {</div>
<div class="line">    <span class="comment">// Create the range of rows to read.</span></div>
<div class="line">    <span class="keyword">auto</span> range = cbt::RowRange::Range(<span class="stringliteral">&quot;phone#4c410523#20190501&quot;</span>,</div>
<div class="line">                                      <span class="stringliteral">&quot;phone#4c410523#20190502&quot;</span>);</div>
<div class="line">    <span class="comment">// Filter the results, only include values from the &quot;connected_wifi&quot; column</span></div>
<div class="line">    <span class="comment">// in the &quot;stats_summary&quot; column family, and only get the latest value.</span></div>
<div class="line">    <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Filter.html">cbt::Filter</a> filter = cbt::Filter::Chain(</div>
<div class="line">        cbt::Filter::ColumnRangeClosed(<span class="stringliteral">&quot;stats_summary&quot;</span>, <span class="stringliteral">&quot;connected_wifi&quot;</span>,</div>
<div class="line">                                       <span class="stringliteral">&quot;connected_wifi&quot;</span>),</div>
<div class="line">        cbt::Filter::Latest(1));</div>
<div class="line">    <span class="comment">// Read and print the first 5 rows in the range.</span></div>
<div class="line">    <span class="keywordflow">for</span> (StatusOr&lt;cbt::Row&gt; <span class="keyword">const</span>&amp; row : table.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#adc6306c3f4c31e27be8432b279c12c27">ReadRows</a>(range, 5, filter)) {</div>
<div class="line">      <span class="keywordflow">if</span> (!row) <span class="keywordflow">throw</span> std::runtime_error(row.status().message());</div>
<div class="line">      <span class="keywordflow">if</span> (row-&gt;cells().size() != 1) {</div>
<div class="line">        std::ostringstream os;</div>
<div class="line">        os &lt;&lt; <span class="stringliteral">&quot;Unexpected number of cells in &quot;</span> &lt;&lt; row-&gt;row_key();</div>
<div class="line">        <span class="keywordflow">throw</span> std::runtime_error(os.str());</div>
<div class="line">      }</div>
<div class="line">      <span class="keyword">auto</span> <span class="keyword">const</span>&amp; cell = row-&gt;cells().at(0);</div>
<div class="line">      std::cout &lt;&lt; cell.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Cell.html#af73803defe911671a7fe2e01afe446b2">row_key</a>() &lt;&lt; <span class="stringliteral">&quot; = [&quot;</span> &lt;&lt; cell.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Cell.html#a6d01e22c1f3531142e18170d825bd8d0">value</a>() &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
</div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8cc_source.html#l00195">195</a> of file <a class="el" href="table_8cc_source.html">table.cc</a>.</p>

</div>
</div>
<a id="a7d89ad8f5b46838e38e620f1912b43c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d89ad8f5b46838e38e620f1912b43c3">&#9670;&nbsp;</a></span>SampleRows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; std::vector&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v1_1_1RowKeySample.html">bigtable::RowKeySample</a> &gt; &gt; google::cloud::bigtable::v1::Table::SampleRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample of the row keys in the table, including approximate data sizes. </p>
<dl class="section return"><dt>Returns</dt><dd>Note that the sample may only include one element for small tables. In addition, the sample may include row keys that do not exist on the table, and may include the empty row key to indicate "end of table".</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Thread-safety</dt><dd>Two threads concurrently calling this member function on the same instance of this class are <b>not</b> guaranteed to work. Consider copying the object and using different copies in each thread.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div>
<div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div>
<div class="line">  [](<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">cbt::Table</a> table) {</div>
<div class="line">    StatusOr&lt;std::vector&lt;cbt::RowKeySample&gt;&gt; samples = table.<a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a7d89ad8f5b46838e38e620f1912b43c3">SampleRows</a>();</div>
<div class="line">    <span class="keywordflow">if</span> (!samples) <span class="keywordflow">throw</span> std::runtime_error(samples.status().message());</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; sample : *samples) {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;key=&quot;</span> &lt;&lt; sample.row_key &lt;&lt; <span class="stringliteral">&quot; - &quot;</span> &lt;&lt; sample.offset_bytes</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
</div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8cc_source.html#l00304">304</a> of file <a class="el" href="table_8cc_source.html">table.cc</a>.</p>

</div>
</div>
<a id="a83b9f3b405faa95ddb3c57e8e3820fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b9f3b405faa95ddb3c57e8e3820fc8">&#9670;&nbsp;</a></span>table_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string const&amp; google::cloud::bigtable::v1::Table::table_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00355">355</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="aa8df03de4aae0d013aa2a133631c33b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8df03de4aae0d013aa2a133631c33b9">&#9670;&nbsp;</a></span>table_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string const&amp; google::cloud::bigtable::v1::Table::table_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00351">351</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a26c8f6be2070a3f5d8c01acabb3ad719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c8f6be2070a3f5d8c01acabb3ad719">&#9670;&nbsp;</a></span>MutationBatcher</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1MutationBatcher.html">MutationBatcher</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00902">902</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table_html_a2241952cb3348bbc524bc6591c593cae"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a2241952cb3348bbc524bc6591c593cae">google::cloud::bigtable::v1::Table::AsyncApply</a></div><div class="ttdeci">future&lt; Status &gt; AsyncApply(SingleRowMutation mut, CompletionQueue &amp;cq)</div><div class="ttdoc">Makes asynchronous attempts to apply the mutation to a row.</div><div class="ttdef"><b>Definition:</b> <a href="table_8cc_source.html#l00113">table.cc:113</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Cell_html_a68f9e5cd687662c1a5ea8b3bbc8ef2b8"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Cell.html#a68f9e5cd687662c1a5ea8b3bbc8ef2b8">google::cloud::bigtable::v1::Cell::column_qualifier</a></div><div class="ttdeci">ColumnQualifierType const  &amp; column_qualifier() const</div><div class="ttdoc">Return the column this cell belongs to.</div><div class="ttdef"><b>Definition:</b> <a href="cell_8h_source.html#l00140">cell.h:140</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table_html_a16b2a091eccd88d9762d93f874c98fef"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a16b2a091eccd88d9762d93f874c98fef">google::cloud::bigtable::v1::Table::AsyncBulkApply</a></div><div class="ttdeci">future&lt; std::vector&lt; FailedMutation &gt; &gt; AsyncBulkApply(BulkMutation mut, CompletionQueue &amp;cq)</div><div class="ttdoc">Makes asynchronous attempts to apply mutations to multiple rows.</div><div class="ttdef"><b>Definition:</b> <a href="table_8cc_source.html#l00178">table.cc:178</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Cell_html_af73803defe911671a7fe2e01afe446b2"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Cell.html#af73803defe911671a7fe2e01afe446b2">google::cloud::bigtable::v1::Cell::row_key</a></div><div class="ttdeci">RowKeyType const  &amp; row_key() const</div><div class="ttdoc">Return the row key this cell belongs to.</div><div class="ttdef"><b>Definition:</b> <a href="cell_8h_source.html#l00132">cell.h:132</a></div></div>
<div class="ttc" id="anamespacegoogle_1_1cloud_1_1v1_html_a2421390acdf2c6b05f2f4bb0c3b9549e"><div class="ttname"><a href="https://googleapis.dev/cpp/google-cloud-common/latest/namespacegoogle_1_1cloud_1_1v1.html#a2421390acdf2c6b05f2f4bb0c3b9549e">make_ready_future</a></div><div class="ttdeci">future&lt; typename internal::make_ready_return&lt; T &gt;::type &gt; make_ready_future(T &amp;&amp;t)</div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ClientOptions_html"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ClientOptions.html">google::cloud::bigtable::v1::ClientOptions</a></div><div class="ttdoc">Configuration options for the Bigtable Client.</div><div class="ttdef"><b>Definition:</b> <a href="client__options_8h_source.html#l00047">client_options.h:47</a></div></div>
<div class="ttc" id="anamespacegoogle_1_1cloud_1_1bigtable_1_1v1_html_a0fa701b519d83686c5ffcdd4cbb24e3d"><div class="ttname"><a href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#a0fa701b519d83686c5ffcdd4cbb24e3d">google::cloud::bigtable::v1::CreateDefaultDataClient</a></div><div class="ttdeci">std::shared_ptr&lt; DataClient &gt; CreateDefaultDataClient(std::string project_id, std::string instance_id, ClientOptions options)</div><div class="ttdoc">Create the default implementation of ClientInterface.</div><div class="ttdef"><b>Definition:</b> <a href="data__client_8cc_source.html#l00368">data_client.cc:368</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1BulkMutation_html_a6c59856e590279a86154741ab95c218b"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1BulkMutation.html#a6c59856e590279a86154741ab95c218b">google::cloud::bigtable::v1::BulkMutation::emplace_back</a></div><div class="ttdeci">BulkMutation &amp; emplace_back(SingleRowMutation mut)</div><div class="ttdef"><b>Definition:</b> <a href="mutations_8h_source.html#l00508">mutations.h:508</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table_html_a83b9f3b405faa95ddb3c57e8e3820fc8"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a83b9f3b405faa95ddb3c57e8e3820fc8">google::cloud::bigtable::v1::Table::table_id</a></div><div class="ttdeci">std::string const  &amp; table_id() const</div><div class="ttdef"><b>Definition:</b> <a href="table_8h_source.html#l00355">table.h:355</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table_html"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html">google::cloud::bigtable::v1::Table</a></div><div class="ttdoc">The main interface to interact with data in a Cloud Bigtable table.</div><div class="ttdef"><b>Definition:</b> <a href="table_8h_source.html#l00165">table.h:165</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Filter_html"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Filter.html">google::cloud::bigtable::v1::Filter</a></div><div class="ttdoc">Define the interfaces to create filter expressions.</div><div class="ttdef"><b>Definition:</b> <a href="filters_8h_source.html#l00049">filters.h:49</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table_html_a7d89ad8f5b46838e38e620f1912b43c3"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a7d89ad8f5b46838e38e620f1912b43c3">google::cloud::bigtable::v1::Table::SampleRows</a></div><div class="ttdeci">StatusOr&lt; std::vector&lt; bigtable::RowKeySample &gt; &gt; SampleRows()</div><div class="ttdoc">Sample of the row keys in the table, including approximate data sizes.</div><div class="ttdef"><b>Definition:</b> <a href="table_8cc_source.html#l00304">table.cc:304</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1SingleRowMutation_html"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1SingleRowMutation.html">google::cloud::bigtable::v1::SingleRowMutation</a></div><div class="ttdoc">Represent a single row mutation.</div><div class="ttdef"><b>Definition:</b> <a href="mutations_8h_source.html#l00293">mutations.h:293</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table_html_adcbbae9a9344ec38cf0987e6433b8191"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#adcbbae9a9344ec38cf0987e6433b8191">google::cloud::bigtable::v1::Table::AsyncReadModifyWriteRow</a></div><div class="ttdeci">future&lt; StatusOr&lt; Row &gt; &gt; AsyncReadModifyWriteRow(std::string row_key, CompletionQueue &amp;cq, bigtable::ReadModifyWriteRule rule, Args &amp;&amp;... rules)</div><div class="ttdoc">Make an asynchronous request to atomically read and modify a row.</div><div class="ttdef"><b>Definition:</b> <a href="table_8h_source.html#l00700">table.h:700</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table_html_aa71a3d0a41ce3f93948fe324d741a09a"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#aa71a3d0a41ce3f93948fe324d741a09a">google::cloud::bigtable::v1::Table::AsyncCheckAndMutateRow</a></div><div class="ttdeci">future&lt; StatusOr&lt; MutationBranch &gt; &gt; AsyncCheckAndMutateRow(std::string row_key, Filter filter, std::vector&lt; Mutation &gt; true_mutations, std::vector&lt; Mutation &gt; false_mutations, CompletionQueue &amp;cq)</div><div class="ttdoc">Make an asynchronous request to conditionally mutate a row.</div><div class="ttdef"><b>Definition:</b> <a href="table_8cc_source.html#l00256">table.cc:256</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table_html_a2fe1685174cfbc3cab5ccb887451b6ab"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a2fe1685174cfbc3cab5ccb887451b6ab">google::cloud::bigtable::v1::Table::CheckAndMutateRow</a></div><div class="ttdeci">StatusOr&lt; MutationBranch &gt; CheckAndMutateRow(std::string row_key, Filter filter, std::vector&lt; Mutation &gt; true_mutations, std::vector&lt; Mutation &gt; false_mutations)</div><div class="ttdoc">Atomic test-and-set for a row using filter expressions.</div><div class="ttdef"><b>Definition:</b> <a href="table_8cc_source.html#l00226">table.cc:226</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Cell_html"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Cell.html">google::cloud::bigtable::v1::Cell</a></div><div class="ttdoc">The in-memory representation of a Bigtable cell.</div><div class="ttdef"><b>Definition:</b> <a href="cell_8h_source.html#l00089">cell.h:89</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table_html_a76145b69620f01fced8949911d8403a8"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a76145b69620f01fced8949911d8403a8">google::cloud::bigtable::v1::Table::ReadModifyWriteRow</a></div><div class="ttdeci">StatusOr&lt; Row &gt; ReadModifyWriteRow(std::string row_key, bigtable::ReadModifyWriteRule rule, Args &amp;&amp;... rules)</div><div class="ttdoc">Atomically read and modify the row in the server, returning the resulting row.</div><div class="ttdef"><b>Definition:</b> <a href="table_8h_source.html#l00646">table.h:646</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Cell_html_a6d01e22c1f3531142e18170d825bd8d0"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Cell.html#a6d01e22c1f3531142e18170d825bd8d0">google::cloud::bigtable::v1::Cell::value</a></div><div class="ttdeci">CellValueType const  &amp; value() const &amp;</div><div class="ttdoc">Return the contents of this cell.</div><div class="ttdef"><b>Definition:</b> <a href="cell_8h_source.html#l00151">cell.h:151</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Cell_html_ad669a9bdafb01565e743cb646260792e"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Cell.html#ad669a9bdafb01565e743cb646260792e">google::cloud::bigtable::v1::Cell::timestamp</a></div><div class="ttdeci">std::chrono::microseconds timestamp() const</div><div class="ttdoc">Return the timestamp of this cell.</div><div class="ttdef"><b>Definition:</b> <a href="cell_8h_source.html#l00145">cell.h:145</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1LimitedErrorCountRetryPolicy_html"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1LimitedErrorCountRetryPolicy.html">google::cloud::bigtable::v1::LimitedErrorCountRetryPolicy</a></div><div class="ttdoc">Implement a simple &quot;count errors and then stop&quot; retry policy.</div><div class="ttdef"><b>Definition:</b> <a href="rpc__retry__policy_8h_source.html#l00128">rpc_retry_policy.h:128</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1BulkMutation_html"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1BulkMutation.html">google::cloud::bigtable::v1::BulkMutation</a></div><div class="ttdoc">Represent a set of mutations across multiple rows.</div><div class="ttdef"><b>Definition:</b> <a href="mutations_8h_source.html#l00466">mutations.h:466</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Cell_html_a5d48f337d1c9d2234541beecbf11915c"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Cell.html#a5d48f337d1c9d2234541beecbf11915c">google::cloud::bigtable::v1::Cell::family_name</a></div><div class="ttdeci">std::string const  &amp; family_name() const</div><div class="ttdoc">Return the family this cell belongs to.</div><div class="ttdef"><b>Definition:</b> <a href="cell_8h_source.html#l00136">cell.h:136</a></div></div>
<div class="ttc" id="anamespacegoogle_1_1cloud_1_1bigtable_1_1v1_html_ac409cdf17f67843fc4279464cc240394"><div class="ttname"><a href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#ac409cdf17f67843fc4279464cc240394">google::cloud::bigtable::v1::SetCell</a></div><div class="ttdeci">Mutation SetCell(Cell)</div><div class="ttdoc">Create a mutation to set a cell value based on a bigtable::Cell.</div><div class="ttdef"><b>Definition:</b> <a href="mutations_8cc_source.html#l00035">mutations.cc:35</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Row_html"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Row.html">google::cloud::bigtable::v1::Row</a></div><div class="ttdoc">The in-memory representation of a Bigtable row.</div><div class="ttdef"><b>Definition:</b> <a href="row_8h_source.html#l00034">row.h:34</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table_html_a430b10cee0704099c000f99418676916"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a430b10cee0704099c000f99418676916">google::cloud::bigtable::v1::Table::project_id</a></div><div class="ttdeci">std::string const  &amp; project_id() const</div><div class="ttdef"><b>Definition:</b> <a href="table_8h_source.html#l00353">table.h:353</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table_html_adc6306c3f4c31e27be8432b279c12c27"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#adc6306c3f4c31e27be8432b279c12c27">google::cloud::bigtable::v1::Table::ReadRows</a></div><div class="ttdeci">RowReader ReadRows(RowSet row_set, Filter filter)</div><div class="ttdoc">Reads a set of rows from the table.</div><div class="ttdef"><b>Definition:</b> <a href="table_8cc_source.html#l00187">table.cc:187</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table_html_a2fbbbab420ecee307d1283fcd7d2e1f5"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a2fbbbab420ecee307d1283fcd7d2e1f5">google::cloud::bigtable::v1::Table::ReadRow</a></div><div class="ttdeci">StatusOr&lt; std::pair&lt; bool, Row &gt; &gt; ReadRow(std::string row_key, Filter filter)</div><div class="ttdoc">Read and return a single row from the table.</div><div class="ttdef"><b>Definition:</b> <a href="table_8cc_source.html#l00204">table.cc:204</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table_html_a7a5c8c8c128e5533205d41829753d439"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Table.html#a7a5c8c8c128e5533205d41829753d439">google::cloud::bigtable::v1::Table::instance_id</a></div><div class="ttdeci">std::string const  &amp; instance_id() const</div><div class="ttdef"><b>Definition:</b> <a href="table_8h_source.html#l00354">table.h:354</a></div></div>
<div class="ttc" id="anamespacegoogle_1_1cloud_1_1bigtable_html"><div class="ttname"><a href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a></div><div class="ttdoc">Contains all the Cloud Bigtable C++ client APIs.</div><div class="ttdef"><b>Definition:</b> <a href="admin__client_8cc_source.html#l00021">admin_client.cc:21</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1AlwaysRetryMutationPolicy_html"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1AlwaysRetryMutationPolicy.html">google::cloud::bigtable::v1::AlwaysRetryMutationPolicy</a></div><div class="ttdoc">Implements a policy that retries all mutations.</div><div class="ttdef"><b>Definition:</b> <a href="idempotent__mutation__policy_8h_source.html#l00075">idempotent_mutation_policy.h:75</a></div></div>
<div class="ttc" id="aclassgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Row_html_a9c86ed8607457b3f3162655c26c54c80"><div class="ttname"><a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1Row.html#a9c86ed8607457b3f3162655c26c54c80">google::cloud::bigtable::v1::Row::cells</a></div><div class="ttdeci">std::vector&lt; Cell &gt; const  &amp; cells() const &amp;</div><div class="ttdoc">Return all cells.</div><div class="ttdef"><b>Definition:</b> <a href="row_8h_source.html#l00046">row.h:46</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
