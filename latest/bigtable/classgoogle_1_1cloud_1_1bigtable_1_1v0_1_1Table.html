<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google Cloud Bigtable C++ Client: google::cloud::bigtable::v0::Table Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Google Cloud Bigtable C++ Client
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
   <div id="projectbrief">A C++ Client Library for Google Cloud Bigtable</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegoogle.html">google</a></li><li class="navelem"><a class="el" href="namespacegoogle_1_1cloud.html">cloud</a></li><li class="navelem"><a class="el" href="namespacegoogle_1_1cloud_1_1bigtable.html">bigtable</a></li><li class="navelem"><a class="el" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html">v0</a></li><li class="navelem"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html">Table</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">google::cloud::bigtable::v0::Table Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The main interface to interact with data in a Cloud Bigtable table.  
 <a href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="table_8h_source.html">google/cloud/bigtable/table.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7360745d0302bcf42e08dce2b40f088f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a7360745d0302bcf42e08dce2b40f088f">Table</a> (std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1DataClient.html">DataClient</a> &gt; client, std::string const &amp;<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a6a9474603a38e1398a9946cdf530413f">table_id</a>)</td></tr>
<tr class="memdesc:a7360745d0302bcf42e08dce2b40f088f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with default policies.  <a href="#a7360745d0302bcf42e08dce2b40f088f">More...</a><br /></td></tr>
<tr class="separator:a7360745d0302bcf42e08dce2b40f088f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71933c08e2b1ed812c353af336fae6c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a71933c08e2b1ed812c353af336fae6c5">Table</a> (std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1DataClient.html">DataClient</a> &gt; client, bigtable::AppProfileId <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a1a7cd66e835b39b90bd0009ccffd3add">app_profile_id</a>, std::string const &amp;<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a6a9474603a38e1398a9946cdf530413f">table_id</a>)</td></tr>
<tr class="memdesc:a71933c08e2b1ed812c353af336fae6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with default policies.  <a href="#a71933c08e2b1ed812c353af336fae6c5">More...</a><br /></td></tr>
<tr class="separator:a71933c08e2b1ed812c353af336fae6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c15317cfa9137f8efcd1c28a9528aee"><td class="memTemplParams" colspan="2">template&lt;typename... Policies&gt; </td></tr>
<tr class="memitem:a4c15317cfa9137f8efcd1c28a9528aee"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a4c15317cfa9137f8efcd1c28a9528aee">Table</a> (std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1DataClient.html">DataClient</a> &gt; client, std::string const &amp;<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a6a9474603a38e1398a9946cdf530413f">table_id</a>, Policies &amp;&amp;... policies)</td></tr>
<tr class="memdesc:a4c15317cfa9137f8efcd1c28a9528aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with explicit policies.  <a href="#a4c15317cfa9137f8efcd1c28a9528aee">More...</a><br /></td></tr>
<tr class="separator:a4c15317cfa9137f8efcd1c28a9528aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f6a3b5d7dddaa23b704510ff2c76ba"><td class="memTemplParams" colspan="2">template&lt;typename... Policies&gt; </td></tr>
<tr class="memitem:a78f6a3b5d7dddaa23b704510ff2c76ba"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a78f6a3b5d7dddaa23b704510ff2c76ba">Table</a> (std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1DataClient.html">DataClient</a> &gt; client, bigtable::AppProfileId <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a1a7cd66e835b39b90bd0009ccffd3add">app_profile_id</a>, std::string const &amp;<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a6a9474603a38e1398a9946cdf530413f">table_id</a>, Policies &amp;&amp;... policies)</td></tr>
<tr class="memdesc:a78f6a3b5d7dddaa23b704510ff2c76ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with explicit policies.  <a href="#a78f6a3b5d7dddaa23b704510ff2c76ba">More...</a><br /></td></tr>
<tr class="separator:a78f6a3b5d7dddaa23b704510ff2c76ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a84118bf4f098d5a4785b586484ab14"><td class="memItemLeft" align="right" valign="top">std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a1a84118bf4f098d5a4785b586484ab14">table_name</a> () const</td></tr>
<tr class="separator:a1a84118bf4f098d5a4785b586484ab14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7cd66e835b39b90bd0009ccffd3add"><td class="memItemLeft" align="right" valign="top">std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a1a7cd66e835b39b90bd0009ccffd3add">app_profile_id</a> () const</td></tr>
<tr class="separator:a1a7cd66e835b39b90bd0009ccffd3add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b5d612b5ef1ee0e178dfb388fe8d56"><td class="memItemLeft" align="right" valign="top">std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a44b5d612b5ef1ee0e178dfb388fe8d56">project_id</a> () const</td></tr>
<tr class="separator:a44b5d612b5ef1ee0e178dfb388fe8d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3592cbd3b3bb163c04b7a586bf0b0d8e"><td class="memItemLeft" align="right" valign="top">std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a3592cbd3b3bb163c04b7a586bf0b0d8e">instance_id</a> () const</td></tr>
<tr class="separator:a3592cbd3b3bb163c04b7a586bf0b0d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9474603a38e1398a9946cdf530413f"><td class="memItemLeft" align="right" valign="top">std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a6a9474603a38e1398a9946cdf530413f">table_id</a> () const</td></tr>
<tr class="separator:a6a9474603a38e1398a9946cdf530413f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078643ebc15409656f987ffd37db658c"><td class="memItemLeft" align="right" valign="top">Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a078643ebc15409656f987ffd37db658c">Apply</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1SingleRowMutation.html">SingleRowMutation</a> mut)</td></tr>
<tr class="memdesc:a078643ebc15409656f987ffd37db658c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to apply the mutation to a row.  <a href="#a078643ebc15409656f987ffd37db658c">More...</a><br /></td></tr>
<tr class="separator:a078643ebc15409656f987ffd37db658c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5fc541ea2468fe6c1945be8f975f72"><td class="memItemLeft" align="right" valign="top">future&lt; Status &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a0a5fc541ea2468fe6c1945be8f975f72">AsyncApply</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1SingleRowMutation.html">SingleRowMutation</a> mut, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;cq)</td></tr>
<tr class="memdesc:a0a5fc541ea2468fe6c1945be8f975f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes asynchronous attempts to apply the mutation to a row.  <a href="#a0a5fc541ea2468fe6c1945be8f975f72">More...</a><br /></td></tr>
<tr class="separator:a0a5fc541ea2468fe6c1945be8f975f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6468a7850ecf45a3dbc633b0bffdd134"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1FailedMutation.html">FailedMutation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a6468a7850ecf45a3dbc633b0bffdd134">BulkApply</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1BulkMutation.html">BulkMutation</a> mut)</td></tr>
<tr class="memdesc:a6468a7850ecf45a3dbc633b0bffdd134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to apply mutations to multiple rows.  <a href="#a6468a7850ecf45a3dbc633b0bffdd134">More...</a><br /></td></tr>
<tr class="separator:a6468a7850ecf45a3dbc633b0bffdd134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289cc53978c2462570fbe7f9f69b7eca"><td class="memItemLeft" align="right" valign="top">future&lt; std::vector&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1FailedMutation.html">FailedMutation</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a289cc53978c2462570fbe7f9f69b7eca">AsyncBulkApply</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1BulkMutation.html">BulkMutation</a> mut, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;cq)</td></tr>
<tr class="memdesc:a289cc53978c2462570fbe7f9f69b7eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes asynchronous attempts to apply mutations to multiple rows.  <a href="#a289cc53978c2462570fbe7f9f69b7eca">More...</a><br /></td></tr>
<tr class="separator:a289cc53978c2462570fbe7f9f69b7eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07fd0b3bc5b4fc17db8e3f099aaf9c33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RowReader.html">RowReader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a07fd0b3bc5b4fc17db8e3f099aaf9c33">ReadRows</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RowSet.html">RowSet</a> row_set, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Filter.html">Filter</a> filter)</td></tr>
<tr class="memdesc:a07fd0b3bc5b4fc17db8e3f099aaf9c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a set of rows from the table.  <a href="#a07fd0b3bc5b4fc17db8e3f099aaf9c33">More...</a><br /></td></tr>
<tr class="separator:a07fd0b3bc5b4fc17db8e3f099aaf9c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95295dc0c3dd50603926b6038160a071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RowReader.html">RowReader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a95295dc0c3dd50603926b6038160a071">ReadRows</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RowSet.html">RowSet</a> row_set, std::int64_t rows_limit, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Filter.html">Filter</a> filter)</td></tr>
<tr class="memdesc:a95295dc0c3dd50603926b6038160a071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a limited set of rows from the table.  <a href="#a95295dc0c3dd50603926b6038160a071">More...</a><br /></td></tr>
<tr class="separator:a95295dc0c3dd50603926b6038160a071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3eb95924778b80d60ebc9ead2036650"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; std::pair&lt; bool, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Row.html">Row</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#ac3eb95924778b80d60ebc9ead2036650">ReadRow</a> (std::string row_key, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Filter.html">Filter</a> filter)</td></tr>
<tr class="memdesc:ac3eb95924778b80d60ebc9ead2036650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and return a single row from the table.  <a href="#ac3eb95924778b80d60ebc9ead2036650">More...</a><br /></td></tr>
<tr class="separator:ac3eb95924778b80d60ebc9ead2036650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888246f28cc27ddd3d43c51c59ed29b9"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a888246f28cc27ddd3d43c51c59ed29b9">CheckAndMutateRow</a> (std::string row_key, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Filter.html">Filter</a> filter, std::vector&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Mutation.html">Mutation</a> &gt; true_mutations, std::vector&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Mutation.html">Mutation</a> &gt; false_mutations)</td></tr>
<tr class="memdesc:a888246f28cc27ddd3d43c51c59ed29b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic test-and-set for a row using filter expressions.  <a href="#a888246f28cc27ddd3d43c51c59ed29b9">More...</a><br /></td></tr>
<tr class="separator:a888246f28cc27ddd3d43c51c59ed29b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba17d2374bb74bda87f87633d11e5a97"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::v2::CheckAndMutateRowResponse &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#aba17d2374bb74bda87f87633d11e5a97">AsyncCheckAndMutateRow</a> (std::string row_key, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Filter.html">Filter</a> filter, std::vector&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Mutation.html">Mutation</a> &gt; true_mutations, std::vector&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Mutation.html">Mutation</a> &gt; false_mutations, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;cq)</td></tr>
<tr class="memdesc:aba17d2374bb74bda87f87633d11e5a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an asynchronous request to conditionally mutate a row.  <a href="#aba17d2374bb74bda87f87633d11e5a97">More...</a><br /></td></tr>
<tr class="separator:aba17d2374bb74bda87f87633d11e5a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7acffbcf43365528cde61d159e7a99"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; class Collection = std::vector&gt; </td></tr>
<tr class="memitem:aba7acffbcf43365528cde61d159e7a99"><td class="memTemplItemLeft" align="right" valign="top">StatusOr&lt; Collection&lt; bigtable::RowKeySample &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#aba7acffbcf43365528cde61d159e7a99">SampleRows</a> ()</td></tr>
<tr class="memdesc:aba7acffbcf43365528cde61d159e7a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample of the row keys in the table, including approximate data sizes.  <a href="#aba7acffbcf43365528cde61d159e7a99">More...</a><br /></td></tr>
<tr class="separator:aba7acffbcf43365528cde61d159e7a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4ddd0053141ed279da2bbeba76b06b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:afd4ddd0053141ed279da2bbeba76b06b"><td class="memTemplItemLeft" align="right" valign="top">StatusOr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Row.html">Row</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#afd4ddd0053141ed279da2bbeba76b06b">ReadModifyWriteRow</a> (std::string row_key, bigtable::ReadModifyWriteRule rule, Args &amp;&amp;... rules)</td></tr>
<tr class="memdesc:afd4ddd0053141ed279da2bbeba76b06b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically read and modify the row in the server, returning the resulting row.  <a href="#afd4ddd0053141ed279da2bbeba76b06b">More...</a><br /></td></tr>
<tr class="separator:afd4ddd0053141ed279da2bbeba76b06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4155f359afaa05605bc3a8dac671b271"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a4155f359afaa05605bc3a8dac671b271"><td class="memTemplItemLeft" align="right" valign="top">future&lt; StatusOr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Row.html">Row</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a4155f359afaa05605bc3a8dac671b271">AsyncReadModifyWriteRow</a> (std::string row_key, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;cq, bigtable::ReadModifyWriteRule rule, Args &amp;&amp;... rules)</td></tr>
<tr class="memdesc:a4155f359afaa05605bc3a8dac671b271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an asynchronous request to atomically read and modify a row.  <a href="#a4155f359afaa05605bc3a8dac671b271">More...</a><br /></td></tr>
<tr class="separator:a4155f359afaa05605bc3a8dac671b271"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a26c8f6be2070a3f5d8c01acabb3ad719"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a26c8f6be2070a3f5d8c01acabb3ad719">MutationBatcher</a></td></tr>
<tr class="separator:a26c8f6be2070a3f5d8c01acabb3ad719"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main interface to interact with data in a Cloud Bigtable table. </p>
<p>This class provides member functions to:</p><ul>
<li>read specific rows: <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#ac3eb95924778b80d60ebc9ead2036650" title="Read and return a single row from the table. ">Table::ReadRow()</a></code></li>
<li>scan a ranges of rows: <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a07fd0b3bc5b4fc17db8e3f099aaf9c33" title="Reads a set of rows from the table. ">Table::ReadRows()</a></code></li>
<li>update or create a single row: <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a078643ebc15409656f987ffd37db658c" title="Attempts to apply the mutation to a row. ">Table::Apply()</a></code></li>
<li>update or modify multiple rows: <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a6468a7850ecf45a3dbc633b0bffdd134" title="Attempts to apply mutations to multiple rows. ">Table::BulkApply()</a></code></li>
<li>update a row based on previous values: <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a888246f28cc27ddd3d43c51c59ed29b9" title="Atomic test-and-set for a row using filter expressions. ">Table::CheckAndMutateRow()</a></code></li>
<li>to atomically append data and/or increment multiple values in a row: <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#afd4ddd0053141ed279da2bbeba76b06b" title="Atomically read and modify the row in the server, returning the resulting row. ">Table::ReadModifyWriteRow()</a></code></li>
<li>to sample the row keys: <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#aba7acffbcf43365528cde61d159e7a99" title="Sample of the row keys in the table, including approximate data sizes. ">Table::SampleRows()</a></code>.</li>
</ul>
<p>The class deals with the most common transient failures, and retries the underlying RPC calls subject to the policies configured by the application. These policies are documented in <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a7360745d0302bcf42e08dce2b40f088f" title="Constructor with default policies. ">Table::Table()</a></code>.</p>
<dl class="section user"><dt>Thread-safety</dt><dd>Instances of this class created via copy-construction or copy-assignment share the underlying pool of connections. Access to these copies via multiple threads is guaranteed to work. Two threads operating on the same instance of this class is not guaranteed to work.</dd></dl>
<dl class="section user"><dt>Cost</dt><dd>Creating a new object of type <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html" title="The main interface to interact with data in a Cloud Bigtable table. ">Table</a></code> is comparable to creating a few objects of type <code>std::string</code> or a few objects of type <code>std::shared_ptr&lt;int&gt;</code>. The class represents a shallow handle to a remote object.</dd></dl>
<dl class="section user"><dt>Error Handling</dt><dd>This class uses <code>StatusOr&lt;T&gt;</code> to report errors. When an operation fails to perform its work the returned <code>StatusOr&lt;T&gt;</code> contains the error details. If the <code>ok()</code> member function in the <code>StatusOr&lt;T&gt;</code> returns <code>true</code> then it contains the expected result. Operations that do not return a value simply return a <code>google::cloud::Status</code> indicating success or the details of the error Please consult the <a href="#google::cloud::v0::StatusOr"><code>StatusOr&lt;T&gt;</code> documentation</a> for more details.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">cbt::Table = ...;</div><div class="line">google::cloud::StatusOr&lt;std::pair&lt;bool, cbt::Row&gt;&gt; row = table.ReadRow(...);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (!row) {</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;Error reading row\n&quot;</span>;</div><div class="line">  <span class="keywordflow">return</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Use &quot;row&quot; as a smart pointer here, e.g.:</span></div><div class="line"><span class="keywordflow">if</span> (!row-&gt;first) {</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Contacting the server was successful, but the row does not&quot;</span></div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; exist\n&quot;</span>;</div><div class="line">  <span class="keywordflow">return</span>;</div><div class="line">}</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The row has &quot;</span> &lt;&lt; row-&gt;second.cells().size() &lt;&lt; <span class="stringliteral">&quot; cells\n&quot;</span>;</div></div><!-- fragment --><p>In addition, the <a class="el" href="index.html">main page</a> contains examples using <code>StatusOr&lt;T&gt;</code> to handle errors.</p>
<dl class="section user"><dt>Retry, Backoff, and Idempotency Policies</dt><dd>The library automatically retries requests that fail with transient errors, and uses <a href="https://cloud.google.com/storage/docs/exponential-backoff">truncated exponential backoff</a> to backoff between retries. The default policies are to continue retrying for up to 10 minutes. On each transient failure the backoff period is doubled, starting with an initial backoff of 100 milliseconds. The backoff period growth is truncated at 60 seconds. The default idempotency policy is to only retry idempotent operations. Note that most operations that change state are <b>not</b> idempotent.</dd></dl>
<p>The application can override these policies when constructing objects of this class. The documentation for the constructors show examples of this in action.</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://cloud.google.com/bigtable/">https://cloud.google.com/bigtable/</a> for an overview of Cloud Bigtable.</dd>
<dd>
<a href="https://cloud.google.com/bigtable/docs/overview">https://cloud.google.com/bigtable/docs/overview</a> for an overview of the Cloud Bigtable data model.</dd>
<dd>
<a href="https://cloud.google.com/bigtable/docs/instances-clusters-nodes">https://cloud.google.com/bigtable/docs/instances-clusters-nodes</a> for an introduction of the <a class="el" href="table__admin__snippets_8cc.html#a0ddf1224851353fc92bfbff6f499fa97">main</a> APIs into Cloud Bigtable.</dd>
<dd>
<a href="https://cloud.google.com/bigtable/docs/reference/service-apis-overview">https://cloud.google.com/bigtable/docs/reference/service-apis-overview</a> for an overview of the underlying Cloud Bigtable API.</dd>
<dd>
<a class="elRef" doxygen="/v/cmake-out/ubuntu-18.04-gcc-Release/google/cloud/cloud.tag:../common/" href="../common/classgoogle_1_1cloud_1_1v0_1_1StatusOr.html">google::cloud::v0::StatusOr</a> for a description of the error reporting class used by this library.</dd>
<dd>
<code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1LimitedTimeRetryPolicy.html" title="Implement a simple &quot;keep trying for this time&quot; retry policy. ">LimitedTimeRetryPolicy</a></code> and <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1LimitedErrorCountRetryPolicy.html" title="Implement a simple &quot;count errors and then stop&quot; retry policy. ">LimitedErrorCountRetryPolicy</a></code> for alternative retry policies.</dd>
<dd>
<code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ExponentialBackoffPolicy.html" title="Implement a simple exponential backoff policy. ">ExponentialBackoffPolicy</a></code> to configure different parameters for the exponential backoff policy.</dd>
<dd>
<code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1SafeIdempotentMutationPolicy.html" title="Implements a policy that only accepts truly idempotent mutations. ">SafeIdempotentMutationPolicy</a></code> and <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1AlwaysRetryMutationPolicy.html" title="Implements a policy that retries all mutations. ">AlwaysRetryMutationPolicy</a></code> for alternative idempotency policies. </dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00130">130</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7360745d0302bcf42e08dce2b40f088f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7360745d0302bcf42e08dce2b40f088f">&#9670;&nbsp;</a></span>Table() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::cloud::bigtable::v0::Table::Table </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1DataClient.html">DataClient</a> &gt;&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>table_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with default policies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>how to communicate with Cloud Bigtable, including credentials, the project id, and the instance id. </td></tr>
    <tr><td class="paramname">table_id</td><td>the table id within the instance defined by client. The full table name is `client-&gt;instance_name() + '/tables/' + table_id`. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00140">140</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a71933c08e2b1ed812c353af336fae6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71933c08e2b1ed812c353af336fae6c5">&#9670;&nbsp;</a></span>Table() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::cloud::bigtable::v0::Table::Table </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1DataClient.html">DataClient</a> &gt;&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::AppProfileId&#160;</td>
          <td class="paramname"><em>app_profile_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>table_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with default policies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>how to communicate with Cloud Bigtable, including credentials, the project id, and the instance id. </td></tr>
    <tr><td class="paramname">app_profile_id</td><td>the app_profile_id needed for using the replication API. </td></tr>
    <tr><td class="paramname">table_id</td><td>the table id within the instance defined by client. The full table name is `client-&gt;instance_name() + '/tables/' + table_id`.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Example Using AppProfile</dt><dd><div class="fragment"><div class="line">  cbt::Table read(data_client, <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a412d4ff7e63afde75faebcbd07be0d4a">cbt::AppProfileId</a>(profile_id), <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a6a9474603a38e1398a9946cdf530413f">table_id</a>);</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> result =</div><div class="line">      read.ReadRow(<span class="stringliteral">&quot;key-0&quot;</span>, cbt::Filter::ColumnRangeClosed(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;c0&quot;</span>, <span class="stringliteral">&quot;c0&quot;</span>));</div><div class="line">  <span class="keywordflow">if</span> (!result) {</div><div class="line">    <span class="keywordflow">throw</span> std::runtime_error(result.status().message());</div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (!result-&gt;first) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Cannot find row &#39;key-0&#39; in the table: &quot;</span> &lt;&lt; <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a6a9474603a38e1398a9946cdf530413f">table_id</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span>&amp; cell = result-&gt;second.cells().front();</div><div class="line">  std::cout &lt;&lt; cell.family_name() &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; cell.column_qualifier() &lt;&lt; <span class="stringliteral">&quot;    @ &quot;</span></div><div class="line">            &lt;&lt; cell.timestamp().count() &lt;&lt; <span class="stringliteral">&quot;us\n&quot;</span></div><div class="line">            &lt;&lt; <span class="charliteral">&#39;&quot;&#39;</span> &lt;&lt; cell.value() &lt;&lt; <span class="charliteral">&#39;&quot;&#39;</span> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00159">159</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a4c15317cfa9137f8efcd1c28a9528aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c15317cfa9137f8efcd1c28a9528aee">&#9670;&nbsp;</a></span>Table() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Policies&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::cloud::bigtable::v0::Table::Table </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1DataClient.html">DataClient</a> &gt;&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>table_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Policies &amp;&amp;...&#160;</td>
          <td class="paramname"><em>policies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with explicit policies. </p>
<p>The policies are passed by value, because this makes it easy for applications to create them.</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">using namespace </span>std::chrono_literals; <span class="comment">// assuming C++14.</span></div><div class="line"><span class="keyword">auto</span> client = bigtable::CreateDefaultClient(...); <span class="comment">// details ommitted</span></div><div class="line">bigtable::Table table(client, <span class="stringliteral">&quot;my-table&quot;</span>,</div><div class="line">                      <span class="comment">// Allow up to 20 minutes to retry operations</span></div><div class="line">                      bigtable::LimitedTimeRetryPolicy(20min),</div><div class="line">                      <span class="comment">// Start with 50 milliseconds backoff, grow</span></div><div class="line">                      <span class="comment">// exponentially to 5 minutes.</span></div><div class="line">                      bigtable::ExponentialBackoffPolicy(50ms, 5min),</div><div class="line">                      <span class="comment">// Only retry idempotent mutations.</span></div><div class="line">                      bigtable::SafeIdempotentMutationPolicy());</div></div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>how to communicate with Cloud Bigtable, including credentials, the project id, and the instance id. </td></tr>
    <tr><td class="paramname">table_id</td><td>the table id within the instance defined by client. The full table name is <code>client-&gt;instance_name() + "/tables/" + table_id</code>. </td></tr>
    <tr><td class="paramname">policies</td><td>the set of policy overrides for this object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Policies</td><td>the types of the policies to override, the types must derive from one of the following types:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1IdempotentMutationPolicy.html" title="Defines the interface to control which mutations are idempotent and therefore can be re-tried...">IdempotentMutationPolicy</a></code> which mutations are retried. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1SafeIdempotentMutationPolicy.html" title="Implements a policy that only accepts truly idempotent mutations. ">SafeIdempotentMutationPolicy</a></code> to only retry idempotent operations, use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1AlwaysRetryMutationPolicy.html" title="Implements a policy that retries all mutations. ">AlwaysRetryMutationPolicy</a></code> to retry all operations. Read the caveats in the class definition to understand the downsides of the latter. You can also create your own policies that decide which mutations to retry.</li>
<li><code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RPCBackoffPolicy.html" title="Define the interface for controlling how the Bigtable client backsoff from failed RPC operations...">RPCBackoffPolicy</a></code> how to backoff from a failed RPC. Currently only <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ExponentialBackoffPolicy.html" title="Implement a simple exponential backoff policy. ">ExponentialBackoffPolicy</a></code> is implemented. You can also create your own policies that backoff using a different algorithm.</li>
<li><code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RPCRetryPolicy.html" title="Define the interface for controlling how the Bigtable client retries RPC operations. ">RPCRetryPolicy</a></code> for how long to retry failed RPCs. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1LimitedErrorCountRetryPolicy.html" title="Implement a simple &quot;count errors and then stop&quot; retry policy. ">LimitedErrorCountRetryPolicy</a></code> to limit the number of failures allowed. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1LimitedTimeRetryPolicy.html" title="Implement a simple &quot;keep trying for this time&quot; retry policy. ">LimitedTimeRetryPolicy</a></code> to bound the time for any request. You can also create your own policies that combine time and error counts.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1SafeIdempotentMutationPolicy.html" title="Implements a policy that only accepts truly idempotent mutations. ">SafeIdempotentMutationPolicy</a>, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1AlwaysRetryMutationPolicy.html" title="Implements a policy that retries all mutations. ">AlwaysRetryMutationPolicy</a>, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ExponentialBackoffPolicy.html" title="Implement a simple exponential backoff policy. ">ExponentialBackoffPolicy</a>, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1LimitedErrorCountRetryPolicy.html" title="Implement a simple &quot;count errors and then stop&quot; retry policy. ">LimitedErrorCountRetryPolicy</a>, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1LimitedTimeRetryPolicy.html" title="Implement a simple &quot;keep trying for this time&quot; retry policy. ">LimitedTimeRetryPolicy</a>.</dd></dl>
<dl class="section user"><dt>Idempotency Policy Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](std::string <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a44b5d612b5ef1ee0e178dfb388fe8d56">project_id</a>, std::string <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a3592cbd3b3bb163c04b7a586bf0b0d8e">instance_id</a>, std::string <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a6a9474603a38e1398a9946cdf530413f">table_id</a>,</div><div class="line">     std::string row_key) {</div><div class="line">    cbt::Table table(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#ad04b836c839640c3e4474eec5f17cbff">cbt::CreateDefaultDataClient</a>(project_id, instance_id,</div><div class="line">                                                  cbt::ClientOptions()),</div><div class="line">                     table_id, cbt::AlwaysRetryMutationPolicy());</div><div class="line">    <span class="comment">// Normally this is not retried on transient failures, because the operation</span></div><div class="line">    <span class="comment">// is not idempotent (each retry would set a different timestamp), in this</span></div><div class="line">    <span class="comment">// case it would, because the table is setup to always retry.</span></div><div class="line">    cbt::SingleRowMutation mutation(</div><div class="line">        row_key, <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;some-column&quot;</span>, <span class="stringliteral">&quot;some-value&quot;</span>));</div><div class="line">    google::cloud::Status status = table.Apply(std::move(mutation));</div><div class="line">    <span class="keywordflow">if</span> (!status.ok()) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(status.message());</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Modified Retry Policy Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](std::string <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a44b5d612b5ef1ee0e178dfb388fe8d56">project_id</a>, std::string <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a3592cbd3b3bb163c04b7a586bf0b0d8e">instance_id</a>, std::string <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a6a9474603a38e1398a9946cdf530413f">table_id</a>,</div><div class="line">     std::string row_key) {</div><div class="line">    cbt::Table table(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#ad04b836c839640c3e4474eec5f17cbff">cbt::CreateDefaultDataClient</a>(project_id, instance_id,</div><div class="line">                                                  cbt::ClientOptions()),</div><div class="line">                     table_id, cbt::LimitedErrorCountRetryPolicy(7));</div><div class="line">    cbt::SingleRowMutation mutation(</div><div class="line">        row_key, <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;some-column&quot;</span>,</div><div class="line">                              std::chrono ::milliseconds(0), <span class="stringliteral">&quot;some-value&quot;</span>));</div><div class="line">    google::cloud::Status status = table.Apply(std::move(mutation));</div><div class="line">    <span class="keywordflow">if</span> (!status.ok()) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(status.message());</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00217">217</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a78f6a3b5d7dddaa23b704510ff2c76ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f6a3b5d7dddaa23b704510ff2c76ba">&#9670;&nbsp;</a></span>Table() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Policies&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::cloud::bigtable::v0::Table::Table </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1DataClient.html">DataClient</a> &gt;&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::AppProfileId&#160;</td>
          <td class="paramname"><em>app_profile_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>table_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Policies &amp;&amp;...&#160;</td>
          <td class="paramname"><em>policies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with explicit policies. </p>
<p>The policies are passed by value, because this makes it easy for applications to create them.</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">using namespace </span>std::chrono_literals; <span class="comment">// assuming C++14.</span></div><div class="line"><span class="keyword">auto</span> client = bigtable::CreateDefaultClient(...); <span class="comment">// details ommitted</span></div><div class="line">bigtable::Table table(client, <span class="stringliteral">&quot;app_id&quot;</span>, <span class="stringliteral">&quot;my-table&quot;</span>,</div><div class="line">                      <span class="comment">// Allow up to 20 minutes to retry operations</span></div><div class="line">                      bigtable::LimitedTimeRetryPolicy(20min),</div><div class="line">                      <span class="comment">// Start with 50 milliseconds backoff, grow</span></div><div class="line">                      <span class="comment">// exponentially to 5 minutes.</span></div><div class="line">                      bigtable::ExponentialBackoffPolicy(50ms, 5min),</div><div class="line">                      <span class="comment">// Only retry idempotent mutations.</span></div><div class="line">                      bigtable::SafeIdempotentMutationPolicy());</div></div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>how to communicate with Cloud Bigtable, including credentials, the project id, and the instance id. </td></tr>
    <tr><td class="paramname">app_profile_id</td><td>the app_profile_id needed for using the replication API. </td></tr>
    <tr><td class="paramname">table_id</td><td>the table id within the instance defined by client. The full table name is <code>client-&gt;instance_name() + "/tables/" + table_id</code>. </td></tr>
    <tr><td class="paramname">policies</td><td>the set of policy overrides for this object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Policies</td><td>the types of the policies to override, the types must derive from one of the following types:<ul>
<li><code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1IdempotentMutationPolicy.html" title="Defines the interface to control which mutations are idempotent and therefore can be re-tried...">IdempotentMutationPolicy</a></code> which mutations are retried. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1SafeIdempotentMutationPolicy.html" title="Implements a policy that only accepts truly idempotent mutations. ">SafeIdempotentMutationPolicy</a></code> to only retry idempotent operations, use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1AlwaysRetryMutationPolicy.html" title="Implements a policy that retries all mutations. ">AlwaysRetryMutationPolicy</a></code> to retry all operations. Read the caveats in the class definition to understand the downsides of the latter. You can also create your own policies that decide which mutations to retry.</li>
<li><code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RPCBackoffPolicy.html" title="Define the interface for controlling how the Bigtable client backsoff from failed RPC operations...">RPCBackoffPolicy</a></code> how to backoff from a failed RPC. Currently only <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ExponentialBackoffPolicy.html" title="Implement a simple exponential backoff policy. ">ExponentialBackoffPolicy</a></code> is implemented. You can also create your own policies that backoff using a different algorithm.</li>
<li><code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RPCRetryPolicy.html" title="Define the interface for controlling how the Bigtable client retries RPC operations. ">RPCRetryPolicy</a></code> for how long to retry failed RPCs. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1LimitedErrorCountRetryPolicy.html" title="Implement a simple &quot;count errors and then stop&quot; retry policy. ">LimitedErrorCountRetryPolicy</a></code> to limit the number of failures allowed. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1LimitedTimeRetryPolicy.html" title="Implement a simple &quot;keep trying for this time&quot; retry policy. ">LimitedTimeRetryPolicy</a></code> to bound the time for any request. You can also create your own policies that combine time and error counts.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1SafeIdempotentMutationPolicy.html" title="Implements a policy that only accepts truly idempotent mutations. ">SafeIdempotentMutationPolicy</a>, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1AlwaysRetryMutationPolicy.html" title="Implements a policy that retries all mutations. ">AlwaysRetryMutationPolicy</a>, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ExponentialBackoffPolicy.html" title="Implement a simple exponential backoff policy. ">ExponentialBackoffPolicy</a>, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1LimitedErrorCountRetryPolicy.html" title="Implement a simple &quot;count errors and then stop&quot; retry policy. ">LimitedErrorCountRetryPolicy</a>, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1LimitedTimeRetryPolicy.html" title="Implement a simple &quot;keep trying for this time&quot; retry policy. ">LimitedTimeRetryPolicy</a>.</dd></dl>
<dl class="section user"><dt>Idempotency Policy Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](std::string <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a44b5d612b5ef1ee0e178dfb388fe8d56">project_id</a>, std::string <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a3592cbd3b3bb163c04b7a586bf0b0d8e">instance_id</a>, std::string <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a6a9474603a38e1398a9946cdf530413f">table_id</a>,</div><div class="line">     std::string row_key) {</div><div class="line">    cbt::Table table(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#ad04b836c839640c3e4474eec5f17cbff">cbt::CreateDefaultDataClient</a>(project_id, instance_id,</div><div class="line">                                                  cbt::ClientOptions()),</div><div class="line">                     table_id, cbt::AlwaysRetryMutationPolicy());</div><div class="line">    <span class="comment">// Normally this is not retried on transient failures, because the operation</span></div><div class="line">    <span class="comment">// is not idempotent (each retry would set a different timestamp), in this</span></div><div class="line">    <span class="comment">// case it would, because the table is setup to always retry.</span></div><div class="line">    cbt::SingleRowMutation mutation(</div><div class="line">        row_key, <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;some-column&quot;</span>, <span class="stringliteral">&quot;some-value&quot;</span>));</div><div class="line">    google::cloud::Status status = table.Apply(std::move(mutation));</div><div class="line">    <span class="keywordflow">if</span> (!status.ok()) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(status.message());</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Modified Retry Policy Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](std::string <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a44b5d612b5ef1ee0e178dfb388fe8d56">project_id</a>, std::string <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a3592cbd3b3bb163c04b7a586bf0b0d8e">instance_id</a>, std::string <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a6a9474603a38e1398a9946cdf530413f">table_id</a>,</div><div class="line">     std::string row_key) {</div><div class="line">    cbt::Table table(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#ad04b836c839640c3e4474eec5f17cbff">cbt::CreateDefaultDataClient</a>(project_id, instance_id,</div><div class="line">                                                  cbt::ClientOptions()),</div><div class="line">                     table_id, cbt::LimitedErrorCountRetryPolicy(7));</div><div class="line">    cbt::SingleRowMutation mutation(</div><div class="line">        row_key, <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;some-column&quot;</span>,</div><div class="line">                              std::chrono ::milliseconds(0), <span class="stringliteral">&quot;some-value&quot;</span>));</div><div class="line">    google::cloud::Status status = table.Apply(std::move(mutation));</div><div class="line">    <span class="keywordflow">if</span> (!status.ok()) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(status.message());</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00277">277</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1a7cd66e835b39b90bd0009ccffd3add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7cd66e835b39b90bd0009ccffd3add">&#9670;&nbsp;</a></span>app_profile_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string const&amp; google::cloud::bigtable::v0::Table::app_profile_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00284">284</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a078643ebc15409656f987ffd37db658c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078643ebc15409656f987ffd37db658c">&#9670;&nbsp;</a></span>Apply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Status google::cloud::bigtable::v0::Table::Apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1SingleRowMutation.html">SingleRowMutation</a>&#160;</td>
          <td class="paramname"><em>mut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to apply the mutation to a row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut</td><td>the mutation. Note that this function takes ownership (and then discards) the data in the mutation. In general, a <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1SingleRowMutation.html" title="Represent a single row mutation. ">SingleRowMutation</a></code> can be used to modify and/or delete multiple cells, across different columns and column families.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the operation.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is idempotent if the provided mutations are idempotent. Note that <code><a class="el" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18" title="Create a mutation to set a cell value. ">google::cloud::bigtable::SetCell()</a></code> without an explicit timestamp is <b>not</b> an idempotent operation.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::Table table) {</div><div class="line">    <span class="keyword">auto</span> timestamp = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div><div class="line">        std::chrono::system_clock::now().time_since_epoch());</div><div class="line"></div><div class="line">    cbt::SingleRowMutation mutation(<span class="stringliteral">&quot;test-key-for-apply&quot;</span>);</div><div class="line">    mutation.emplace_back(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;some-column&quot;</span>, <span class="stringliteral">&quot;some-value&quot;</span>));</div><div class="line">    mutation.emplace_back(</div><div class="line">        <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;another-column&quot;</span>, <span class="stringliteral">&quot;another-value&quot;</span>));</div><div class="line">    mutation.emplace_back(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;even-more-columns&quot;</span>, timestamp,</div><div class="line">                                       <span class="stringliteral">&quot;with-explicit-timestamp&quot;</span>));</div><div class="line">    google::cloud::Status status = table.Apply(std::move(mutation));</div><div class="line">    <span class="keywordflow">if</span> (!status.ok()) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(status.message());</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8cc_source.html#l00032">32</a> of file <a class="el" href="table_8cc_source.html">table.cc</a>.</p>

</div>
</div>
<a id="a0a5fc541ea2468fe6c1945be8f975f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5fc541ea2468fe6c1945be8f975f72">&#9670;&nbsp;</a></span>AsyncApply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; Status &gt; google::cloud::bigtable::v0::Table::AsyncApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1SingleRowMutation.html">SingleRowMutation</a>&#160;</td>
          <td class="paramname"><em>mut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes asynchronous attempts to apply the mutation to a row. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut</td><td>the mutation. Note that this function takes ownership (and then discards) the data in the mutation. In general, a <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1SingleRowMutation.html" title="Represent a single row mutation. ">SingleRowMutation</a></code> can be used to modify and/or delete multiple cells, across different columns and column families. </td></tr>
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is idempotent if the provided mutations are idempotent. Note that <code><a class="el" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18" title="Create a mutation to set a cell value. ">google::cloud::bigtable::SetCell()</a></code> without an explicit timestamp is <b>not</b> an idempotent operation.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::Table table, cbt::CompletionQueue cq, std::string <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a6a9474603a38e1398a9946cdf530413f">table_id</a>,</div><div class="line">     std::string row_key) {</div><div class="line">    <span class="keyword">auto</span> timestamp = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div><div class="line">        std::chrono::system_clock::now().time_since_epoch());</div><div class="line"></div><div class="line">    cbt::SingleRowMutation mutation(row_key);</div><div class="line">    mutation.emplace_back(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;some-column&quot;</span>, <span class="stringliteral">&quot;some-value&quot;</span>));</div><div class="line">    mutation.emplace_back(</div><div class="line">        <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;another-column&quot;</span>, <span class="stringliteral">&quot;another-value&quot;</span>));</div><div class="line">    mutation.emplace_back(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;even-more-columns&quot;</span>, timestamp,</div><div class="line">                                       <span class="stringliteral">&quot;with-explicit-timestamp&quot;</span>));</div><div class="line"></div><div class="line">    google::cloud::future&lt;google::cloud::Status&gt; fut =</div><div class="line">        table.AsyncApply(std::move(mutation), cq);</div><div class="line">    google::cloud::Status status = fut.get();</div><div class="line">    <span class="keywordflow">if</span> (!status.ok()) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(status.message());</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Successfully applied mutation\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8cc_source.html#l00076">76</a> of file <a class="el" href="table_8cc_source.html">table.cc</a>.</p>

</div>
</div>
<a id="a289cc53978c2462570fbe7f9f69b7eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289cc53978c2462570fbe7f9f69b7eca">&#9670;&nbsp;</a></span>AsyncBulkApply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; std::vector&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1FailedMutation.html">FailedMutation</a> &gt; &gt; google::cloud::bigtable::v0::Table::AsyncBulkApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1BulkMutation.html">BulkMutation</a>&#160;</td>
          <td class="paramname"><em>mut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes asynchronous attempts to apply mutations to multiple rows. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut</td><td>the mutations, note that this function takes ownership (and then discards) the data in the mutation. In general, a <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1BulkMutation.html" title="Represent a set of mutations across multiple rows. ">BulkMutation</a></code> can modify multiple rows, and the modifications for each row can change (or create) multiple cells, across different columns and column families. </td></tr>
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is idempotent if the provided mutations are idempotent. Note that <code><a class="el" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18" title="Create a mutation to set a cell value. ">google::cloud::bigtable::SetCell()</a></code> without an explicit timestamp is <b>not</b> an idempotent operation.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::Table table, cbt::CompletionQueue cq, std::string <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a6a9474603a38e1398a9946cdf530413f">table_id</a>) {</div><div class="line">    <span class="comment">// Write several rows in a single operation, each row has some trivial data.</span></div><div class="line">    cbt::BulkMutation bulk;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != 5000; ++i) {</div><div class="line">      <span class="comment">// Note: This example uses sequential numeric IDs for simplicity, but</span></div><div class="line">      <span class="comment">// this can result in poor performance in a production application.</span></div><div class="line">      <span class="comment">// Since rows are stored in sorted order by key, sequential keys can</span></div><div class="line">      <span class="comment">// result in poor distribution of operations across nodes.</span></div><div class="line">      <span class="comment">//</span></div><div class="line">      <span class="comment">// For more information about how to design a Bigtable schema for the</span></div><div class="line">      <span class="comment">// best performance, see the documentation:</span></div><div class="line">      <span class="comment">//</span></div><div class="line">      <span class="comment">//     https://cloud.google.com/bigtable/docs/schema-design</span></div><div class="line">      <span class="keywordtype">char</span> buf[32];</div><div class="line">      snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class="stringliteral">&quot;key-%06d&quot;</span>, i);</div><div class="line">      cbt::SingleRowMutation mutation(buf);</div><div class="line">      mutation.emplace_back(</div><div class="line">          <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col0&quot;</span>, <span class="stringliteral">&quot;value0-&quot;</span> + std::to_string(i)));</div><div class="line">      mutation.emplace_back(</div><div class="line">          <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col1&quot;</span>, <span class="stringliteral">&quot;value2-&quot;</span> + std::to_string(i)));</div><div class="line">      mutation.emplace_back(</div><div class="line">          <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col2&quot;</span>, <span class="stringliteral">&quot;value3-&quot;</span> + std::to_string(i)));</div><div class="line">      mutation.emplace_back(</div><div class="line">          <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col3&quot;</span>, <span class="stringliteral">&quot;value4-&quot;</span> + std::to_string(i)));</div><div class="line">      bulk.emplace_back(std::move(mutation));</div><div class="line">    }</div><div class="line"></div><div class="line">    google::cloud::future&lt;std::vector&lt;cbt::FailedMutation&gt;&gt; fut =</div><div class="line">        table.AsyncBulkApply(std::move(bulk), cq);</div><div class="line"></div><div class="line">    fut.get();</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8cc_source.html#l00138">138</a> of file <a class="el" href="table_8cc_source.html">table.cc</a>.</p>

</div>
</div>
<a id="aba17d2374bb74bda87f87633d11e5a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba17d2374bb74bda87f87633d11e5a97">&#9670;&nbsp;</a></span>AsyncCheckAndMutateRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; btproto::CheckAndMutateRowResponse &gt; &gt; google::cloud::bigtable::v0::Table::AsyncCheckAndMutateRow </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>row_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Filter.html">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Mutation.html">Mutation</a> &gt;&#160;</td>
          <td class="paramname"><em>true_mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Mutation.html">Mutation</a> &gt;&#160;</td>
          <td class="paramname"><em>false_mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make an asynchronous request to conditionally mutate a row. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_key</td><td>the row key on which the conditional mutation will be performed </td></tr>
    <tr><td class="paramname">filter</td><td>the condition, depending on which the mutation will be performed </td></tr>
    <tr><td class="paramname">true_mutations</td><td>the mutations which will be performed if <code>filter</code> is true </td></tr>
    <tr><td class="paramname">false_mutations</td><td>the mutations which will be performed if <code>filter</code> is false </td></tr>
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::Table table, cbt::CompletionQueue cq, std::string <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a6a9474603a38e1398a9946cdf530413f">table_id</a>,</div><div class="line">     std::string row_key) {</div><div class="line">    <span class="comment">// Check if the latest value of the flip-flop column is &quot;on&quot;.</span></div><div class="line">    <span class="keyword">auto</span> predicate = cbt::Filter::Chain(</div><div class="line">        cbt::Filter::ColumnRangeClosed(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flip-flop&quot;</span>, <span class="stringliteral">&quot;flip-flop&quot;</span>),</div><div class="line">        cbt::Filter::Latest(1), cbt::Filter::ValueRegex(<span class="stringliteral">&quot;on&quot;</span>));</div><div class="line">    google::cloud::future&lt;google::cloud::StatusOr&lt;</div><div class="line">        google::bigtable::v2::CheckAndMutateRowResponse&gt;&gt;</div><div class="line">        future = table.AsyncCheckAndMutateRow(</div><div class="line">            row_key, std::move(predicate),</div><div class="line">            {<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flip-flop&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>),</div><div class="line">             <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flop-flip&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>)},</div><div class="line">            {<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flip-flop&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>),</div><div class="line">             <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flop-flip&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>)},</div><div class="line">            cq);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> <span class="keyword">final</span> =</div><div class="line">        future.then([](google::cloud::future&lt;google::cloud::StatusOr&lt;</div><div class="line">                           google::bigtable::v2::CheckAndMutateRowResponse&gt;&gt;</div><div class="line">                           f) {</div><div class="line">          <span class="keyword">auto</span> row = f.get();</div><div class="line">          <span class="keywordflow">if</span> (!row) {</div><div class="line">            <span class="keywordflow">throw</span> std::runtime_error(row.status().message());</div><div class="line">          }</div><div class="line"></div><div class="line">          <span class="keywordflow">return</span> google::cloud::Status();</div><div class="line">        });</div><div class="line">    <span class="keyword">final</span>.get();</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8cc_source.html#l00222">222</a> of file <a class="el" href="table_8cc_source.html">table.cc</a>.</p>

</div>
</div>
<a id="a4155f359afaa05605bc3a8dac671b271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4155f359afaa05605bc3a8dac671b271">&#9670;&nbsp;</a></span>AsyncReadModifyWriteRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">future&lt;StatusOr&lt;<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Row.html">Row</a>&gt; &gt; google::cloud::bigtable::v0::Table::AsyncReadModifyWriteRow </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>row_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::ReadModifyWriteRule&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rules</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an asynchronous request to atomically read and modify a row. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_key</td><td>the row key on which modification will be performed </td></tr>
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>.</td></tr>
    <tr><td class="paramname">rule</td><td>to modify the row. Two types of rules are applied here AppendValue which will read the existing value and append the text provided to the value. IncrementAmount which will read the existing uint64 big-endian-int and add the value provided. Both rules accept the family and column identifier to modify. </td></tr>
    <tr><td class="paramname">rules</td><td>is the zero or more ReadModifyWriteRules to apply on a row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A future, that becomes satisfied when the operation completes, at that point the future has the contents of all modified cells.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::Table table, cbt::CompletionQueue cq, std::string <a class="code" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a6a9474603a38e1398a9946cdf530413f">table_id</a>,</div><div class="line">     std::string row_key) {</div><div class="line">    future&lt;StatusOr&lt;cbt::Row&gt;&gt; async_future = table.AsyncReadModifyWriteRow(</div><div class="line">        row_key, cq,</div><div class="line">        cbt::ReadModifyWriteRule::AppendValue(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;list&quot;</span>, <span class="stringliteral">&quot;;element&quot;</span>));</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> <span class="keyword">final</span> =</div><div class="line">        async_future.then([](future&lt;google::cloud::StatusOr&lt;cbt::Row&gt;&gt; f) {</div><div class="line">          <span class="keyword">auto</span> row = f.get();</div><div class="line">          <span class="keywordflow">if</span> (!row) {</div><div class="line">            <span class="keywordflow">throw</span> std::runtime_error(row.status().message());</div><div class="line">          }</div><div class="line">        });</div><div class="line"></div><div class="line">    <span class="keyword">final</span>.get();</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00600">600</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a6468a7850ecf45a3dbc633b0bffdd134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6468a7850ecf45a3dbc633b0bffdd134">&#9670;&nbsp;</a></span>BulkApply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1FailedMutation.html">FailedMutation</a> &gt; google::cloud::bigtable::v0::Table::BulkApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1BulkMutation.html">BulkMutation</a>&#160;</td>
          <td class="paramname"><em>mut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to apply mutations to multiple rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mut</td><td>the mutations, note that this function takes ownership (and then discards) the data in the mutation. In general, a <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1BulkMutation.html" title="Represent a set of mutations across multiple rows. ">BulkMutation</a></code> can modify multiple rows, and the modifications for each row can change (or create) multiple cells, across different columns and column families.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is idempotent if the provided mutations are idempotent. Note that <code><a class="el" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18" title="Create a mutation to set a cell value. ">google::cloud::bigtable::SetCell()</a></code> without an explicit timestamp is <b>not</b> an idempotent operation.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::Table table) {</div><div class="line">    <span class="comment">// Write several rows in a single operation, each row has some trivial data.</span></div><div class="line">    cbt::BulkMutation bulk;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != 5000; ++i) {</div><div class="line">      <span class="comment">// Note: This example uses sequential numeric IDs for simplicity, but</span></div><div class="line">      <span class="comment">// this can result in poor performance in a production application.</span></div><div class="line">      <span class="comment">// Since rows are stored in sorted order by key, sequential keys can</span></div><div class="line">      <span class="comment">// result in poor distribution of operations across nodes.</span></div><div class="line">      <span class="comment">//</span></div><div class="line">      <span class="comment">// For more information about how to design a Bigtable schema for the</span></div><div class="line">      <span class="comment">// best performance, see the documentation:</span></div><div class="line">      <span class="comment">//</span></div><div class="line">      <span class="comment">//     https://cloud.google.com/bigtable/docs/schema-design</span></div><div class="line">      <span class="keywordtype">char</span> buf[32];</div><div class="line">      snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class="stringliteral">&quot;key-%06d&quot;</span>, i);</div><div class="line">      cbt::SingleRowMutation mutation(buf);</div><div class="line">      mutation.emplace_back(</div><div class="line">          <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col0&quot;</span>, <span class="stringliteral">&quot;value0-&quot;</span> + std::to_string(i)));</div><div class="line">      mutation.emplace_back(</div><div class="line">          <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col1&quot;</span>, <span class="stringliteral">&quot;value1-&quot;</span> + std::to_string(i)));</div><div class="line">      bulk.emplace_back(std::move(mutation));</div><div class="line">    }</div><div class="line">    std::vector&lt;cbt::FailedMutation&gt; failures =</div><div class="line">        table.BulkApply(std::move(bulk));</div><div class="line">    <span class="keywordflow">if</span> (failures.empty()) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;All mutations applied successfully\n&quot;</span>;</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;The following mutations failed:\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; f : failures) {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;index[&quot;</span> &lt;&lt; f.original_index() &lt;&lt; <span class="stringliteral">&quot;]=&quot;</span> &lt;&lt; f.status() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">throw</span> std::runtime_error(failures.front().status().message());</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8cc_source.html#l00110">110</a> of file <a class="el" href="table_8cc_source.html">table.cc</a>.</p>

</div>
</div>
<a id="a888246f28cc27ddd3d43c51c59ed29b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888246f28cc27ddd3d43c51c59ed29b9">&#9670;&nbsp;</a></span>CheckAndMutateRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; bool &gt; google::cloud::bigtable::v0::Table::CheckAndMutateRow </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>row_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Filter.html">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Mutation.html">Mutation</a> &gt;&#160;</td>
          <td class="paramname"><em>true_mutations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Mutation.html">Mutation</a> &gt;&#160;</td>
          <td class="paramname"><em>false_mutations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic test-and-set for a row using filter expressions. </p>
<p>Atomically check the value of a row using a filter expression. If the expression passes (meaning at least one element is returned by it), one set of mutations is applied. If the filter does not pass, a different set of mutations is applied. The changes are atomically applied in the server.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_key</td><td>the row to modify. </td></tr>
    <tr><td class="paramname">filter</td><td>the filter expression. </td></tr>
    <tr><td class="paramname">true_mutations</td><td>the mutations for the "filter passed" case. </td></tr>
    <tr><td class="paramname">false_mutations</td><td>the mutations for the "filter did not pass" case. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the filter passed.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Check for Value Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::Table table, std::string row_key) {</div><div class="line">    <span class="comment">// Check if the latest value of the flip-flop column is &quot;on&quot;.</span></div><div class="line">    cbt::Filter predicate = cbt::Filter::Chain(</div><div class="line">        cbt::Filter::ColumnRangeClosed(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flip-flop&quot;</span>, <span class="stringliteral">&quot;flip-flop&quot;</span>),</div><div class="line">        cbt::Filter::Latest(1), cbt::Filter::ValueRegex(<span class="stringliteral">&quot;on&quot;</span>));</div><div class="line">    <span class="comment">// If the predicate matches, change the latest value to &quot;off&quot;, otherwise,</span></div><div class="line">    <span class="comment">// change the latest value to &quot;on&quot;.  Modify the &quot;flop-flip&quot; column at the</span></div><div class="line">    <span class="comment">// same time.</span></div><div class="line">    StatusOr&lt;bool&gt; branch =</div><div class="line">        table.CheckAndMutateRow(row_key, std::move(predicate),</div><div class="line">                                {<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flip-flop&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>),</div><div class="line">                                 <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flop-flip&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>)},</div><div class="line">                                {<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flip-flop&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>),</div><div class="line">                                 <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;flop-flip&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>)});</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!branch) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(branch.status().message());</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;The predicate &quot;</span> &lt;&lt; (*branch ? <span class="stringliteral">&quot;was&quot;</span> : <span class="stringliteral">&quot;was not&quot;</span>)</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; matched\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Check for Cell Presence Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::Table table, std::string row_key) {</div><div class="line">    <span class="comment">// Check if the latest value of the &quot;test-column&quot; column is present,</span></div><div class="line">    <span class="comment">// regardless of its value.</span></div><div class="line">    cbt::Filter predicate = cbt::Filter::Chain(</div><div class="line">        cbt::Filter::ColumnRangeClosed(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;test-column&quot;</span>, <span class="stringliteral">&quot;test-column&quot;</span>),</div><div class="line">        cbt::Filter::Latest(1));</div><div class="line">    <span class="comment">// If the predicate matches, do nothing, otherwise set the</span></div><div class="line">    <span class="comment">// &quot;had-test-column&quot; to &quot;false&quot;:</span></div><div class="line">    StatusOr&lt;bool&gt; branch = table.CheckAndMutateRow(</div><div class="line">        row_key, std::move(predicate), {},</div><div class="line">        {<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a24adeb58de68ffc7a792f42b8391ce18">cbt::SetCell</a>(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;had-test-column&quot;</span>, <span class="stringliteral">&quot;false&quot;</span>)});</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!branch) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(branch.status().message());</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;The CheckAndMutateRow() predicate &quot;</span></div><div class="line">              &lt;&lt; (*branch ? <span class="stringliteral">&quot;was&quot;</span> : <span class="stringliteral">&quot;was not&quot;</span>) &lt;&lt; <span class="stringliteral">&quot; matched\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8cc_source.html#l00191">191</a> of file <a class="el" href="table_8cc_source.html">table.cc</a>.</p>

</div>
</div>
<a id="a3592cbd3b3bb163c04b7a586bf0b0d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3592cbd3b3bb163c04b7a586bf0b0d8e">&#9670;&nbsp;</a></span>instance_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string const&amp; google::cloud::bigtable::v0::Table::instance_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00286">286</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a44b5d612b5ef1ee0e178dfb388fe8d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b5d612b5ef1ee0e178dfb388fe8d56">&#9670;&nbsp;</a></span>project_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string const&amp; google::cloud::bigtable::v0::Table::project_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00285">285</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="afd4ddd0053141ed279da2bbeba76b06b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4ddd0053141ed279da2bbeba76b06b">&#9670;&nbsp;</a></span>ReadModifyWriteRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt;<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Row.html">Row</a>&gt; google::cloud::bigtable::v0::Table::ReadModifyWriteRow </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>row_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::ReadModifyWriteRule&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rules</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically read and modify the row in the server, returning the resulting row. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>this is zero or more ReadModifyWriteRules to apply on a row </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_key</td><td>the row to read </td></tr>
    <tr><td class="paramname">rule</td><td>to modify the row. Two types of rules are applied here AppendValue which will read the existing value and append the text provided to the value. IncrementAmount which will read the existing uint64 big-endian-int and add the value provided. Both rules accept the family and column identifier to modify. </td></tr>
    <tr><td class="paramname">rules</td><td>is the zero or more ReadModifyWriteRules to apply on a row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new contents of all modified cells.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::Table table, std::string row_key) {</div><div class="line">    StatusOr&lt;cbt::Row&gt; row = table.ReadModifyWriteRow(</div><div class="line">        row_key, cbt::ReadModifyWriteRule::IncrementAmount(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;counter&quot;</span>, 1),</div><div class="line">        cbt::ReadModifyWriteRule::AppendValue(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;list&quot;</span>, <span class="stringliteral">&quot;;element&quot;</span>));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!row) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(row.status().message());</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; row-&gt;row_key() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00550">550</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="ac3eb95924778b80d60ebc9ead2036650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3eb95924778b80d60ebc9ead2036650">&#9670;&nbsp;</a></span>ReadRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; std::pair&lt; bool, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Row.html">Row</a> &gt; &gt; google::cloud::bigtable::v0::Table::ReadRow </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>row_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Filter.html">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and return a single row from the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_key</td><td>the row to read. </td></tr>
    <tr><td class="paramname">filter</td><td>a filter expression, can be used to select a subset of the column families and columns in the row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple, the first element is a boolean, with value <code>false</code> if the row does not exist. If the first element is <code>true</code> the second element has the contents of the <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Row.html" title="The in-memory representation of a Bigtable row. ">Row</a>. Note that the contents may be empty if the filter expression removes all column families and columns.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This is a read-only operation and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](google::cloud::bigtable::Table table, std::string row_key) {</div><div class="line">    <span class="comment">// Filter the results, only include the latest value on each cell.</span></div><div class="line">    cbt::Filter filter = cbt::Filter::Latest(1);</div><div class="line">    <span class="comment">// Read a row, this returns a tuple (bool, row)</span></div><div class="line">    StatusOr&lt;std::pair&lt;bool, cbt::Row&gt;&gt; tuple =</div><div class="line">        table.ReadRow(row_key, std::move(filter));</div><div class="line">    <span class="keywordflow">if</span> (!tuple) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(tuple.status().message());</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (!tuple-&gt;first) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Row &quot;</span> &lt;&lt; row_key &lt;&lt; <span class="stringliteral">&quot; not found\n&quot;</span>;</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;key: &quot;</span> &lt;&lt; tuple-&gt;second.row_key() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; cell : tuple-&gt;second.cells()) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; cell.family_name() &lt;&lt; <span class="stringliteral">&quot;:&quot;</span></div><div class="line">                &lt;&lt; cell.column_qualifier() &lt;&lt; <span class="stringliteral">&quot; = &lt;&quot;</span>;</div><div class="line">      <span class="keywordflow">if</span> (cell.column_qualifier() == <span class="stringliteral">&quot;counter&quot;</span>) {</div><div class="line">        <span class="comment">// This example uses &quot;counter&quot; to store 64-bit numbers in big-endian</span></div><div class="line">        <span class="comment">// format, extract them as follows:</span></div><div class="line">        std::cout &lt;&lt; cell.decode_big_endian_integer&lt;std::int64_t&gt;().value();</div><div class="line">      } <span class="keywordflow">else</span> {</div><div class="line">        std::cout &lt;&lt; cell.value();</div><div class="line">      }</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;&gt;\n&quot;</span>;</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8cc_source.html#l00169">169</a> of file <a class="el" href="table_8cc_source.html">table.cc</a>.</p>

</div>
</div>
<a id="a07fd0b3bc5b4fc17db8e3f099aaf9c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07fd0b3bc5b4fc17db8e3f099aaf9c33">&#9670;&nbsp;</a></span>ReadRows() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RowReader.html">RowReader</a> google::cloud::bigtable::v0::Table::ReadRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RowSet.html">RowSet</a>&#160;</td>
          <td class="paramname"><em>row_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Filter.html">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a set of rows from the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_set</td><td>the rows to read from. </td></tr>
    <tr><td class="paramname">filter</td><td>is applied on the server-side to data in the rows.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Idempotency</dt><dd>This is a read-only operation and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::Table table) {</div><div class="line">    <span class="comment">// Create the range of rows to read.</span></div><div class="line">    <span class="keyword">auto</span> range = cbt::RowRange::Range(<span class="stringliteral">&quot;key-000010&quot;</span>, <span class="stringliteral">&quot;key-000020&quot;</span>);</div><div class="line">    <span class="comment">// Filter the results, only include values from the &quot;col0&quot; column in the</span></div><div class="line">    <span class="comment">// &quot;fam&quot; column family, and only get the latest value.</span></div><div class="line">    cbt::Filter filter = cbt::Filter::Chain(</div><div class="line">        cbt::Filter::ColumnRangeClosed(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col0&quot;</span>, <span class="stringliteral">&quot;col0&quot;</span>),</div><div class="line">        cbt::Filter::Latest(1));</div><div class="line">    <span class="comment">// Read and print the rows.</span></div><div class="line">    <span class="keywordflow">for</span> (StatusOr&lt;cbt::Row&gt; <span class="keyword">const</span>&amp; row : table.ReadRows(range, filter)) {</div><div class="line">      <span class="keywordflow">if</span> (!row) {</div><div class="line">        <span class="keywordflow">throw</span> std::runtime_error(row.status().message());</div><div class="line">      }</div><div class="line">      <span class="keywordflow">if</span> (row-&gt;cells().size() != 1) {</div><div class="line">        std::ostringstream os;</div><div class="line">        os &lt;&lt; <span class="stringliteral">&quot;Unexpected number of cells in &quot;</span> &lt;&lt; row-&gt;row_key();</div><div class="line">        <span class="keywordflow">throw</span> std::runtime_error(os.str());</div><div class="line">      }</div><div class="line">      <span class="keyword">auto</span> <span class="keyword">const</span>&amp; cell = row-&gt;cells().at(0);</div><div class="line">      std::cout &lt;&lt; cell.row_key() &lt;&lt; <span class="stringliteral">&quot; = [&quot;</span> &lt;&lt; cell.value() &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8cc_source.html#l00148">148</a> of file <a class="el" href="table_8cc_source.html">table.cc</a>.</p>

</div>
</div>
<a id="a95295dc0c3dd50603926b6038160a071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95295dc0c3dd50603926b6038160a071">&#9670;&nbsp;</a></span>ReadRows() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RowReader.html">RowReader</a> google::cloud::bigtable::v0::Table::ReadRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RowSet.html">RowSet</a>&#160;</td>
          <td class="paramname"><em>row_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>rows_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Filter.html">Filter</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a limited set of rows from the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_set</td><td>the rows to read from. </td></tr>
    <tr><td class="paramname">rows_limit</td><td>the maximum number of rows to read. Cannot be a negative number or zero. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1Table.html#a07fd0b3bc5b4fc17db8e3f099aaf9c33" title="Reads a set of rows from the table. ">ReadRows(RowSet, Filter)</a></code> to read all matching rows. </td></tr>
    <tr><td class="paramname">filter</td><td>is applied on the server-side to data in the rows.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Idempotency</dt><dd>This is a read-only operation and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::Table table) {</div><div class="line">    <span class="comment">// Create the range of rows to read.</span></div><div class="line">    <span class="keyword">auto</span> range = cbt::RowRange::Range(<span class="stringliteral">&quot;key-000010&quot;</span>, <span class="stringliteral">&quot;key-000020&quot;</span>);</div><div class="line">    <span class="comment">// Filter the results, only include values from the &quot;col0&quot; column in the</span></div><div class="line">    <span class="comment">// &quot;fam&quot; column family, and only get the latest value.</span></div><div class="line">    cbt::Filter filter = cbt::Filter::Chain(</div><div class="line">        cbt::Filter::ColumnRangeClosed(<span class="stringliteral">&quot;fam&quot;</span>, <span class="stringliteral">&quot;col0&quot;</span>, <span class="stringliteral">&quot;col0&quot;</span>),</div><div class="line">        cbt::Filter::Latest(1));</div><div class="line">    <span class="comment">// Read and print the first 5 rows in the range.</span></div><div class="line">    <span class="keywordflow">for</span> (StatusOr&lt;cbt::Row&gt; <span class="keyword">const</span>&amp; row : table.ReadRows(range, 5, filter)) {</div><div class="line">      <span class="keywordflow">if</span> (!row) {</div><div class="line">        <span class="keywordflow">throw</span> std::runtime_error(row.status().message());</div><div class="line">      }</div><div class="line">      <span class="keywordflow">if</span> (row-&gt;cells().size() != 1) {</div><div class="line">        std::ostringstream os;</div><div class="line">        os &lt;&lt; <span class="stringliteral">&quot;Unexpected number of cells in &quot;</span> &lt;&lt; row-&gt;row_key();</div><div class="line">        <span class="keywordflow">throw</span> std::runtime_error(os.str());</div><div class="line">      }</div><div class="line">      <span class="keyword">auto</span> <span class="keyword">const</span>&amp; cell = row-&gt;cells().at(0);</div><div class="line">      std::cout &lt;&lt; cell.row_key() &lt;&lt; <span class="stringliteral">&quot; = [&quot;</span> &lt;&lt; cell.value() &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8cc_source.html#l00158">158</a> of file <a class="el" href="table_8cc_source.html">table.cc</a>.</p>

</div>
</div>
<a id="aba7acffbcf43365528cde61d159e7a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba7acffbcf43365528cde61d159e7a99">&#9670;&nbsp;</a></span>SampleRows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename... &gt; class Collection = std::vector&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt;Collection&lt;bigtable::RowKeySample&gt; &gt; google::cloud::bigtable::v0::Table::SampleRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sample of the row keys in the table, including approximate data sizes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Collection</td><td>the type of collection where the samples are returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Note that the sample may only include one element for small tables. In addition, the sample may include row keys that do not exist on the table, and may include the empty row key to indicate "end of table".</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::Table table) {</div><div class="line">    StatusOr&lt;std::vector&lt;cbt::RowKeySample&gt;&gt; samples = table.SampleRows&lt;&gt;();</div><div class="line">    <span class="keywordflow">if</span> (!samples) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(samples.status().message());</div><div class="line">    }</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; sample : *samples) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;key=&quot;</span> &lt;&lt; sample.row_key &lt;&lt; <span class="stringliteral">&quot; - &quot;</span> &lt;&lt; sample.offset_bytes</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --> In addition, application developers can specify other collection types, for example <code>std::list&lt;&gt;</code> or <code>std::deque&lt;&gt;</code>: <div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::Table table) {</div><div class="line">    StatusOr&lt;std::list&lt;cbt::RowKeySample&gt;&gt; list_samples =</div><div class="line">        table.SampleRows&lt;std::list&gt;();</div><div class="line">    <span class="keywordflow">if</span> (!list_samples) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(list_samples.status().message());</div><div class="line">    }</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; sample : *list_samples) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;key=&quot;</span> &lt;&lt; sample.row_key &lt;&lt; <span class="stringliteral">&quot; - &quot;</span> &lt;&lt; sample.offset_bytes</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">auto</span> deque_samples = table.SampleRows&lt;std::deque&gt;();</div><div class="line">    <span class="keywordflow">if</span> (!deque_samples) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(deque_samples.status().message());</div><div class="line">    }</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; sample : *deque_samples) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;key=&quot;</span> &lt;&lt; sample.row_key &lt;&lt; <span class="stringliteral">&quot; - &quot;</span> &lt;&lt; sample.offset_bytes</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00511">511</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a6a9474603a38e1398a9946cdf530413f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9474603a38e1398a9946cdf530413f">&#9670;&nbsp;</a></span>table_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string const&amp; google::cloud::bigtable::v0::Table::table_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00289">289</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a1a84118bf4f098d5a4785b586484ab14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a84118bf4f098d5a4785b586484ab14">&#9670;&nbsp;</a></span>table_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string const&amp; google::cloud::bigtable::v0::Table::table_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00283">283</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a26c8f6be2070a3f5d8c01acabb3ad719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c8f6be2070a3f5d8c01acabb3ad719">&#9670;&nbsp;</a></span>MutationBatcher</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1MutationBatcher.html">MutationBatcher</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00662">662</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
