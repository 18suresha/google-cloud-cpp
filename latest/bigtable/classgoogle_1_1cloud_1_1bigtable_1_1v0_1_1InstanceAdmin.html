<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google Cloud Bigtable C++ Client: google::cloud::bigtable::v0::InstanceAdmin Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Google Cloud Bigtable C++ Client
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
   <div id="projectbrief">A C++ Client Library for Google Cloud Bigtable</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegoogle.html">google</a></li><li class="navelem"><a class="el" href="namespacegoogle_1_1cloud.html">cloud</a></li><li class="navelem"><a class="el" href="namespacegoogle_1_1cloud_1_1bigtable.html">bigtable</a></li><li class="navelem"><a class="el" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html">v0</a></li><li class="navelem"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html">InstanceAdmin</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">google::cloud::bigtable::v0::InstanceAdmin Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements the APIs to administer Cloud Bigtable instances.  
 <a href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="instance__admin_8h_source.html">google/cloud/bigtable/instance_admin.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af1131dad1833304ae0586de8a2fcd1dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#af1131dad1833304ae0586de8a2fcd1dd">InstanceAdmin</a> (std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdminClient.html">InstanceAdminClient</a> &gt; client)</td></tr>
<tr class="separator:af1131dad1833304ae0586de8a2fcd1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade73f858cc14f0f06c77dcbc07426f3e"><td class="memTemplParams" colspan="2">template&lt;typename... Policies&gt; </td></tr>
<tr class="memitem:ade73f858cc14f0f06c77dcbc07426f3e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#ade73f858cc14f0f06c77dcbc07426f3e">InstanceAdmin</a> (std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdminClient.html">InstanceAdminClient</a> &gt; client, Policies &amp;&amp;... policies)</td></tr>
<tr class="memdesc:ade73f858cc14f0f06c77dcbc07426f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html" title="Implements the APIs to administer Cloud Bigtable instances. ">InstanceAdmin</a> using explicit policies to handle RPC errors.  <a href="#ade73f858cc14f0f06c77dcbc07426f3e">More...</a><br /></td></tr>
<tr class="separator:ade73f858cc14f0f06c77dcbc07426f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d9a1591c24ab2521a9e6f8d29af18e"><td class="memItemLeft" align="right" valign="top">std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a62d9a1591c24ab2521a9e6f8d29af18e">project_name</a> () const</td></tr>
<tr class="memdesc:a62d9a1591c24ab2521a9e6f8d29af18e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The full name (<code>projects/&lt;project_id&gt;</code>) of the project.  <a href="#a62d9a1591c24ab2521a9e6f8d29af18e">More...</a><br /></td></tr>
<tr class="separator:a62d9a1591c24ab2521a9e6f8d29af18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21477780db4f5268667ab89cb8df235e"><td class="memItemLeft" align="right" valign="top">std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a21477780db4f5268667ab89cb8df235e">project_id</a> () const</td></tr>
<tr class="memdesc:a21477780db4f5268667ab89cb8df235e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The project id, i.e., <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a62d9a1591c24ab2521a9e6f8d29af18e" title="The full name (projects/&lt;project_id&gt;) of the project. ">project_name()</a></code> without the <code>projects/</code> prefix.  <a href="#a21477780db4f5268667ab89cb8df235e">More...</a><br /></td></tr>
<tr class="separator:a21477780db4f5268667ab89cb8df235e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d5dd94a1c3414bdbad5ee9f217022a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a13d5dd94a1c3414bdbad5ee9f217022a">InstanceName</a> (std::string const &amp;instance_id) const</td></tr>
<tr class="memdesc:a13d5dd94a1c3414bdbad5ee9f217022a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fully qualified name of the given instance_id.  <a href="#a13d5dd94a1c3414bdbad5ee9f217022a">More...</a><br /></td></tr>
<tr class="separator:a13d5dd94a1c3414bdbad5ee9f217022a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a70eb6e950e9ef8c2d2089438f67d5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a36a70eb6e950e9ef8c2d2089438f67d5">ClusterName</a> (bigtable::InstanceId const &amp;instance_id, bigtable::ClusterId const &amp;cluster_id) const</td></tr>
<tr class="memdesc:a36a70eb6e950e9ef8c2d2089438f67d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fully qualified name of the given cluster_id in give instance_id.  <a href="#a36a70eb6e950e9ef8c2d2089438f67d5">More...</a><br /></td></tr>
<tr class="separator:a36a70eb6e950e9ef8c2d2089438f67d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642849986a3e8c67b160d4e654d9a999"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::Instance &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a642849986a3e8c67b160d4e654d9a999">CreateInstance</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceConfig.html">InstanceConfig</a> instance_config)</td></tr>
<tr class="memdesc:a642849986a3e8c67b160d4e654d9a999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of Cloud Bigtable.  <a href="#a642849986a3e8c67b160d4e654d9a999">More...</a><br /></td></tr>
<tr class="separator:a642849986a3e8c67b160d4e654d9a999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa08fcb1eb7e520da38ebeb7da740188"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::Instance &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#afa08fcb1eb7e520da38ebeb7da740188">AsyncCreateInstance</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;cq, bigtable::InstanceConfig instance_config)</td></tr>
<tr class="memdesc:afa08fcb1eb7e520da38ebeb7da740188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an instance (asynchronously).  <a href="#afa08fcb1eb7e520da38ebeb7da740188">More...</a><br /></td></tr>
<tr class="separator:afa08fcb1eb7e520da38ebeb7da740188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ff5a065242ca9b552049b9b1a0e0b3"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::Cluster &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a20ff5a065242ca9b552049b9b1a0e0b3">CreateCluster</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ClusterConfig.html">ClusterConfig</a> cluster_config, bigtable::InstanceId const &amp;instance_id, bigtable::ClusterId const &amp;cluster_id)</td></tr>
<tr class="memdesc:a20ff5a065242ca9b552049b9b1a0e0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Cluster of Cloud Bigtable.  <a href="#a20ff5a065242ca9b552049b9b1a0e0b3">More...</a><br /></td></tr>
<tr class="separator:a20ff5a065242ca9b552049b9b1a0e0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fb60218e36596f5553cfb73714ecd5"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::Cluster &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a46fb60218e36596f5553cfb73714ecd5">AsyncCreateCluster</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;cq, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ClusterConfig.html">ClusterConfig</a> cluster_config, bigtable::InstanceId const &amp;instance_id, bigtable::ClusterId const &amp;cluster_id)</td></tr>
<tr class="memdesc:a46fb60218e36596f5553cfb73714ecd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new cluster (asynchronously).  <a href="#a46fb60218e36596f5553cfb73714ecd5">More...</a><br /></td></tr>
<tr class="separator:a46fb60218e36596f5553cfb73714ecd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e23515ae533a95e5d07f60057cbaf1"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::Instance &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#aa6e23515ae533a95e5d07f60057cbaf1">UpdateInstance</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceUpdateConfig.html">InstanceUpdateConfig</a> instance_update_config)</td></tr>
<tr class="memdesc:aa6e23515ae533a95e5d07f60057cbaf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update an existing instance of Cloud Bigtable.  <a href="#aa6e23515ae533a95e5d07f60057cbaf1">More...</a><br /></td></tr>
<tr class="separator:aa6e23515ae533a95e5d07f60057cbaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6717c2cd7a77ff60a2e8b904a776d014"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::Instance &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a6717c2cd7a77ff60a2e8b904a776d014">AsyncUpdateInstance</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;cq, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceUpdateConfig.html">InstanceUpdateConfig</a> instance_update_config)</td></tr>
<tr class="memdesc:a6717c2cd7a77ff60a2e8b904a776d014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update an existing instance (asynchronously).  <a href="#a6717c2cd7a77ff60a2e8b904a776d014">More...</a><br /></td></tr>
<tr class="separator:a6717c2cd7a77ff60a2e8b904a776d014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560bc7eb9bbdc92d8afda323e0922a74"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceList.html">InstanceList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a560bc7eb9bbdc92d8afda323e0922a74">ListInstances</a> ()</td></tr>
<tr class="memdesc:a560bc7eb9bbdc92d8afda323e0922a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the list of instances in the project.  <a href="#a560bc7eb9bbdc92d8afda323e0922a74">More...</a><br /></td></tr>
<tr class="separator:a560bc7eb9bbdc92d8afda323e0922a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eed97625526b0effc3fc0d4812b4134"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceList.html">InstanceList</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a5eed97625526b0effc3fc0d4812b4134">AsyncListInstances</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;cq)</td></tr>
<tr class="memdesc:a5eed97625526b0effc3fc0d4812b4134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query (asynchronously) the list of instances in the project.  <a href="#a5eed97625526b0effc3fc0d4812b4134">More...</a><br /></td></tr>
<tr class="separator:a5eed97625526b0effc3fc0d4812b4134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d5daa968557296320a8251bb0ae1ec"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; google::bigtable::admin::v2::Instance &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a55d5daa968557296320a8251bb0ae1ec">GetInstance</a> (std::string const &amp;instance_id)</td></tr>
<tr class="memdesc:a55d5daa968557296320a8251bb0ae1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the details of <code>instance_id</code>.  <a href="#a55d5daa968557296320a8251bb0ae1ec">More...</a><br /></td></tr>
<tr class="separator:a55d5daa968557296320a8251bb0ae1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654a2aae76b64c4e7c34b3692f08ed03"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::Instance &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a654a2aae76b64c4e7c34b3692f08ed03">AsyncGetInstance</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;cq, std::string const &amp;instance_id)</td></tr>
<tr class="memdesc:a654a2aae76b64c4e7c34b3692f08ed03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an asynchronous request to get information about an existing instance.  <a href="#a654a2aae76b64c4e7c34b3692f08ed03">More...</a><br /></td></tr>
<tr class="separator:a654a2aae76b64c4e7c34b3692f08ed03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7de1ee5392dfccc006218f0abb83118"><td class="memItemLeft" align="right" valign="top">Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#ab7de1ee5392dfccc006218f0abb83118">DeleteInstance</a> (std::string const &amp;instance_id)</td></tr>
<tr class="memdesc:ab7de1ee5392dfccc006218f0abb83118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the instances in the project.  <a href="#ab7de1ee5392dfccc006218f0abb83118">More...</a><br /></td></tr>
<tr class="separator:ab7de1ee5392dfccc006218f0abb83118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f65c2587cdd9c747efe677c1b9c30a8"><td class="memItemLeft" align="right" valign="top">future&lt; Status &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a7f65c2587cdd9c747efe677c1b9c30a8">AsyncDeleteInstance</a> (std::string const &amp;instance_id, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;cq)</td></tr>
<tr class="memdesc:a7f65c2587cdd9c747efe677c1b9c30a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an asynchronous request to delete an instance.  <a href="#a7f65c2587cdd9c747efe677c1b9c30a8">More...</a><br /></td></tr>
<tr class="separator:a7f65c2587cdd9c747efe677c1b9c30a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bc59bb5c428a77bfd34c5a0a39b1e2"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ClusterList.html">ClusterList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a92bc59bb5c428a77bfd34c5a0a39b1e2">ListClusters</a> ()</td></tr>
<tr class="memdesc:a92bc59bb5c428a77bfd34c5a0a39b1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the list of clusters in an instance.  <a href="#a92bc59bb5c428a77bfd34c5a0a39b1e2">More...</a><br /></td></tr>
<tr class="separator:a92bc59bb5c428a77bfd34c5a0a39b1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fad2de97c492b7f37f957a043967cae"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ClusterList.html">ClusterList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a4fad2de97c492b7f37f957a043967cae">ListClusters</a> (std::string const &amp;instance_id)</td></tr>
<tr class="memdesc:a4fad2de97c492b7f37f957a043967cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the list of clusters in an instance.  <a href="#a4fad2de97c492b7f37f957a043967cae">More...</a><br /></td></tr>
<tr class="separator:a4fad2de97c492b7f37f957a043967cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ec26e92178da8dfc5f880fc1762896"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ClusterList.html">ClusterList</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#ab6ec26e92178da8dfc5f880fc1762896">AsyncListClusters</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;cq)</td></tr>
<tr class="memdesc:ab6ec26e92178da8dfc5f880fc1762896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query (asynchronously) the list of clusters in a project.  <a href="#ab6ec26e92178da8dfc5f880fc1762896">More...</a><br /></td></tr>
<tr class="separator:ab6ec26e92178da8dfc5f880fc1762896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84fbe8f84a51b9e8e2c24df1fdd36fc"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ClusterList.html">ClusterList</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#ac84fbe8f84a51b9e8e2c24df1fdd36fc">AsyncListClusters</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;cq, std::string const &amp;instance_id)</td></tr>
<tr class="memdesc:ac84fbe8f84a51b9e8e2c24df1fdd36fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query (asynchronously) the list of clusters in an instance.  <a href="#ac84fbe8f84a51b9e8e2c24df1fdd36fc">More...</a><br /></td></tr>
<tr class="separator:ac84fbe8f84a51b9e8e2c24df1fdd36fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd851711d3d5dce20cc195e9cd1c4bcf"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::Cluster &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#abd851711d3d5dce20cc195e9cd1c4bcf">UpdateCluster</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ClusterConfig.html">ClusterConfig</a> cluster_config)</td></tr>
<tr class="memdesc:abd851711d3d5dce20cc195e9cd1c4bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update an existing cluster of Cloud Bigtable.  <a href="#abd851711d3d5dce20cc195e9cd1c4bcf">More...</a><br /></td></tr>
<tr class="separator:abd851711d3d5dce20cc195e9cd1c4bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284fcf3a539d1c3e7100880ce5da3c24"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::Cluster &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a284fcf3a539d1c3e7100880ce5da3c24">AsyncUpdateCluster</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;cq, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ClusterConfig.html">ClusterConfig</a> cluster_config)</td></tr>
<tr class="memdesc:a284fcf3a539d1c3e7100880ce5da3c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update an existing cluster (asynchronously).  <a href="#a284fcf3a539d1c3e7100880ce5da3c24">More...</a><br /></td></tr>
<tr class="separator:a284fcf3a539d1c3e7100880ce5da3c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911a3dfc283d37ec580797ce126b2bc4"><td class="memItemLeft" align="right" valign="top">Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a911a3dfc283d37ec580797ce126b2bc4">DeleteCluster</a> (bigtable::InstanceId const &amp;instance_id, bigtable::ClusterId const &amp;cluster_id)</td></tr>
<tr class="memdesc:a911a3dfc283d37ec580797ce126b2bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the specified cluster of an instance in the project.  <a href="#a911a3dfc283d37ec580797ce126b2bc4">More...</a><br /></td></tr>
<tr class="separator:a911a3dfc283d37ec580797ce126b2bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2792b02dc9e5ea482b2e0d60dd427991"><td class="memItemLeft" align="right" valign="top">future&lt; Status &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a2792b02dc9e5ea482b2e0d60dd427991">AsyncDeleteCluster</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;cq, bigtable::InstanceId const &amp;instance_id, bigtable::ClusterId const &amp;cluster_id)</td></tr>
<tr class="memdesc:a2792b02dc9e5ea482b2e0d60dd427991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an asynchronous request to delete a cluster.  <a href="#a2792b02dc9e5ea482b2e0d60dd427991">More...</a><br /></td></tr>
<tr class="separator:a2792b02dc9e5ea482b2e0d60dd427991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad023404fcf897a265e2cdf3e7671bef5"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; google::bigtable::admin::v2::Cluster &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#ad023404fcf897a265e2cdf3e7671bef5">GetCluster</a> (bigtable::InstanceId const &amp;instance_id, bigtable::ClusterId const &amp;cluster_id)</td></tr>
<tr class="memdesc:ad023404fcf897a265e2cdf3e7671bef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the specified cluster of an instance in the project.  <a href="#ad023404fcf897a265e2cdf3e7671bef5">More...</a><br /></td></tr>
<tr class="separator:ad023404fcf897a265e2cdf3e7671bef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4022a3a4cd2b98fdbfc4dbf762b31f2b"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::Cluster &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a4022a3a4cd2b98fdbfc4dbf762b31f2b">AsyncGetCluster</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;cq, bigtable::InstanceId const &amp;instance_id, bigtable::ClusterId const &amp;cluster_id)</td></tr>
<tr class="memdesc:a4022a3a4cd2b98fdbfc4dbf762b31f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an asynchronous request to get information about existing cluster of an instance.  <a href="#a4022a3a4cd2b98fdbfc4dbf762b31f2b">More...</a><br /></td></tr>
<tr class="separator:a4022a3a4cd2b98fdbfc4dbf762b31f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c14a6464a0ec9d547c2911f685d000"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; google::bigtable::admin::v2::AppProfile &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a54c14a6464a0ec9d547c2911f685d000">CreateAppProfile</a> (bigtable::InstanceId const &amp;instance_id, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1AppProfileConfig.html">AppProfileConfig</a> config)</td></tr>
<tr class="memdesc:a54c14a6464a0ec9d547c2911f685d000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new application profile.  <a href="#a54c14a6464a0ec9d547c2911f685d000">More...</a><br /></td></tr>
<tr class="separator:a54c14a6464a0ec9d547c2911f685d000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c450db912e938f9f86cf9cbf1208a6"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::AppProfile &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a95c450db912e938f9f86cf9cbf1208a6">AsyncCreateAppProfile</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;cq, bigtable::InstanceId const &amp;instance_id, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1AppProfileConfig.html">AppProfileConfig</a> config)</td></tr>
<tr class="memdesc:a95c450db912e938f9f86cf9cbf1208a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously create a new application profile.  <a href="#a95c450db912e938f9f86cf9cbf1208a6">More...</a><br /></td></tr>
<tr class="separator:a95c450db912e938f9f86cf9cbf1208a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76865c687f2cadc808c39e3c7334abc9"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; google::bigtable::admin::v2::AppProfile &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a76865c687f2cadc808c39e3c7334abc9">GetAppProfile</a> (bigtable::InstanceId const &amp;instance_id, bigtable::AppProfileId const &amp;profile_id)</td></tr>
<tr class="memdesc:a76865c687f2cadc808c39e3c7334abc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the detailed information about an existing application profile.  <a href="#a76865c687f2cadc808c39e3c7334abc9">More...</a><br /></td></tr>
<tr class="separator:a76865c687f2cadc808c39e3c7334abc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d38adcbbf2da4b175bb82a3b41fe38"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::AppProfile &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a59d38adcbbf2da4b175bb82a3b41fe38">AsyncGetAppProfile</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;cq, bigtable::InstanceId const &amp;instance_id, bigtable::AppProfileId const &amp;profile_id)</td></tr>
<tr class="memdesc:a59d38adcbbf2da4b175bb82a3b41fe38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously fetch the information about an existing application profile.  <a href="#a59d38adcbbf2da4b175bb82a3b41fe38">More...</a><br /></td></tr>
<tr class="separator:a59d38adcbbf2da4b175bb82a3b41fe38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384aaa94d541751ff796856f98f14b7a"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::AppProfile &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a384aaa94d541751ff796856f98f14b7a">UpdateAppProfile</a> (bigtable::InstanceId instance_id, bigtable::AppProfileId profile_id, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1AppProfileUpdateConfig.html">AppProfileUpdateConfig</a> config)</td></tr>
<tr class="memdesc:a384aaa94d541751ff796856f98f14b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new application profile.  <a href="#a384aaa94d541751ff796856f98f14b7a">More...</a><br /></td></tr>
<tr class="separator:a384aaa94d541751ff796856f98f14b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044403c787f39b775d56e4fedb8f1193"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::AppProfile &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a044403c787f39b775d56e4fedb8f1193">AsyncUpdateAppProfile</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;cq, bigtable::InstanceId instance_id, bigtable::AppProfileId profile_id, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1AppProfileUpdateConfig.html">AppProfileUpdateConfig</a> config)</td></tr>
<tr class="memdesc:a044403c787f39b775d56e4fedb8f1193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update an application profile (asynchronously).  <a href="#a044403c787f39b775d56e4fedb8f1193">More...</a><br /></td></tr>
<tr class="separator:a044403c787f39b775d56e4fedb8f1193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43273851a72529657b74cf80e464d85a"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; std::vector&lt; google::bigtable::admin::v2::AppProfile &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a43273851a72529657b74cf80e464d85a">ListAppProfiles</a> (std::string const &amp;instance_id)</td></tr>
<tr class="memdesc:a43273851a72529657b74cf80e464d85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">List the application profiles in an instance.  <a href="#a43273851a72529657b74cf80e464d85a">More...</a><br /></td></tr>
<tr class="separator:a43273851a72529657b74cf80e464d85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667f2c625e015a35f88399acfec23950"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; std::vector&lt; google::bigtable::admin::v2::AppProfile &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a667f2c625e015a35f88399acfec23950">AsyncListAppProfiles</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;cq, std::string const &amp;instance_id)</td></tr>
<tr class="memdesc:a667f2c625e015a35f88399acfec23950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query (asynchronously) the list of app profiles in an instance.  <a href="#a667f2c625e015a35f88399acfec23950">More...</a><br /></td></tr>
<tr class="separator:a667f2c625e015a35f88399acfec23950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc4bffa110e02adc20b601a5b2f6538"><td class="memItemLeft" align="right" valign="top">Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a6bc4bffa110e02adc20b601a5b2f6538">DeleteAppProfile</a> (bigtable::InstanceId const &amp;instance_id, bigtable::AppProfileId const &amp;profile_id, bool ignore_warnings=false)</td></tr>
<tr class="memdesc:a6bc4bffa110e02adc20b601a5b2f6538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an existing application profile.  <a href="#a6bc4bffa110e02adc20b601a5b2f6538">More...</a><br /></td></tr>
<tr class="separator:a6bc4bffa110e02adc20b601a5b2f6538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c54a91e0fc70432d136bfcecc33716f"><td class="memItemLeft" align="right" valign="top">future&lt; Status &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a5c54a91e0fc70432d136bfcecc33716f">AsyncDeleteAppProfile</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;cq, bigtable::InstanceId const &amp;instance_id, bigtable::AppProfileId const &amp;profile_id, bool ignore_warnings=false)</td></tr>
<tr class="memdesc:a5c54a91e0fc70432d136bfcecc33716f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously delete an existing application profile.  <a href="#a5c54a91e0fc70432d136bfcecc33716f">More...</a><br /></td></tr>
<tr class="separator:a5c54a91e0fc70432d136bfcecc33716f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb556f62cbb7b71cf036e5d00c830f9"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; google::cloud::IamPolicy &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a1cb556f62cbb7b71cf036e5d00c830f9">GetIamPolicy</a> (std::string const &amp;instance_id)</td></tr>
<tr class="memdesc:a1cb556f62cbb7b71cf036e5d00c830f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the policy for <code>instance_id</code>.  <a href="#a1cb556f62cbb7b71cf036e5d00c830f9">More...</a><br /></td></tr>
<tr class="separator:a1cb556f62cbb7b71cf036e5d00c830f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2aaa7cc2b1704825c187a80567234fa"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::cloud::IamPolicy &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#aa2aaa7cc2b1704825c187a80567234fa">AsyncGetIamPolicy</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;cq, <a class="el" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">InstanceId</a> const &amp;instance_id)</td></tr>
<tr class="memdesc:aa2aaa7cc2b1704825c187a80567234fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the policy for <code>instance_id</code>.  <a href="#aa2aaa7cc2b1704825c187a80567234fa">More...</a><br /></td></tr>
<tr class="separator:aa2aaa7cc2b1704825c187a80567234fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7709527acc7b0827a9e9d372bcfa25"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; google::cloud::IamPolicy &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a1e7709527acc7b0827a9e9d372bcfa25">SetIamPolicy</a> (std::string const &amp;instance_id, google::cloud::IamBindings const &amp;iam_bindings, std::string const &amp;etag=std::string{})</td></tr>
<tr class="memdesc:a1e7709527acc7b0827a9e9d372bcfa25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the IAM policy for an instance.  <a href="#a1e7709527acc7b0827a9e9d372bcfa25">More...</a><br /></td></tr>
<tr class="separator:a1e7709527acc7b0827a9e9d372bcfa25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628efb6a49363fa8fa4a34ebdd2d4ada"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a628efb6a49363fa8fa4a34ebdd2d4ada">TestIamPermissions</a> (std::string const &amp;instance_id, std::vector&lt; std::string &gt; const &amp;permissions)</td></tr>
<tr class="memdesc:a628efb6a49363fa8fa4a34ebdd2d4ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a permission set that the caller has on the specified instance.  <a href="#a628efb6a49363fa8fa4a34ebdd2d4ada">More...</a><br /></td></tr>
<tr class="separator:a628efb6a49363fa8fa4a34ebdd2d4ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7420b7cb337cde52f0a94ae7977c926"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; std::vector&lt; std::string &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#ab7420b7cb337cde52f0a94ae7977c926">AsyncTestIamPermissions</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;cq, std::string const &amp;instance_id, std::vector&lt; std::string &gt; const &amp;permissions)</td></tr>
<tr class="memdesc:ab7420b7cb337cde52f0a94ae7977c926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously obtains a permission set that the caller has on the specified instance.  <a href="#ab7420b7cb337cde52f0a94ae7977c926">More...</a><br /></td></tr>
<tr class="separator:ab7420b7cb337cde52f0a94ae7977c926"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements the APIs to administer Cloud Bigtable instances. </p>
<dl class="section user"><dt>Cost</dt><dd>Creating a new object of type <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html" title="Implements the APIs to administer Cloud Bigtable instances. ">InstanceAdmin</a></code> is comparable to creating a few objects of type <code>std::string</code> or a few objects of type <code>std::shared_ptr&lt;int&gt;</code>. The class represents a shallow handle to a remote object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8h_source.html#l00043">43</a> of file <a class="el" href="instance__admin_8h_source.html">instance_admin.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af1131dad1833304ae0586de8a2fcd1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1131dad1833304ae0586de8a2fcd1dd">&#9670;&nbsp;</a></span>InstanceAdmin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::cloud::bigtable::v0::InstanceAdmin::InstanceAdmin </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdminClient.html">InstanceAdminClient</a> &gt;&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>the interface to create grpc stubs, report errors, etc. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8h_source.html#l00048">48</a> of file <a class="el" href="instance__admin_8h_source.html">instance_admin.h</a>.</p>

</div>
</div>
<a id="ade73f858cc14f0f06c77dcbc07426f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade73f858cc14f0f06c77dcbc07426f3e">&#9670;&nbsp;</a></span>InstanceAdmin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Policies&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::cloud::bigtable::v0::InstanceAdmin::InstanceAdmin </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdminClient.html">InstanceAdminClient</a> &gt;&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Policies &amp;&amp;...&#160;</td>
          <td class="paramname"><em>policies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html" title="Implements the APIs to administer Cloud Bigtable instances. ">InstanceAdmin</a> using explicit policies to handle RPC errors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>the interface to create grpc stubs, report errors, etc. </td></tr>
    <tr><td class="paramname">policies</td><td>the set of policy overrides for this object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Policies</td><td>the types of the policies to override, the types must derive from one of the following types:<ul>
<li><code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RPCBackoffPolicy.html" title="Define the interface for controlling how the Bigtable client backsoff from failed RPC operations...">RPCBackoffPolicy</a></code> how to backoff from a failed RPC. Currently only <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ExponentialBackoffPolicy.html" title="Implement a simple exponential backoff policy. ">ExponentialBackoffPolicy</a></code> is implemented. You can also create your own policies that backoff using a different algorithm.</li>
<li><code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1RPCRetryPolicy.html" title="Define the interface for controlling how the Bigtable client retries RPC operations. ">RPCRetryPolicy</a></code> for how long to retry failed RPCs. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1LimitedErrorCountRetryPolicy.html" title="Implement a simple &quot;count errors and then stop&quot; retry policy. ">LimitedErrorCountRetryPolicy</a></code> to limit the number of failures allowed. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1LimitedTimeRetryPolicy.html" title="Implement a simple &quot;keep trying for this time&quot; retry policy. ">LimitedTimeRetryPolicy</a></code> to bound the time for any request. You can also create your own policies that combine time and error counts.</li>
<li><code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1PollingPolicy.html" title="Define the interface for providing asynchronous repetitive call rules. ">PollingPolicy</a></code> for how long will the class wait for <code>google.longrunning.Operation</code> to complete. This class combines both the backoff policy for checking long running operations and the retry policy.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1GenericPollingPolicy.html">GenericPollingPolicy</a>, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ExponentialBackoffPolicy.html" title="Implement a simple exponential backoff policy. ">ExponentialBackoffPolicy</a>, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1LimitedErrorCountRetryPolicy.html" title="Implement a simple &quot;count errors and then stop&quot; retry policy. ">LimitedErrorCountRetryPolicy</a>, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1LimitedTimeRetryPolicy.html" title="Implement a simple &quot;keep trying for this time&quot; retry policy. ">LimitedTimeRetryPolicy</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8h_source.html#l00075">75</a> of file <a class="el" href="instance__admin_8h_source.html">instance_admin.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a95c450db912e938f9f86cf9cbf1208a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c450db912e938f9f86cf9cbf1208a6">&#9670;&nbsp;</a></span>AsyncCreateAppProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; google::bigtable::admin::v2::AppProfile &gt; &gt; google::cloud::bigtable::v0::InstanceAdmin::AsyncCreateAppProfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::InstanceId const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1AppProfileConfig.html">AppProfileConfig</a>&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously create a new application profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_id</td><td>the instance for the new application profile. </td></tr>
    <tr><td class="paramname">config</td><td>the configuration for the new application profile. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The proto describing the new application profile.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string instance_id, std::string profile_id) {</div><div class="line">    <span class="keyword">auto</span> config = cbt::AppProfileConfig::MultiClusterUseAny(</div><div class="line">        <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a412d4ff7e63afde75faebcbd07be0d4a">cbt::AppProfileId</a>(profile_id));</div><div class="line">    <span class="keyword">auto</span> future = instance_admin.AsyncCreateAppProfile(</div><div class="line">        cq, <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">cbt::InstanceId</a>(instance_id), config);</div><div class="line"></div><div class="line">    <span class="comment">// Most applications would simply call future.get(), here we show how to</span></div><div class="line">    <span class="comment">// perform additional work while the long running operation completes.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Waiting for app_profile creation to complete &quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != 100; ++i) {</div><div class="line">      <span class="keywordflow">if</span> (std::future_status::ready ==</div><div class="line">          future.wait_for(std::chrono::seconds(2))) {</div><div class="line">        <span class="keyword">auto</span> app_profile = future.get();</div><div class="line">        <span class="keywordflow">if</span> (!app_profile) {</div><div class="line">          <span class="keywordflow">throw</span> std::runtime_error(app_profile.status().message());</div><div class="line">        }</div><div class="line">        std::string app_profile_detail;</div><div class="line">        google::protobuf::TextFormat::PrintToString(*app_profile,</div><div class="line">                                                    &amp;app_profile_detail);</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;DONE, app profile details: &quot;</span> &lt;&lt; app_profile_detail</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">      }</div><div class="line">      std::cout &lt;&lt; <span class="charliteral">&#39;.&#39;</span> &lt;&lt; std::flush;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;TIMEOUT\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00546">546</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a46fb60218e36596f5553cfb73714ecd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46fb60218e36596f5553cfb73714ecd5">&#9670;&nbsp;</a></span>AsyncCreateCluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; google::bigtable::admin::v2::Cluster &gt; &gt; google::cloud::bigtable::v0::InstanceAdmin::AsyncCreateCluster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ClusterConfig.html">ClusterConfig</a>&#160;</td>
          <td class="paramname"><em>cluster_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::InstanceId const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::ClusterId const &amp;&#160;</td>
          <td class="paramname"><em>cluster_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new cluster (asynchronously). </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">cluster_config</td><td>a description of the new cluster to be created. </td></tr>
    <tr><td class="paramname">instance_id</td><td>the id of the instance in the project </td></tr>
    <tr><td class="paramname">cluster_id</td><td>the id of the cluster in the project that needs to be created. It must be between 6 and 30 characters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future satisfied when either (a) the cluster is created or (b) an unretriable error occurs or (c) polling or retry policy has been exhausted.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string instance_id, std::string cluster_id, std::string zone) {</div><div class="line">    <span class="keyword">auto</span> cluster_config = cbt::ClusterConfig(zone, 3, cbt::ClusterConfig::HDD);</div><div class="line">    <span class="keyword">auto</span> future = instance_admin.AsyncCreateCluster(</div><div class="line">        cq, cluster_config, <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">cbt::InstanceId</a>(instance_id),</div><div class="line">        <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a73d20496d86761052e55848775b1e30b">cbt::ClusterId</a>(cluster_id));</div><div class="line">    <span class="comment">// Most applications would simply call future.get(), here we show how to</span></div><div class="line">    <span class="comment">// perform additional work while the long running operation completes.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Waiting for cluster creation to complete &quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != 100; ++i) {</div><div class="line">      <span class="keywordflow">if</span> (std::future_status::ready ==</div><div class="line">          future.wait_for(std::chrono::seconds(2))) {</div><div class="line">        <span class="keyword">auto</span> cluster = future.get();</div><div class="line">        <span class="keywordflow">if</span> (!cluster) {</div><div class="line">          <span class="keywordflow">throw</span> std::runtime_error(cluster.status().message());</div><div class="line">        }</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;DONE: &quot;</span> &lt;&lt; cluster-&gt;name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">      }</div><div class="line">      std::cout &lt;&lt; <span class="charliteral">&#39;.&#39;</span> &lt;&lt; std::flush;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;TIMEOUT\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00179">179</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="afa08fcb1eb7e520da38ebeb7da740188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa08fcb1eb7e520da38ebeb7da740188">&#9670;&nbsp;</a></span>AsyncCreateInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; google::bigtable::admin::v2::Instance &gt; &gt; google::cloud::bigtable::v0::InstanceAdmin::AsyncCreateInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::InstanceConfig&#160;</td>
          <td class="paramname"><em>instance_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an instance (asynchronously). </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_config</td><td>the desired configuration of the instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future satisfied when either (a) the cluster is created or (b) an unretriable error occurs or (c) polling or retry policy has been exhausted.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string instance_id, std::string zone) {</div><div class="line">    <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aeb2a52a19595444371d7dc12350d3f63">cbt::DisplayName</a> display_name(<span class="stringliteral">&quot;Put description here&quot;</span>);</div><div class="line">    std::string cluster_id = instance_id + <span class="stringliteral">&quot;-c1&quot;</span>;</div><div class="line">    <span class="keyword">auto</span> cluster_config = cbt::ClusterConfig(zone, 3, cbt::ClusterConfig::HDD);</div><div class="line">    cbt::InstanceConfig config(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">cbt::InstanceId</a>(instance_id), display_name,</div><div class="line">                               {{cluster_id, cluster_config}});</div><div class="line">    config.set_type(cbt::InstanceConfig::PRODUCTION);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> future = instance_admin.AsyncCreateInstance(cq, config);</div><div class="line">    <span class="comment">// Most applications would simply call future.get(), here we show how to</span></div><div class="line">    <span class="comment">// perform additional work while the long running operation completes.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Waiting for instance creation to complete &quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != 100; ++i) {</div><div class="line">      <span class="keywordflow">if</span> (std::future_status::ready ==</div><div class="line">          future.wait_for(std::chrono::seconds(2))) {</div><div class="line">        <span class="keyword">auto</span> instance = future.get();</div><div class="line">        <span class="keywordflow">if</span> (!instance) {</div><div class="line">          <span class="keywordflow">throw</span> std::runtime_error(instance.status().message());</div><div class="line">        }</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;DONE: &quot;</span> &lt;&lt; instance-&gt;name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">      }</div><div class="line">      std::cout &lt;&lt; <span class="charliteral">&#39;.&#39;</span> &lt;&lt; std::flush;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;TIMEOUT\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00140">140</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a5c54a91e0fc70432d136bfcecc33716f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c54a91e0fc70432d136bfcecc33716f">&#9670;&nbsp;</a></span>AsyncDeleteAppProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; Status &gt; google::cloud::bigtable::v0::InstanceAdmin::AsyncDeleteAppProfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::InstanceId const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::AppProfileId const &amp;&#160;</td>
          <td class="paramname"><em>profile_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_warnings</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously delete an existing application profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_id</td><td>the instance to look the profile in. </td></tr>
    <tr><td class="paramname">profile_id</td><td>the id of the profile within that instance. </td></tr>
    <tr><td class="paramname">ignore_warnings</td><td>if true, ignore safety checks when deleting the application profile.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future satisfied when either (a) the app profile is deleted or (b) an unretriable error occurs or (c) retry policy has been exhausted.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string instance_id, std::string app_profile_id) {</div><div class="line">    google::cloud::future&lt;google::cloud::Status&gt; future =</div><div class="line">        instance_admin.AsyncDeleteAppProfile(cq, <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">cbt::InstanceId</a>(instance_id),</div><div class="line">                                             <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a412d4ff7e63afde75faebcbd07be0d4a">cbt::AppProfileId</a>(app_profile_id));</div><div class="line"></div><div class="line">    <span class="comment">// Most applications would simply call future.get(), here we show how to</span></div><div class="line">    <span class="comment">// perform additional work while the long running operation completes.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Waiting for app profile deletion to complete &quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != 100; ++i) {</div><div class="line">      <span class="keywordflow">if</span> (std::future_status::ready ==</div><div class="line">          future.wait_for(std::chrono::seconds(2))) {</div><div class="line">        <span class="keyword">auto</span> res = future.get();</div><div class="line">        <span class="keywordflow">if</span> (!res.ok()) {</div><div class="line">          <span class="keywordflow">throw</span> std::runtime_error(res.message());</div><div class="line">        }</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;DONE, app profile deleted.\n&quot;</span>;</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">      }</div><div class="line">      std::cout &lt;&lt; <span class="charliteral">&#39;.&#39;</span> &lt;&lt; std::flush;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;TIMEOUT\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00720">720</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a2792b02dc9e5ea482b2e0d60dd427991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2792b02dc9e5ea482b2e0d60dd427991">&#9670;&nbsp;</a></span>AsyncDeleteCluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; Status &gt; google::cloud::bigtable::v0::InstanceAdmin::AsyncDeleteCluster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::InstanceId const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::ClusterId const &amp;&#160;</td>
          <td class="paramname"><em>cluster_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends an asynchronous request to delete a cluster. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_id</td><td>the id of the instance in the project. </td></tr>
    <tr><td class="paramname">cluster_id</td><td>the id of the cluster in the project that needs to be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future that will be satisfied when the request succeeds or the retry policy expires.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string instance_id, std::string cluster_id) {</div><div class="line">    google::cloud::future&lt;google::cloud::Status&gt; future =</div><div class="line">        instance_admin.AsyncDeleteCluster(cq, <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">cbt::InstanceId</a>(instance_id),</div><div class="line">                                          <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a73d20496d86761052e55848775b1e30b">cbt::ClusterId</a>(cluster_id));</div><div class="line"></div><div class="line">    <span class="comment">// Most applications would simply call future.get(), here we show how to</span></div><div class="line">    <span class="comment">// perform additional work while the long running operation completes.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Waiting for cluster deletion to complete &quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != 100; ++i) {</div><div class="line">      <span class="keywordflow">if</span> (std::future_status::ready ==</div><div class="line">          future.wait_for(std::chrono::seconds(2))) {</div><div class="line">        <span class="keyword">auto</span> res = future.get();</div><div class="line">        <span class="keywordflow">if</span> (!res.ok()) {</div><div class="line">          <span class="keywordflow">throw</span> std::runtime_error(res.message());</div><div class="line">        }</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;DONE, cluster deleted.\n&quot;</span>;</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">      }</div><div class="line">      std::cout &lt;&lt; <span class="charliteral">&#39;.&#39;</span> &lt;&lt; std::flush;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;TIMEOUT\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00291">291</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a7f65c2587cdd9c747efe677c1b9c30a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f65c2587cdd9c747efe677c1b9c30a8">&#9670;&nbsp;</a></span>AsyncDeleteInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; Status &gt; google::cloud::bigtable::v0::InstanceAdmin::AsyncDeleteInstance </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes an asynchronous request to delete an instance. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the id of the instance in the project to be deleted. </td></tr>
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string instance_id) {</div><div class="line">    google::cloud::future&lt;google::cloud::Status&gt; fut =</div><div class="line">        instance_admin.AsyncDeleteInstance(instance_id, cq);</div><div class="line"></div><div class="line">    google::cloud::Status status = fut.get();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; status.message() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!status.ok()) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(status.message());</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; Done\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00317">317</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a59d38adcbbf2da4b175bb82a3b41fe38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d38adcbbf2da4b175bb82a3b41fe38">&#9670;&nbsp;</a></span>AsyncGetAppProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; google::bigtable::admin::v2::AppProfile &gt; &gt; google::cloud::bigtable::v0::InstanceAdmin::AsyncGetAppProfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::InstanceId const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::AppProfileId const &amp;&#160;</td>
          <td class="paramname"><em>profile_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously fetch the information about an existing application profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_id</td><td>the instance to look the profile in. </td></tr>
    <tr><td class="paramname">profile_id</td><td>the id of the profile within that instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future satisfied when either (a) the profile is fetched or (b) an unretriable error occurs or (c) retry policy has been exhausted.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string instance_id, std::string app_profile_id) {</div><div class="line">    <span class="keyword">auto</span> <span class="keyword">final</span> =</div><div class="line">        instance_admin</div><div class="line">            .AsyncGetAppProfile(cq, <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">cbt::InstanceId</a>(instance_id),</div><div class="line">                                <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a412d4ff7e63afde75faebcbd07be0d4a">cbt::AppProfileId</a>(app_profile_id))</div><div class="line">            .then([](google::cloud::future&lt;</div><div class="line">                      StatusOr&lt;google::bigtable::admin::v2::AppProfile&gt;&gt;</div><div class="line">                         f) {</div><div class="line">              <span class="keyword">auto</span> app_profile = f.get();</div><div class="line">              <span class="keywordflow">if</span> (!app_profile) {</div><div class="line">                <span class="keywordflow">throw</span> std::runtime_error(app_profile.status().message());</div><div class="line">              }</div><div class="line">              std::string app_profile_detail;</div><div class="line">              google::protobuf::TextFormat::PrintToString(*app_profile,</div><div class="line">                                                          &amp;app_profile_detail);</div><div class="line">              std::cout &lt;&lt; <span class="stringliteral">&quot;GetAppProfile details : &quot;</span> &lt;&lt; app_profile_detail</div><div class="line">                        &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">              <span class="keywordflow">return</span> google::cloud::Status();</div><div class="line">            });</div><div class="line"></div><div class="line">    <span class="keyword">final</span>.get();</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00586">586</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a4022a3a4cd2b98fdbfc4dbf762b31f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4022a3a4cd2b98fdbfc4dbf762b31f2b">&#9670;&nbsp;</a></span>AsyncGetCluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; btadmin::Cluster &gt; &gt; google::cloud::bigtable::v0::InstanceAdmin::AsyncGetCluster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::InstanceId const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::ClusterId const &amp;&#160;</td>
          <td class="paramname"><em>cluster_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends an asynchronous request to get information about existing cluster of an instance. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the id of the instance in the project. </td></tr>
    <tr><td class="paramname">cluster_id</td><td>the id of the cluster in the project that needs to be retrieved. </td></tr>
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future that will be satisfied when the request succeeds or the retry policy expires. In the first case, the future will contain the response from the service. In the second the future is satisfied with an exception.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the operation cannot be started.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string instance_id, std::string cluster_id) {</div><div class="line">    <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">cbt::InstanceId</a> instance_id1(instance_id);</div><div class="line">    <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a73d20496d86761052e55848775b1e30b">cbt::ClusterId</a> cluster_id1(cluster_id);</div><div class="line"></div><div class="line">    google::cloud::future&lt;</div><div class="line">        google::cloud::StatusOr&lt;google::bigtable::admin::v2::Cluster&gt;&gt;</div><div class="line">        future = instance_admin.AsyncGetCluster(cq, instance_id1, cluster_id1);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> <span class="keyword">final</span> = future.then(</div><div class="line">        [](google::cloud::future&lt;</div><div class="line">            google::cloud::StatusOr&lt;google::bigtable::admin::v2::Cluster&gt;&gt;</div><div class="line">               f) {</div><div class="line">          <span class="keyword">auto</span> cluster = f.get();</div><div class="line">          <span class="keywordflow">if</span> (!cluster) {</div><div class="line">            <span class="keywordflow">throw</span> std::runtime_error(cluster.status().message());</div><div class="line">          }</div><div class="line">          std::string cluster_detail;</div><div class="line">          google::protobuf::TextFormat::PrintToString(*cluster,</div><div class="line">                                                      &amp;cluster_detail);</div><div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot;GetCluster details : &quot;</span> &lt;&lt; cluster_detail &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">          <span class="keywordflow">return</span> google::cloud::Status();</div><div class="line">        });</div><div class="line"></div><div class="line">    <span class="keyword">final</span>.get();</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00360">360</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="aa2aaa7cc2b1704825c187a80567234fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2aaa7cc2b1704825c187a80567234fa">&#9670;&nbsp;</a></span>AsyncGetIamPolicy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; google::cloud::IamPolicy &gt; &gt; google::cloud::bigtable::v0::InstanceAdmin::AsyncGetIamPolicy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">InstanceId</a> const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously gets the policy for <code>instance_id</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_id</td><td>the instance to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future satisfied when either (a) the policy is fetched or (b) an unretriable error occurs or (c) retry policy has been exhausted.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string instance_id) {</div><div class="line">    google::cloud::future&lt;StatusOr&lt;google::cloud::IamPolicy&gt;&gt; future =</div><div class="line">        instance_admin.AsyncGetIamPolicy(cq, <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">cbt::InstanceId</a>(instance_id));</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> <span class="keyword">final</span> = future.then(</div><div class="line">        [](google::cloud::future&lt;StatusOr&lt;google::cloud::IamPolicy&gt;&gt; f) {</div><div class="line">          <span class="keyword">auto</span> iam_policy = f.get();</div><div class="line">          <span class="keywordflow">if</span> (!iam_policy) {</div><div class="line">            <span class="keywordflow">throw</span> std::runtime_error(iam_policy.status().message());</div><div class="line">          }</div><div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot;IamPolicy details : &quot;</span> &lt;&lt; *iam_policy &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">          <span class="keywordflow">return</span> google::cloud::Status();</div><div class="line">        });</div><div class="line"></div><div class="line">    <span class="keyword">final</span>.get();</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00772">772</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a654a2aae76b64c4e7c34b3692f08ed03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654a2aae76b64c4e7c34b3692f08ed03">&#9670;&nbsp;</a></span>AsyncGetInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; btadmin::Instance &gt; &gt; google::cloud::bigtable::v0::InstanceAdmin::AsyncGetInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends an asynchronous request to get information about an existing instance. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the id of the instance in the project that to be retrieved. </td></tr>
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future that will be satisfied when the request succeeds or the retry policy expires. In the first case, the future will contain the response from the service. In the second the future is satisfied with an exception.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the operation cannot be started.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string instance_id) {</div><div class="line">    google::cloud::future&lt;</div><div class="line">        google::cloud::StatusOr&lt;google::bigtable::admin::v2::Instance&gt;&gt;</div><div class="line">        future = instance_admin.AsyncGetInstance(cq, instance_id);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> <span class="keyword">final</span> = future.then(</div><div class="line">        [](google::cloud::future&lt;</div><div class="line">            google::cloud::StatusOr&lt;google::bigtable::admin::v2::Instance&gt;&gt;</div><div class="line">               f) {</div><div class="line">          <span class="keyword">auto</span> instance = f.get();</div><div class="line">          <span class="keywordflow">if</span> (!instance) {</div><div class="line">            <span class="keywordflow">throw</span> std::runtime_error(instance.status().message());</div><div class="line">          }</div><div class="line">          std::string instance_detail;</div><div class="line">          google::protobuf::TextFormat::PrintToString(*instance,</div><div class="line">                                                      &amp;instance_detail);</div><div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot;GetInstance details : &quot;</span> &lt;&lt; instance_detail &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">          <span class="keywordflow">return</span> google::cloud::Status();</div><div class="line">        });</div><div class="line"></div><div class="line">    <span class="keyword">final</span>.get();</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00260">260</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a667f2c625e015a35f88399acfec23950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667f2c625e015a35f88399acfec23950">&#9670;&nbsp;</a></span>AsyncListAppProfiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; std::vector&lt; btadmin::AppProfile &gt; &gt; &gt; google::cloud::bigtable::v0::InstanceAdmin::AsyncListAppProfiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query (asynchronously) the list of app profiles in an instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_id</td><td>the instance in a project. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of app profiles.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string instance_id) {</div><div class="line">    <span class="keyword">auto</span> cluster_list = instance_admin.ListClusters(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!cluster_list) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(cluster_list.status().message());</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Cluster Name List\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; cluster : cluster_list-&gt;clusters) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Cluster Name:&quot;</span> &lt;&lt; cluster.name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (!cluster_list-&gt;failed_locations.empty()) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;The Cloud Bigtable service reports that the following &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;locations are temporarily unavailable and no information &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;about clusters in these locations can be obtained:\n&quot;</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; failed_location : cluster_list-&gt;failed_locations) {</div><div class="line">        std::cout &lt;&lt; failed_location &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00679">679</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="ab6ec26e92178da8dfc5f880fc1762896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ec26e92178da8dfc5f880fc1762896">&#9670;&nbsp;</a></span>AsyncListClusters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ClusterList.html">ClusterList</a> &gt; &gt; google::cloud::bigtable::v0::InstanceAdmin::AsyncListClusters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query (asynchronously) the list of clusters in a project. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In some circumstances Cloud Bigtable may be unable to obtain the full list of clusters, typically because some transient failure has made specific zones unavailable. In this cases the service returns a separate list of <code>failed_locations</code> that represent the unavailable zones. Applications may want to retry the operation after the transient conditions have cleared.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of clusters. It is possible that some zones are not currently available for querying. In that case this function returns the list of failed locations in the <code>projects/&lt;project&gt;/locations/&lt;zone_id&gt;</code> format.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string instance_id) {</div><div class="line">    <span class="keyword">auto</span> cluster_list = instance_admin.ListClusters(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!cluster_list) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(cluster_list.status().message());</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Cluster Name List\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; cluster : cluster_list-&gt;clusters) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Cluster Name:&quot;</span> &lt;&lt; cluster.name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (!cluster_list-&gt;failed_locations.empty()) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;The Cloud Bigtable service reports that the following &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;locations are temporarily unavailable and no information &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;about clusters in these locations can be obtained:\n&quot;</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; failed_location : cluster_list-&gt;failed_locations) {</div><div class="line">        std::cout &lt;&lt; failed_location &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00428">428</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="ac84fbe8f84a51b9e8e2c24df1fdd36fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84fbe8f84a51b9e8e2c24df1fdd36fc">&#9670;&nbsp;</a></span>AsyncListClusters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ClusterList.html">ClusterList</a> &gt; &gt; google::cloud::bigtable::v0::InstanceAdmin::AsyncListClusters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query (asynchronously) the list of clusters in an instance. </p>
<dl class="section note"><dt>Note</dt><dd>In some circumstances Cloud Bigtable may be unable to obtain the full list of clusters, typically because some transient failure has made specific zones unavailable. In this cases the service returns a separate list of <code>failed_locations</code> that represent the unavailable zones. Applications may want to retry the operation after the transient conditions have cleared.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_id</td><td>the instance in a project. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of clusters. It is possible that some zones are not currently available for querying. In that case this function returns the list of failed locations in the <code>projects/&lt;project&gt;/locations/&lt;zone_id&gt;</code> format.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string instance_id) {</div><div class="line">    <span class="keyword">auto</span> cluster_list = instance_admin.ListClusters(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!cluster_list) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(cluster_list.status().message());</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Cluster Name List\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; cluster : cluster_list-&gt;clusters) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Cluster Name:&quot;</span> &lt;&lt; cluster.name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (!cluster_list-&gt;failed_locations.empty()) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;The Cloud Bigtable service reports that the following &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;locations are temporarily unavailable and no information &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;about clusters in these locations can be obtained:\n&quot;</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; failed_location : cluster_list-&gt;failed_locations) {</div><div class="line">        std::cout &lt;&lt; failed_location &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00433">433</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a5eed97625526b0effc3fc0d4812b4134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eed97625526b0effc3fc0d4812b4134">&#9670;&nbsp;</a></span>AsyncListInstances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceList.html">InstanceList</a> &gt; &gt; google::cloud::bigtable::v0::InstanceAdmin::AsyncListInstances </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query (asynchronously) the list of instances in the project. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In some circumstances Cloud Bigtable may be unable to obtain the full list of instances, typically because some transient failure has made specific zones unavailable. In this cases the service returns a separate list of <code>failed_locations</code> that represent the unavailable zones. Applications may want to retry the operation after the transient conditions have cleared.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of instances. It is possible that some zones are not currently available for querying. In that case this function returns the list of failed locations in the <code>projects/&lt;project&gt;/locations/&lt;zone_id&gt;</code> format.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq) {</div><div class="line">    google::cloud::future&lt;google::cloud::StatusOr&lt;cbt::InstanceList&gt;&gt; future =</div><div class="line">        instance_admin.AsyncListInstances(cq);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> <span class="keyword">final</span> = future.then(</div><div class="line">        [](google::cloud::future&lt;google::cloud::StatusOr&lt;cbt::InstanceList&gt;&gt;</div><div class="line">               f) {</div><div class="line">          <span class="keyword">auto</span> instance_list = f.get();</div><div class="line">          <span class="keywordflow">if</span> (!instance_list) {</div><div class="line">            <span class="keywordflow">throw</span> std::runtime_error(instance_list.status().message());</div><div class="line">          }</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; instance : instance_list-&gt;instances) {</div><div class="line">            std::cout &lt;&lt; instance.name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">          }</div><div class="line">          <span class="keywordflow">if</span> (!instance_list-&gt;failed_locations.empty()) {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;The Cloud Bigtable service reports that it could not &quot;</span></div><div class="line">                         <span class="stringliteral">&quot;retrieve data for the following zones:\n&quot;</span>;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; failed_location :</div><div class="line">                 instance_list-&gt;failed_locations) {</div><div class="line">              std::cout &lt;&lt; failed_location &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">            }</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;This is typically a transient condition, try again &quot;</span></div><div class="line">                         <span class="stringliteral">&quot;later.\n&quot;</span>;</div><div class="line">          }</div><div class="line">          <span class="keywordflow">return</span> google::cloud::Status();</div><div class="line">        });</div><div class="line">    <span class="keyword">final</span>.get();</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00080">80</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="ab7420b7cb337cde52f0a94ae7977c926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7420b7cb337cde52f0a94ae7977c926">&#9670;&nbsp;</a></span>AsyncTestIamPermissions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; std::vector&lt; std::string &gt; &gt; &gt; google::cloud::bigtable::v0::InstanceAdmin::AsyncTestIamPermissions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>permissions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously obtains a permission set that the caller has on the specified instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_id</td><td>the ID of the instance to query. </td></tr>
    <tr><td class="paramname">permissions</td><td>set of permissions to check for the resource.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string resource, std::vector&lt;std::string&gt;(permissions)) {</div><div class="line">    <span class="keyword">auto</span> future =</div><div class="line">        instance_admin.AsyncTestIamPermissions(cq, resource, permissions);</div><div class="line">    <span class="comment">// Most applications would simply call future.get(), here we show how to</span></div><div class="line">    <span class="comment">// perform additional work while the long running operation completes.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Waiting for app profile update to complete &quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != 100; ++i) {</div><div class="line">      <span class="keywordflow">if</span> (std::future_status::ready ==</div><div class="line">          future.wait_for(std::chrono::seconds(2))) {</div><div class="line">        <span class="keyword">auto</span> result = future.get();</div><div class="line">        <span class="keywordflow">if</span> (!result) {</div><div class="line">          <span class="keywordflow">throw</span> std::runtime_error(result.status().message());</div><div class="line">        }</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;DONE, the current user has the following permissions [&quot;</span>;</div><div class="line">        <span class="keywordtype">char</span> <span class="keyword">const</span>* sep = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; p : *result) {</div><div class="line">          std::cout &lt;&lt; sep &lt;&lt; p;</div><div class="line">          sep = <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">        }</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">      }</div><div class="line">      std::cout &lt;&lt; <span class="charliteral">&#39;.&#39;</span> &lt;&lt; std::flush;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;TIMEOUT\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://cloud.google.com/bigtable/docs/access-control">https://cloud.google.com/bigtable/docs/access-control</a> for a list of valid permissions on Google Cloud Bigtable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00872">872</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a044403c787f39b775d56e4fedb8f1193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044403c787f39b775d56e4fedb8f1193">&#9670;&nbsp;</a></span>AsyncUpdateAppProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; google::bigtable::admin::v2::AppProfile &gt; &gt; google::cloud::bigtable::v0::InstanceAdmin::AsyncUpdateAppProfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::InstanceId&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::AppProfileId&#160;</td>
          <td class="paramname"><em>profile_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1AppProfileUpdateConfig.html">AppProfileUpdateConfig</a>&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update an application profile (asynchronously). </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_id</td><td>the instance for the new application profile. </td></tr>
    <tr><td class="paramname">profile_id</td><td>the id (not the full name) of the profile to update. </td></tr>
    <tr><td class="paramname">config</td><td>the configuration for the new application profile.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future satisfied when either (a) the profile is updated or (b) an unretriable error occurs or (c) polling or retry policy has been exhausted.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string instance_id, std::string profile_id) {</div><div class="line">    <span class="keyword">auto</span> future = instance_admin.AsyncUpdateAppProfile(</div><div class="line">        cq, <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">cbt::InstanceId</a>(instance_id), <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a412d4ff7e63afde75faebcbd07be0d4a">cbt::AppProfileId</a>(profile_id),</div><div class="line">        cbt::AppProfileUpdateConfig().set_description(<span class="stringliteral">&quot;new description&quot;</span>));</div><div class="line">    <span class="comment">// Most applications would simply call future.get(), here we show how to</span></div><div class="line">    <span class="comment">// perform additional work while the long running operation completes.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Waiting for app profile update to complete &quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != 100; ++i) {</div><div class="line">      <span class="keywordflow">if</span> (std::future_status::ready ==</div><div class="line">          future.wait_for(std::chrono::seconds(2))) {</div><div class="line">        <span class="keyword">auto</span> app_profile = future.get();</div><div class="line">        <span class="keywordflow">if</span> (!app_profile) {</div><div class="line">          <span class="keywordflow">throw</span> std::runtime_error(app_profile.status().message());</div><div class="line">        }</div><div class="line">        std::string app_profile_detail;</div><div class="line">        google::protobuf::TextFormat::PrintToString(*app_profile,</div><div class="line">                                                    &amp;app_profile_detail);</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;DONE, app profile details: &quot;</span> &lt;&lt; app_profile_detail</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">      }</div><div class="line">      std::cout &lt;&lt; <span class="charliteral">&#39;.&#39;</span> &lt;&lt; std::flush;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;TIMEOUT\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00620">620</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a284fcf3a539d1c3e7100880ce5da3c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a284fcf3a539d1c3e7100880ce5da3c24">&#9670;&nbsp;</a></span>AsyncUpdateCluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; google::bigtable::admin::v2::Cluster &gt; &gt; google::cloud::bigtable::v0::InstanceAdmin::AsyncUpdateCluster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ClusterConfig.html">ClusterConfig</a>&#160;</td>
          <td class="paramname"><em>cluster_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update an existing cluster (asynchronously). </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">cluster_config</td><td>cluster with updated values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future satisfied when either (a) the cluster is updated or (b) an unretriable error occurs or (c) polling or retry policy has been exhausted.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string instance_id, std::string cluster_id) {</div><div class="line">    <span class="keyword">auto</span> future =</div><div class="line">        instance_admin</div><div class="line">            .AsyncGetCluster(cq, <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">cbt::InstanceId</a>(instance_id),</div><div class="line">                             <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a73d20496d86761052e55848775b1e30b">cbt::ClusterId</a>(cluster_id))</div><div class="line">            .then([instance_admin,</div><div class="line">                   cq](google::cloud::future&lt;google::cloud::StatusOr&lt;</div><div class="line">                           google::bigtable::admin::v2::Cluster&gt;&gt;</div><div class="line">                           cluster_fut) <span class="keyword">mutable</span> {</div><div class="line">              <span class="keyword">auto</span> cluster = cluster_fut.get();</div><div class="line">              <span class="keywordflow">if</span> (!cluster) {</div><div class="line">                <span class="keywordflow">throw</span> std::runtime_error(cluster.status().message());</div><div class="line">              }</div><div class="line">              <span class="comment">// Modify the cluster.</span></div><div class="line">              cluster-&gt;set_serve_nodes(4);</div><div class="line">              <span class="keyword">auto</span> modified_config = cbt::ClusterConfig(std::move(*cluster));</div><div class="line"></div><div class="line">              <span class="keywordflow">return</span> instance_admin.AsyncUpdateCluster(cq, modified_config);</div><div class="line">            });</div><div class="line">    <span class="comment">// Most applications would simply call future.get(), here we show how to</span></div><div class="line">    <span class="comment">// perform additional work while the long running operation completes.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Waiting for cluster update to complete &quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != 100; ++i) {</div><div class="line">      <span class="keywordflow">if</span> (std::future_status::ready ==</div><div class="line">          future.wait_for(std::chrono::seconds(2))) {</div><div class="line">        <span class="keyword">auto</span> cluster = future.get();</div><div class="line">        <span class="keywordflow">if</span> (!cluster) {</div><div class="line">          <span class="keywordflow">throw</span> std::runtime_error(cluster.status().message());</div><div class="line">        }</div><div class="line">        std::string cluster_detail;</div><div class="line">        google::protobuf::TextFormat::PrintToString(*cluster, &amp;cluster_detail);</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;DONE, cluster details: &quot;</span> &lt;&lt; cluster_detail &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">      }</div><div class="line">      std::cout &lt;&lt; <span class="charliteral">&#39;.&#39;</span> &lt;&lt; std::flush;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;TIMEOUT\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00490">490</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a6717c2cd7a77ff60a2e8b904a776d014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6717c2cd7a77ff60a2e8b904a776d014">&#9670;&nbsp;</a></span>AsyncUpdateInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; google::bigtable::admin::v2::Instance &gt; &gt; google::cloud::bigtable::v0::InstanceAdmin::AsyncUpdateInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1CompletionQueue.html">CompletionQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceUpdateConfig.html">InstanceUpdateConfig</a>&#160;</td>
          <td class="paramname"><em>instance_update_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update an existing instance (asynchronously). </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_update_config</td><td>config with modified instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future satisfied when either (a) the instance is updated or (b) an unretriable error occurs or (c) polling or retry policy has been exhausted.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string instance_id) {</div><div class="line">    <span class="keyword">auto</span> future =</div><div class="line">        instance_admin.AsyncGetInstance(cq, instance_id)</div><div class="line">            .then([instance_admin,</div><div class="line">                   cq](google::cloud::future&lt;google::cloud::StatusOr&lt;</div><div class="line">                           <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a6fd9b4a69047dfdcd3e57799ff905a8a">google::bigtable::admin::v2::Instance</a>&gt;&gt;</div><div class="line">                           instance_fut) <span class="keyword">mutable</span> {</div><div class="line">              <span class="keyword">auto</span> instance = instance_fut.get();</div><div class="line">              <span class="keywordflow">if</span> (!instance) {</div><div class="line">                <span class="keywordflow">throw</span> std::runtime_error(instance.status().message());</div><div class="line">              }</div><div class="line">              <span class="comment">// Modify the instance and prepare the mask with modified field</span></div><div class="line">              cbt::InstanceUpdateConfig instance_update_config(</div><div class="line">                  std::move(*instance));</div><div class="line">              instance_update_config.set_display_name(<span class="stringliteral">&quot;Modified Display Name&quot;</span>);</div><div class="line"></div><div class="line">              <span class="keywordflow">return</span> instance_admin.AsyncUpdateInstance(cq,</div><div class="line">                                                        instance_update_config);</div><div class="line">            });</div><div class="line">    <span class="comment">// Most applications would simply call future.get(), here we show how to</span></div><div class="line">    <span class="comment">// perform additional work while the long running operation completes.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Waiting for instance update to complete &quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != 100; ++i) {</div><div class="line">      <span class="keywordflow">if</span> (std::future_status::ready ==</div><div class="line">          future.wait_for(std::chrono::seconds(2))) {</div><div class="line">        <span class="keyword">auto</span> instance = future.get();</div><div class="line">        <span class="keywordflow">if</span> (!instance) {</div><div class="line">          <span class="keywordflow">throw</span> std::runtime_error(instance.status().message());</div><div class="line">        }</div><div class="line">        std::string instance_detail;</div><div class="line">        google::protobuf::TextFormat::PrintToString(*instance,</div><div class="line">                                                    &amp;instance_detail);</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;DONE, instance details: &quot;</span> &lt;&lt; instance_detail &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">      }</div><div class="line">      std::cout &lt;&lt; <span class="charliteral">&#39;.&#39;</span> &lt;&lt; std::flush;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;TIMEOUT\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00218">218</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a36a70eb6e950e9ef8c2d2089438f67d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a70eb6e950e9ef8c2d2089438f67d5">&#9670;&nbsp;</a></span>ClusterName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string google::cloud::bigtable::v0::InstanceAdmin::ClusterName </td>
          <td>(</td>
          <td class="paramtype">bigtable::InstanceId const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::ClusterId const &amp;&#160;</td>
          <td class="paramname"><em>cluster_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the fully qualified name of the given cluster_id in give instance_id. </p>

<p class="definition">Definition at line <a class="el" href="instance__admin_8h_source.html#l00091">91</a> of file <a class="el" href="instance__admin_8h_source.html">instance_admin.h</a>.</p>

</div>
</div>
<a id="a54c14a6464a0ec9d547c2911f685d000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c14a6464a0ec9d547c2911f685d000">&#9670;&nbsp;</a></span>CreateAppProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; btadmin::AppProfile &gt; google::cloud::bigtable::v0::InstanceAdmin::CreateAppProfile </td>
          <td>(</td>
          <td class="paramtype">bigtable::InstanceId const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1AppProfileConfig.html">AppProfileConfig</a>&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new application profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the instance for the new application profile. </td></tr>
    <tr><td class="paramname">config</td><td>the configuration for the new application profile. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The proto describing the new application profile.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string instance_id,</div><div class="line">     std::string profile_id) {</div><div class="line">    <span class="keyword">auto</span> config = cbt::AppProfileConfig::MultiClusterUseAny(</div><div class="line">        <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a412d4ff7e63afde75faebcbd07be0d4a">cbt::AppProfileId</a>(profile_id));</div><div class="line">    <span class="keyword">auto</span> profile =</div><div class="line">        instance_admin.CreateAppProfile(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">cbt::InstanceId</a>(instance_id), config);</div><div class="line">    <span class="keywordflow">if</span> (!profile) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(profile.status().message());</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;New profile created with name=&quot;</span> &lt;&lt; profile-&gt;name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> CreateAppProfileCluster(</div><div class="line">    google::cloud::bigtable::InstanceAdmin instance_admin, <span class="keywordtype">int</span> argc,</div><div class="line">    <span class="keywordtype">char</span>* argv[]) {</div><div class="line">  <span class="keywordflow">if</span> (argc != 4) {</div><div class="line">    <span class="keywordflow">throw</span> Usage{</div><div class="line">        <span class="stringliteral">&quot;create-app-profile-cluster: &lt;project-id&gt; &lt;instance-id&gt; &lt;profile-id&gt;&quot;</span></div><div class="line">        <span class="stringliteral">&quot; &lt;cluster-id&gt;&quot;</span>};</div><div class="line">  }</div><div class="line">  <span class="keyword">auto</span> instance_id = ConsumeArg(argc, argv);</div><div class="line">  <span class="keyword">auto</span> profile_id = ConsumeArg(argc, argv);</div><div class="line">  <span class="keyword">auto</span> cluster_id = ConsumeArg(argc, argv);</div><div class="line"></div><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string instance_id,</div><div class="line">     std::string profile_id, std::string cluster_id) {</div><div class="line">    <span class="keyword">auto</span> config = cbt::AppProfileConfig::SingleClusterRouting(</div><div class="line">        <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a412d4ff7e63afde75faebcbd07be0d4a">cbt::AppProfileId</a>(profile_id), <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a73d20496d86761052e55848775b1e30b">cbt::ClusterId</a>(cluster_id));</div><div class="line">    <span class="keyword">auto</span> profile =</div><div class="line">        instance_admin.CreateAppProfile(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">cbt::InstanceId</a>(instance_id), config);</div><div class="line">    <span class="keywordflow">if</span> (!profile) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(profile.status().message());</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;New profile created with name=&quot;</span> &lt;&lt; profile-&gt;name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00526">526</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a20ff5a065242ca9b552049b9b1a0e0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ff5a065242ca9b552049b9b1a0e0b3">&#9670;&nbsp;</a></span>CreateCluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; btadmin::Cluster &gt; &gt; google::cloud::bigtable::v0::InstanceAdmin::CreateCluster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ClusterConfig.html">ClusterConfig</a>&#160;</td>
          <td class="paramname"><em>cluster_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::InstanceId const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::ClusterId const &amp;&#160;</td>
          <td class="paramname"><em>cluster_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new Cluster of Cloud Bigtable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster_config</td><td>a description of the new cluster to be created. </td></tr>
    <tr><td class="paramname">instance_id</td><td>the id of the instance in the project </td></tr>
    <tr><td class="paramname">cluster_id</td><td>the id of the cluster in the project that needs to be created. It must be between 6 and 30 characters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string instance_id,</div><div class="line">     std::string cluster_id, std::string zone) {</div><div class="line">    <span class="keyword">auto</span> cluster_config = cbt::ClusterConfig(zone, 3, cbt::ClusterConfig::HDD);</div><div class="line">    <span class="keyword">auto</span> future_cluster = instance_admin.CreateCluster(</div><div class="line">        cluster_config, <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">cbt::InstanceId</a>(instance_id),</div><div class="line">        <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a73d20496d86761052e55848775b1e30b">cbt::ClusterId</a>(cluster_id));</div><div class="line"></div><div class="line">    <span class="comment">// Applications can wait asynchronously, in this example we just block.</span></div><div class="line">    StatusOr&lt;google::bigtable::admin::v2::Cluster&gt; cluster =</div><div class="line">        future_cluster.get();</div><div class="line">    <span class="keywordflow">if</span> (!cluster) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(cluster.status().message());</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Successfully created cluster &quot;</span> &lt;&lt; cluster-&gt;name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00164">164</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a642849986a3e8c67b160d4e654d9a999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642849986a3e8c67b160d4e654d9a999">&#9670;&nbsp;</a></span>CreateInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; btadmin::Instance &gt; &gt; google::cloud::bigtable::v0::InstanceAdmin::CreateInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceConfig.html">InstanceConfig</a>&#160;</td>
          <td class="paramname"><em>instance_config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new instance of Cloud Bigtable. </p>
<dl class="section warning"><dt>Warning</dt><dd>Note that this is operation can take seconds or minutes to complete. The application may prefer to perform other work while waiting for this operation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_config</td><td>a description of the new instance to be created. instance_id and a display_name parameters must be set in instance_config,<ul>
<li>instance_id : must be between 6 and 33 characters.</li>
<li>display_name : must be between 4 and 30 characters. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future that becomes satisfied when (a) the operation has completed successfully, in which case it returns a proto with the Instance details, (b) the operation has failed, in which case the future contains an exception (typically <code>bigtable::GrpcError</code>) with the details of the failure, or (c) the state of the operation is unknown after the time allocated by the retry policies has expired, in which case the future contains an exception of type <code>bigtable::PollTimeout</code>.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string instance_id,</div><div class="line">     std::string zone) {</div><div class="line">    <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aeb2a52a19595444371d7dc12350d3f63">cbt::DisplayName</a> display_name(<span class="stringliteral">&quot;Put description here&quot;</span>);</div><div class="line">    std::string cluster_id = instance_id + <span class="stringliteral">&quot;-c1&quot;</span>;</div><div class="line">    <span class="keyword">auto</span> cluster_config = cbt::ClusterConfig(zone, 3, cbt::ClusterConfig::HDD);</div><div class="line">    cbt::InstanceConfig config(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">cbt::InstanceId</a>(instance_id), display_name,</div><div class="line">                               {{cluster_id, cluster_config}});</div><div class="line">    config.set_type(cbt::InstanceConfig::PRODUCTION);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> future = instance_admin.CreateInstance(config);</div><div class="line">    <span class="comment">// Most applications would simply call future.get(), here we show how to</span></div><div class="line">    <span class="comment">// perform additional work while the long running operation completes.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Waiting for instance creation to complete &quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != 100; ++i) {</div><div class="line">      <span class="keywordflow">if</span> (std::future_status::ready ==</div><div class="line">          future.wait_for(std::chrono::seconds(2))) {</div><div class="line">        <span class="keyword">auto</span> instance = future.get();</div><div class="line">        <span class="keywordflow">if</span> (!instance) {</div><div class="line">          <span class="keywordflow">throw</span> std::runtime_error(instance.status().message());</div><div class="line">        }</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;DONE: &quot;</span> &lt;&lt; instance-&gt;name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">      }</div><div class="line">      std::cout &lt;&lt; <span class="charliteral">&#39;.&#39;</span> &lt;&lt; std::flush;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;TIMEOUT\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00127">127</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a6bc4bffa110e02adc20b601a5b2f6538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc4bffa110e02adc20b601a5b2f6538">&#9670;&nbsp;</a></span>DeleteAppProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Status google::cloud::bigtable::v0::InstanceAdmin::DeleteAppProfile </td>
          <td>(</td>
          <td class="paramtype">bigtable::InstanceId const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::AppProfileId const &amp;&#160;</td>
          <td class="paramname"><em>profile_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_warnings</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an existing application profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the instance to look the profile in. </td></tr>
    <tr><td class="paramname">profile_id</td><td>the id of the profile within that instance. </td></tr>
    <tr><td class="paramname">ignore_warnings</td><td>if true, ignore safety checks when deleting the application profile.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string instance_id,</div><div class="line">     std::string profile_id, <span class="keywordtype">bool</span> ignore_warnings) {</div><div class="line">    google::cloud::Status status = instance_admin.DeleteAppProfile(</div><div class="line">        <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">cbt::InstanceId</a>(instance_id), <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a412d4ff7e63afde75faebcbd07be0d4a">cbt::AppProfileId</a>(profile_id),</div><div class="line">        ignore_warnings);</div><div class="line">    <span class="keywordflow">if</span> (!status.ok()) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(status.message());</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Application Profile deleted\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00703">703</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a911a3dfc283d37ec580797ce126b2bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911a3dfc283d37ec580797ce126b2bc4">&#9670;&nbsp;</a></span>DeleteCluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Status google::cloud::bigtable::v0::InstanceAdmin::DeleteCluster </td>
          <td>(</td>
          <td class="paramtype">bigtable::InstanceId const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::ClusterId const &amp;&#160;</td>
          <td class="paramname"><em>cluster_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the specified cluster of an instance in the project. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the id of the instance in the project </td></tr>
    <tr><td class="paramname">cluster_id</td><td>the id of the cluster in the project that needs to be deleted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string instance_id,</div><div class="line">     std::string cluster_id) {</div><div class="line">    google::cloud::Status status = instance_admin.DeleteCluster(</div><div class="line">        <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">cbt::InstanceId</a>(instance_id), <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a73d20496d86761052e55848775b1e30b">cbt::ClusterId</a>(cluster_id));</div><div class="line">    <span class="keywordflow">if</span> (!status.ok()) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(status.message());</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00509">509</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="ab7de1ee5392dfccc006218f0abb83118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7de1ee5392dfccc006218f0abb83118">&#9670;&nbsp;</a></span>DeleteInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Status google::cloud::bigtable::v0::InstanceAdmin::DeleteInstance </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the instances in the project. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the id of the instance in the project that needs to be deleted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string instance_id) {</div><div class="line">    google::cloud::Status status = instance_admin.DeleteInstance(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!status.ok()) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(status.message());</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Successfully deleted the instance &quot;</span> &lt;&lt; instance_id &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00278">278</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a76865c687f2cadc808c39e3c7334abc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76865c687f2cadc808c39e3c7334abc9">&#9670;&nbsp;</a></span>GetAppProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; btadmin::AppProfile &gt; google::cloud::bigtable::v0::InstanceAdmin::GetAppProfile </td>
          <td>(</td>
          <td class="paramtype">bigtable::InstanceId const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::AppProfileId const &amp;&#160;</td>
          <td class="paramname"><em>profile_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the detailed information about an existing application profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the instance to look the profile in. </td></tr>
    <tr><td class="paramname">profile_id</td><td>the id of the profile within that instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The proto describing the application profile.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string instance_id,</div><div class="line">     std::string profile_id) {</div><div class="line">    <span class="keyword">auto</span> profile = instance_admin.GetAppProfile(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">cbt::InstanceId</a>(instance_id),</div><div class="line">                                                <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a412d4ff7e63afde75faebcbd07be0d4a">cbt::AppProfileId</a>(profile_id));</div><div class="line">    <span class="keywordflow">if</span> (!profile) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(profile.status().message());</div><div class="line">    }</div><div class="line">    std::string detail;</div><div class="line">    google::protobuf::TextFormat::PrintToString(*profile, &amp;detail);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Application Profile details=&quot;</span> &lt;&lt; detail &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00565">565</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="ad023404fcf897a265e2cdf3e7671bef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad023404fcf897a265e2cdf3e7671bef5">&#9670;&nbsp;</a></span>GetCluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; btadmin::Cluster &gt; google::cloud::bigtable::v0::InstanceAdmin::GetCluster </td>
          <td>(</td>
          <td class="paramtype">bigtable::InstanceId const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::ClusterId const &amp;&#160;</td>
          <td class="paramname"><em>cluster_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the specified cluster of an instance in the project. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the id of the instance in the project </td></tr>
    <tr><td class="paramname">cluster_id</td><td>the id of the cluster in the project that needs to be deleted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a Cluster for given instance_id and cluster_id.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string instance_id,</div><div class="line">     std::string cluster_id) {</div><div class="line">    <span class="keyword">auto</span> cluster = instance_admin.GetCluster(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">cbt::InstanceId</a>(instance_id),</div><div class="line">                                             <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a73d20496d86761052e55848775b1e30b">cbt::ClusterId</a>(cluster_id));</div><div class="line">    <span class="keywordflow">if</span> (!cluster) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(cluster.status().message());</div><div class="line">    }</div><div class="line">    std::string cluster_detail;</div><div class="line">    google::protobuf::TextFormat::PrintToString(*cluster, &amp;cluster_detail);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;GetCluster details : &quot;</span> &lt;&lt; cluster_detail &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00340">340</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a1cb556f62cbb7b71cf036e5d00c830f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb556f62cbb7b71cf036e5d00c830f9">&#9670;&nbsp;</a></span>GetIamPolicy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; google::cloud::IamPolicy &gt; google::cloud::bigtable::v0::InstanceAdmin::GetIamPolicy </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the policy for <code>instance_id</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the instance to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Policy the full IAM policy for the instance.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string instance_id) {</div><div class="line">    <span class="keyword">auto</span> policy = instance_admin.GetIamPolicy(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!policy) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(policy.status().message());</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;The IAM Policy for &quot;</span> &lt;&lt; instance_id &lt;&lt; <span class="stringliteral">&quot; is\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; kv : policy-&gt;bindings) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;role &quot;</span> &lt;&lt; kv.first &lt;&lt; <span class="stringliteral">&quot; includes [&quot;</span>;</div><div class="line">      <span class="keywordtype">char</span> <span class="keyword">const</span>* sep = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; member : kv.second) {</div><div class="line">        std::cout &lt;&lt; sep &lt;&lt; member;</div><div class="line">        sep = <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">      }</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00748">748</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a55d5daa968557296320a8251bb0ae1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d5daa968557296320a8251bb0ae1ec">&#9670;&nbsp;</a></span>GetInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; btadmin::Instance &gt; google::cloud::bigtable::v0::InstanceAdmin::GetInstance </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the details of <code>instance_id</code>. </p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string instance_id) {</div><div class="line">    <span class="keyword">auto</span> instance = instance_admin.GetInstance(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!instance) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(instance.status().message());</div><div class="line">    }</div><div class="line">    std::string instance_detail;</div><div class="line">    google::protobuf::TextFormat::PrintToString(*instance, &amp;instance_detail);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;GetInstance details : &quot;</span> &lt;&lt; instance_detail &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00238">238</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a13d5dd94a1c3414bdbad5ee9f217022a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d5dd94a1c3414bdbad5ee9f217022a">&#9670;&nbsp;</a></span>InstanceName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string google::cloud::bigtable::v0::InstanceAdmin::InstanceName </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the fully qualified name of the given instance_id. </p>

<p class="definition">Definition at line <a class="el" href="instance__admin_8h_source.html#l00085">85</a> of file <a class="el" href="instance__admin_8h_source.html">instance_admin.h</a>.</p>

</div>
</div>
<a id="a43273851a72529657b74cf80e464d85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43273851a72529657b74cf80e464d85a">&#9670;&nbsp;</a></span>ListAppProfiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; std::vector&lt; btadmin::AppProfile &gt; &gt; google::cloud::bigtable::v0::InstanceAdmin::ListAppProfiles </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List the application profiles in an instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the instance to list the profiles for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::vector with the protos describing any profiles.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string instance_id) {</div><div class="line">    <span class="keyword">auto</span> profiles = instance_admin.ListAppProfiles(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!profiles) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(profiles.status().message());</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;The &quot;</span> &lt;&lt; instance_id &lt;&lt; <span class="stringliteral">&quot; instance has &quot;</span> &lt;&lt; profiles-&gt;size()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; application profiles\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; profile : *profiles) {</div><div class="line">      std::string detail;</div><div class="line">      google::protobuf::TextFormat::PrintToString(profile, &amp;detail);</div><div class="line">      std::cout &lt;&lt; detail &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00643">643</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a92bc59bb5c428a77bfd34c5a0a39b1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92bc59bb5c428a77bfd34c5a0a39b1e2">&#9670;&nbsp;</a></span>ListClusters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ClusterList.html">ClusterList</a> &gt; google::cloud::bigtable::v0::InstanceAdmin::ListClusters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the list of clusters in an instance. </p>
<dl class="section note"><dt>Note</dt><dd>In some circumstances Cloud Bigtable may be unable to obtain the full list of clusters, typically because some transient failure has made specific zones unavailable. In this cases the service returns a separate list of <code>failed_locations</code> that represent the unavailable zones. Applications may want to retry the operation after the transient conditions have cleared.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string instance_id) {</div><div class="line">    <span class="keyword">auto</span> cluster_list = instance_admin.ListClusters(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!cluster_list) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(cluster_list.status().message());</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Cluster Name List\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; cluster : cluster_list-&gt;clusters) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Cluster Name:&quot;</span> &lt;&lt; cluster.name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (!cluster_list-&gt;failed_locations.empty()) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;The Cloud Bigtable service reports that the following &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;locations are temporarily unavailable and no information &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;about clusters in these locations can be obtained:\n&quot;</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; failed_location : cluster_list-&gt;failed_locations) {</div><div class="line">        std::cout &lt;&lt; failed_location &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00380">380</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a4fad2de97c492b7f37f957a043967cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fad2de97c492b7f37f957a043967cae">&#9670;&nbsp;</a></span>ListClusters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ClusterList.html">ClusterList</a> &gt; google::cloud::bigtable::v0::InstanceAdmin::ListClusters </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the list of clusters in an instance. </p>
<dl class="section note"><dt>Note</dt><dd>In some circumstances Cloud Bigtable may be unable to obtain the full list of clusters, typically because some transient failure has made specific zones unavailable. In this cases the service returns a separate list of <code>failed_locations</code> that represent the unavailable zones. Applications may want to retry the operation after the transient conditions have cleared.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string instance_id) {</div><div class="line">    <span class="keyword">auto</span> cluster_list = instance_admin.ListClusters(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!cluster_list) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(cluster_list.status().message());</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Cluster Name List\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; cluster : cluster_list-&gt;clusters) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Cluster Name:&quot;</span> &lt;&lt; cluster.name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (!cluster_list-&gt;failed_locations.empty()) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;The Cloud Bigtable service reports that the following &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;locations are temporarily unavailable and no information &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;about clusters in these locations can be obtained:\n&quot;</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; failed_location : cluster_list-&gt;failed_locations) {</div><div class="line">        std::cout &lt;&lt; failed_location &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00384">384</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a560bc7eb9bbdc92d8afda323e0922a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a560bc7eb9bbdc92d8afda323e0922a74">&#9670;&nbsp;</a></span>ListInstances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceList.html">InstanceList</a> &gt; google::cloud::bigtable::v0::InstanceAdmin::ListInstances </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the list of instances in the project. </p>
<dl class="section note"><dt>Note</dt><dd>In some circumstances Cloud Bigtable may be unable to obtain the full list of instances, typically because some transient failure has made specific zones unavailable. In this cases the service returns a separate list of <code>failed_locations</code> that represent the unavailable zones. Applications may want to retry the operation after the transient conditions have cleared.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin) {</div><div class="line">    <span class="keyword">auto</span> instances = instance_admin.ListInstances();</div><div class="line">    <span class="keywordflow">if</span> (!instances) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(instances.status().message());</div><div class="line">    }</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; instance : instances-&gt;instances) {</div><div class="line">      std::cout &lt;&lt; instance.name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (!instances-&gt;failed_locations.empty()) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;The Cloud Bigtable service reports that the following &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;locations are temporarily unavailable and no information &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;about instances in these locations can be obtained:\n&quot;</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; failed_location : instances-&gt;failed_locations) {</div><div class="line">        std::cout &lt;&lt; failed_location &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00037">37</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a21477780db4f5268667ab89cb8df235e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21477780db4f5268667ab89cb8df235e">&#9670;&nbsp;</a></span>project_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string const&amp; google::cloud::bigtable::v0::InstanceAdmin::project_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The project id, i.e., <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceAdmin.html#a62d9a1591c24ab2521a9e6f8d29af18e" title="The full name (projects/&lt;project_id&gt;) of the project. ">project_name()</a></code> without the <code>projects/</code> prefix. </p>

<p class="definition">Definition at line <a class="el" href="instance__admin_8h_source.html#l00082">82</a> of file <a class="el" href="instance__admin_8h_source.html">instance_admin.h</a>.</p>

</div>
</div>
<a id="a62d9a1591c24ab2521a9e6f8d29af18e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d9a1591c24ab2521a9e6f8d29af18e">&#9670;&nbsp;</a></span>project_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string const&amp; google::cloud::bigtable::v0::InstanceAdmin::project_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The full name (<code>projects/&lt;project_id&gt;</code>) of the project. </p>

<p class="definition">Definition at line <a class="el" href="instance__admin_8h_source.html#l00080">80</a> of file <a class="el" href="instance__admin_8h_source.html">instance_admin.h</a>.</p>

</div>
</div>
<a id="a1e7709527acc7b0827a9e9d372bcfa25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7709527acc7b0827a9e9d372bcfa25">&#9670;&nbsp;</a></span>SetIamPolicy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; google::cloud::IamPolicy &gt; google::cloud::bigtable::v0::InstanceAdmin::SetIamPolicy </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">google::cloud::IamBindings const &amp;&#160;</td>
          <td class="paramname"><em>iam_bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>etag</em> = <code>std::string{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the IAM policy for an instance. </p>
<p>Applications can provide the <code>etag</code> to implement optimistic concurrency control. If <code>etag</code> is not empty, the server will reject calls where the provided ETag does not match the ETag value stored in the server.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>which instance to set the IAM policy for. </td></tr>
    <tr><td class="paramname">iam_bindings</td><td>IamBindings object containing role and members. </td></tr>
    <tr><td class="paramname">etag</td><td>the expected ETag value for the current policy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Policy the current IAM bindings for the instance.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string instance_id,</div><div class="line">     std::string role, std::string member) {</div><div class="line">    <span class="keyword">auto</span> current = instance_admin.GetIamPolicy(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!current) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(current.status().message());</div><div class="line">    }</div><div class="line">    <span class="keyword">auto</span> bindings = current-&gt;bindings;</div><div class="line">    bindings.AddMember(role, member);</div><div class="line">    <span class="keyword">auto</span> policy =</div><div class="line">        instance_admin.SetIamPolicy(instance_id, bindings, current-&gt;etag);</div><div class="line">    <span class="keywordflow">if</span> (!policy) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(policy.status().message());</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;The IAM Policy for &quot;</span> &lt;&lt; instance_id &lt;&lt; <span class="stringliteral">&quot; is\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; kv : policy-&gt;bindings) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;role &quot;</span> &lt;&lt; kv.first &lt;&lt; <span class="stringliteral">&quot; includes [&quot;</span>;</div><div class="line">      <span class="keywordtype">char</span> <span class="keyword">const</span>* sep = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; m : kv.second) {</div><div class="line">        std::cout &lt;&lt; sep &lt;&lt; m;</div><div class="line">        sep = <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">      }</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00798">798</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a628efb6a49363fa8fa4a34ebdd2d4ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628efb6a49363fa8fa4a34ebdd2d4ada">&#9670;&nbsp;</a></span>TestIamPermissions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; std::vector&lt; std::string &gt; &gt; google::cloud::bigtable::v0::InstanceAdmin::TestIamPermissions </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>permissions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a permission set that the caller has on the specified instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the ID of the instance to query. </td></tr>
    <tr><td class="paramname">permissions</td><td>set of permissions to check for the resource.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string resource,</div><div class="line">     std::vector&lt;std::string&gt; permissions) {</div><div class="line">    <span class="keyword">auto</span> result = instance_admin.TestIamPermissions(resource, permissions);</div><div class="line">    <span class="keywordflow">if</span> (!result) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(result.status().message());</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;The current user has the following permissions [&quot;</span>;</div><div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span>* sep = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; p : *result) {</div><div class="line">      std::cout &lt;&lt; sep &lt;&lt; p;</div><div class="line">      sep = <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://cloud.google.com/bigtable/docs/access-control">https://cloud.google.com/bigtable/docs/access-control</a> for a list of valid permissions on Google Cloud Bigtable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00835">835</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a384aaa94d541751ff796856f98f14b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384aaa94d541751ff796856f98f14b7a">&#9670;&nbsp;</a></span>UpdateAppProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; btadmin::AppProfile &gt; &gt; google::cloud::bigtable::v0::InstanceAdmin::UpdateAppProfile </td>
          <td>(</td>
          <td class="paramtype">bigtable::InstanceId&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::AppProfileId&#160;</td>
          <td class="paramname"><em>profile_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1AppProfileUpdateConfig.html">AppProfileUpdateConfig</a>&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new application profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the instance for the new application profile. </td></tr>
    <tr><td class="paramname">profile_id</td><td>the id (not the full name) of the profile to update. </td></tr>
    <tr><td class="paramname">config</td><td>the configuration for the new application profile. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The proto describing the new application profile.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string instance_id,</div><div class="line">     std::string profile_id, std::string description) {</div><div class="line">    <span class="keyword">auto</span> profile_future = instance_admin.UpdateAppProfile(</div><div class="line">        <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">cbt::InstanceId</a>(instance_id), <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a412d4ff7e63afde75faebcbd07be0d4a">cbt::AppProfileId</a>(profile_id),</div><div class="line">        cbt::AppProfileUpdateConfig().set_description(description));</div><div class="line">    <span class="keyword">auto</span> profile = profile_future.get();</div><div class="line">    <span class="keywordflow">if</span> (!profile) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(profile.status().message());</div><div class="line">    }</div><div class="line">    std::string detail;</div><div class="line">    google::protobuf::TextFormat::PrintToString(*profile, &amp;detail);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Application Profile details=&quot;</span> &lt;&lt; detail &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string instance_id,</div><div class="line">     std::string profile_id) {</div><div class="line">    <span class="keyword">auto</span> profile_future = instance_admin.UpdateAppProfile(</div><div class="line">        <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">cbt::InstanceId</a>(instance_id), <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a412d4ff7e63afde75faebcbd07be0d4a">cbt::AppProfileId</a>(profile_id),</div><div class="line">        cbt::AppProfileUpdateConfig()</div><div class="line">            .set_multi_cluster_use_any()</div><div class="line">            .set_ignore_warnings(<span class="keyword">true</span>));</div><div class="line">    <span class="keyword">auto</span> profile = profile_future.get();</div><div class="line">    <span class="keywordflow">if</span> (!profile) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(profile.status().message());</div><div class="line">    }</div><div class="line">    std::string detail;</div><div class="line">    google::protobuf::TextFormat::PrintToString(*profile, &amp;detail);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Application Profile details=&quot;</span> &lt;&lt; detail &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string instance_id,</div><div class="line">     std::string profile_id, std::string cluster_id) {</div><div class="line">    <span class="keyword">auto</span> profile_future = instance_admin.UpdateAppProfile(</div><div class="line">        <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">cbt::InstanceId</a>(instance_id), <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a412d4ff7e63afde75faebcbd07be0d4a">cbt::AppProfileId</a>(profile_id),</div><div class="line">        cbt::AppProfileUpdateConfig()</div><div class="line">            .set_single_cluster_routing(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a73d20496d86761052e55848775b1e30b">cbt::ClusterId</a>(cluster_id))</div><div class="line">            .set_ignore_warnings(<span class="keyword">true</span>));</div><div class="line">    <span class="keyword">auto</span> profile = profile_future.get();</div><div class="line">    <span class="keywordflow">if</span> (!profile) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(profile.status().message());</div><div class="line">    }</div><div class="line">    std::string detail;</div><div class="line">    google::protobuf::TextFormat::PrintToString(*profile, &amp;detail);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Application Profile details=&quot;</span> &lt;&lt; detail &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00605">605</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="abd851711d3d5dce20cc195e9cd1c4bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd851711d3d5dce20cc195e9cd1c4bcf">&#9670;&nbsp;</a></span>UpdateCluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; google::bigtable::admin::v2::Cluster &gt; &gt; google::cloud::bigtable::v0::InstanceAdmin::UpdateCluster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1ClusterConfig.html">ClusterConfig</a>&#160;</td>
          <td class="paramname"><em>cluster_config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update an existing cluster of Cloud Bigtable. </p>
<dl class="section warning"><dt>Warning</dt><dd>Note that this is operation can take seconds or minutes to complete. The application may prefer to perform other work while waiting for this operation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster_config</td><td>cluster with updated values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future that becomes satisfied when (a) the operation has completed successfully, in which case it returns a proto with the Instance details, (b) the operation has failed, in which case the future contains an exception (typically <code>bigtable::GrpcError</code>) with the details of the failure, or (c) the state of the operation is unknown after the time allocated by the retry policies has expired, in which case the future contains an exception of type <code>bigtable::PollTimeout</code>.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string instance_id,</div><div class="line">     std::string cluster_id) {</div><div class="line">    <span class="comment">// GetCluster first and then modify it.</span></div><div class="line">    <span class="keyword">auto</span> cluster = instance_admin.GetCluster(<a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#aa9a2503f014b52ebb4ba4b2651070d71">cbt::InstanceId</a>(instance_id),</div><div class="line">                                             <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v0.html#a73d20496d86761052e55848775b1e30b">cbt::ClusterId</a>(cluster_id));</div><div class="line">    <span class="keywordflow">if</span> (!cluster) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(cluster.status().message());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Modify the cluster.</span></div><div class="line">    cluster-&gt;set_serve_nodes(4);</div><div class="line">    <span class="keyword">auto</span> modified_config = cbt::ClusterConfig(std::move(*cluster));</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> modified_cluster = instance_admin.UpdateCluster(modified_config).get();</div><div class="line">    <span class="keywordflow">if</span> (!modified_cluster) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(modified_cluster.status().message());</div><div class="line">    }</div><div class="line">    std::string cluster_detail;</div><div class="line">    google::protobuf::TextFormat::PrintToString(*modified_cluster,</div><div class="line">                                                &amp;cluster_detail);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;cluster details : &quot;</span> &lt;&lt; cluster_detail &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00478">478</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="aa6e23515ae533a95e5d07f60057cbaf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e23515ae533a95e5d07f60057cbaf1">&#9670;&nbsp;</a></span>UpdateInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; google::bigtable::admin::v2::Instance &gt; &gt; google::cloud::bigtable::v0::InstanceAdmin::UpdateInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v0_1_1InstanceUpdateConfig.html">InstanceUpdateConfig</a>&#160;</td>
          <td class="paramname"><em>instance_update_config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update an existing instance of Cloud Bigtable. </p>
<dl class="section warning"><dt>Warning</dt><dd>Note that this is operation can take seconds or minutes to complete. The application may prefer to perform other work while waiting for this operation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_update_config</td><td>config with modified instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future that becomes satisfied when (a) the operation has completed successfully, in which case it returns a proto with the Instance details, (b) the operation has failed, in which case the future contains an exception (typically <code>bigtable::GrpcError</code>) with the details of the failure, or (c) the state of the operation is unknown after the time allocated by the retry policies has expired, in which case the future contains an exception of type <code>bigtable::PollTimeout</code>.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string instance_id) {</div><div class="line">    <span class="keyword">auto</span> instance = instance_admin.GetInstance(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!instance) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(instance.status().message());</div><div class="line">    }</div><div class="line">    <span class="comment">// Modify the instance and prepare the mask with modified field</span></div><div class="line">    cbt::InstanceUpdateConfig instance_update_config(std::move(*instance));</div><div class="line">    instance_update_config.set_display_name(<span class="stringliteral">&quot;Modified Display Name&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> future =</div><div class="line">        instance_admin.UpdateInstance(std::move(instance_update_config));</div><div class="line">    <span class="keyword">auto</span> updated_instance = future.get();</div><div class="line">    <span class="keywordflow">if</span> (!updated_instance) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(updated_instance.status().message());</div><div class="line">    }</div><div class="line">    std::string instance_detail;</div><div class="line">    google::protobuf::TextFormat::PrintToString(*updated_instance,</div><div class="line">                                                &amp;instance_detail);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;GetInstance details : &quot;</span> &lt;&lt; instance_detail &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00206">206</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
