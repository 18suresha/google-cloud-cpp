<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google Cloud Bigtable C++ Client: google::cloud::bigtable::v1::InstanceAdmin Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Google Cloud Bigtable C++ Client
   &#160;<span id="projectnumber">1.19.0</span>
   </div>
   <div id="projectbrief">A C++ Client Library for Google Cloud Bigtable</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegoogle.html">google</a></li><li class="navelem"><a class="el" href="namespacegoogle_1_1cloud.html">cloud</a></li><li class="navelem"><a class="el" href="namespacegoogle_1_1cloud_1_1bigtable.html">bigtable</a></li><li class="navelem"><a class="el" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html">v1</a></li><li class="navelem"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html">InstanceAdmin</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">google::cloud::bigtable::v1::InstanceAdmin Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements the APIs to administer Cloud Bigtable instances.  
 <a href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="instance__admin_8h_source.html">google/cloud/bigtable/instance_admin.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a11b793627d92457a0f7909b31f1dd247"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a11b793627d92457a0f7909b31f1dd247">InstanceAdmin</a> (std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdminClient.html">InstanceAdminClient</a> &gt; client)</td></tr>
<tr class="separator:a11b793627d92457a0f7909b31f1dd247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f86c97b5c2f667f98ba53376b9db2d"><td class="memTemplParams" colspan="2">template&lt;typename... Policies&gt; </td></tr>
<tr class="memitem:a35f86c97b5c2f667f98ba53376b9db2d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a35f86c97b5c2f667f98ba53376b9db2d">InstanceAdmin</a> (std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdminClient.html">InstanceAdminClient</a> &gt; client, Policies &amp;&amp;... policies)</td></tr>
<tr class="memdesc:a35f86c97b5c2f667f98ba53376b9db2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html" title="Implements the APIs to administer Cloud Bigtable instances.">InstanceAdmin</a> using explicit policies to handle RPC errors.  <a href="#a35f86c97b5c2f667f98ba53376b9db2d">More...</a><br /></td></tr>
<tr class="separator:a35f86c97b5c2f667f98ba53376b9db2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7c80489d100c5e2d109819fa7cf608"><td class="memItemLeft" align="right" valign="top">std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a4c7c80489d100c5e2d109819fa7cf608">project_name</a> () const</td></tr>
<tr class="memdesc:a4c7c80489d100c5e2d109819fa7cf608"><td class="mdescLeft">&#160;</td><td class="mdescRight">The full name (<code>projects/&lt;project_id&gt;</code>) of the project.  <a href="#a4c7c80489d100c5e2d109819fa7cf608">More...</a><br /></td></tr>
<tr class="separator:a4c7c80489d100c5e2d109819fa7cf608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6982c136a05df506dca2f56acfcdeb"><td class="memItemLeft" align="right" valign="top">std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a6b6982c136a05df506dca2f56acfcdeb">project_id</a> () const</td></tr>
<tr class="memdesc:a6b6982c136a05df506dca2f56acfcdeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The project id, i.e., <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a4c7c80489d100c5e2d109819fa7cf608" title="The full name (projects/&lt;project_id&gt;) of the project.">project_name()</a></code> without the <code>projects/</code> prefix.  <a href="#a6b6982c136a05df506dca2f56acfcdeb">More...</a><br /></td></tr>
<tr class="separator:a6b6982c136a05df506dca2f56acfcdeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefeee609fab315842e014c1cbadb246c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#aefeee609fab315842e014c1cbadb246c">InstanceName</a> (std::string const &amp;instance_id) const</td></tr>
<tr class="memdesc:aefeee609fab315842e014c1cbadb246c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fully qualified name of the given instance_id.  <a href="#aefeee609fab315842e014c1cbadb246c">More...</a><br /></td></tr>
<tr class="separator:aefeee609fab315842e014c1cbadb246c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92f07ae5d32b312166a2b71cf50f06e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#ac92f07ae5d32b312166a2b71cf50f06e">ClusterName</a> (std::string const &amp;instance_id, std::string const &amp;cluster_id) const</td></tr>
<tr class="memdesc:ac92f07ae5d32b312166a2b71cf50f06e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fully qualified name of the given cluster_id in give instance_id.  <a href="#ac92f07ae5d32b312166a2b71cf50f06e">More...</a><br /></td></tr>
<tr class="separator:ac92f07ae5d32b312166a2b71cf50f06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7780db83710aea2ff7f5d7024f5eb34"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#af7780db83710aea2ff7f5d7024f5eb34">AppProfileName</a> (std::string const &amp;instance_id, std::string const &amp;profile_id)</td></tr>
<tr class="separator:af7780db83710aea2ff7f5d7024f5eb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50920c09a6f964085bb86b14f53d75b"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::Instance &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#ac50920c09a6f964085bb86b14f53d75b">CreateInstance</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceConfig.html">InstanceConfig</a> instance_config)</td></tr>
<tr class="memdesc:ac50920c09a6f964085bb86b14f53d75b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of Cloud Bigtable.  <a href="#ac50920c09a6f964085bb86b14f53d75b">More...</a><br /></td></tr>
<tr class="separator:ac50920c09a6f964085bb86b14f53d75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef5f7d5ad7e675efa2ed7d1a359d226"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::Instance &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a4ef5f7d5ad7e675efa2ed7d1a359d226">AsyncCreateInstance</a> (CompletionQueue &amp;cq, bigtable::InstanceConfig instance_config)</td></tr>
<tr class="memdesc:a4ef5f7d5ad7e675efa2ed7d1a359d226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an instance (asynchronously).  <a href="#a4ef5f7d5ad7e675efa2ed7d1a359d226">More...</a><br /></td></tr>
<tr class="separator:a4ef5f7d5ad7e675efa2ed7d1a359d226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213dd25989a612adf21074ecb8a05d24"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::Cluster &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a213dd25989a612adf21074ecb8a05d24">CreateCluster</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ClusterConfig.html">ClusterConfig</a> cluster_config, std::string const &amp;instance_id, std::string const &amp;cluster_id)</td></tr>
<tr class="memdesc:a213dd25989a612adf21074ecb8a05d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Cluster of Cloud Bigtable.  <a href="#a213dd25989a612adf21074ecb8a05d24">More...</a><br /></td></tr>
<tr class="separator:a213dd25989a612adf21074ecb8a05d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada155307106edf1466bfc31e91f331aa"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::Cluster &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#ada155307106edf1466bfc31e91f331aa">AsyncCreateCluster</a> (CompletionQueue &amp;cq, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ClusterConfig.html">ClusterConfig</a> cluster_config, std::string const &amp;instance_id, std::string const &amp;cluster_id)</td></tr>
<tr class="memdesc:ada155307106edf1466bfc31e91f331aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new cluster (asynchronously).  <a href="#ada155307106edf1466bfc31e91f331aa">More...</a><br /></td></tr>
<tr class="separator:ada155307106edf1466bfc31e91f331aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b562a651dbff16f4d02f83b2172f77d"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::Instance &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a8b562a651dbff16f4d02f83b2172f77d">UpdateInstance</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceUpdateConfig.html">InstanceUpdateConfig</a> instance_update_config)</td></tr>
<tr class="memdesc:a8b562a651dbff16f4d02f83b2172f77d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update an existing instance of Cloud Bigtable.  <a href="#a8b562a651dbff16f4d02f83b2172f77d">More...</a><br /></td></tr>
<tr class="separator:a8b562a651dbff16f4d02f83b2172f77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43f3ac54f2914e8ffd2f294314fa874"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::Instance &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#ad43f3ac54f2914e8ffd2f294314fa874">AsyncUpdateInstance</a> (CompletionQueue &amp;cq, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceUpdateConfig.html">InstanceUpdateConfig</a> instance_update_config)</td></tr>
<tr class="memdesc:ad43f3ac54f2914e8ffd2f294314fa874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update an existing instance (asynchronously).  <a href="#ad43f3ac54f2914e8ffd2f294314fa874">More...</a><br /></td></tr>
<tr class="separator:ad43f3ac54f2914e8ffd2f294314fa874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a4b95b901129d28e74c17b4e293411"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceList.html">InstanceList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a73a4b95b901129d28e74c17b4e293411">ListInstances</a> ()</td></tr>
<tr class="memdesc:a73a4b95b901129d28e74c17b4e293411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the list of instances in the project.  <a href="#a73a4b95b901129d28e74c17b4e293411">More...</a><br /></td></tr>
<tr class="separator:a73a4b95b901129d28e74c17b4e293411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497b7b67b0682ecf37fbf16e7f85dd12"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceList.html">InstanceList</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a497b7b67b0682ecf37fbf16e7f85dd12">AsyncListInstances</a> (CompletionQueue &amp;cq)</td></tr>
<tr class="memdesc:a497b7b67b0682ecf37fbf16e7f85dd12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query (asynchronously) the list of instances in the project.  <a href="#a497b7b67b0682ecf37fbf16e7f85dd12">More...</a><br /></td></tr>
<tr class="separator:a497b7b67b0682ecf37fbf16e7f85dd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60844ae9110014889b77ee24129de5d5"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; google::bigtable::admin::v2::Instance &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a60844ae9110014889b77ee24129de5d5">GetInstance</a> (std::string const &amp;instance_id)</td></tr>
<tr class="memdesc:a60844ae9110014889b77ee24129de5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the details of <code>instance_id</code>.  <a href="#a60844ae9110014889b77ee24129de5d5">More...</a><br /></td></tr>
<tr class="separator:a60844ae9110014889b77ee24129de5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edb03b4ff9817f9cb4c34760eb878f4"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::Instance &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a8edb03b4ff9817f9cb4c34760eb878f4">AsyncGetInstance</a> (CompletionQueue &amp;cq, std::string const &amp;instance_id)</td></tr>
<tr class="memdesc:a8edb03b4ff9817f9cb4c34760eb878f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an asynchronous request to get information about an existing instance.  <a href="#a8edb03b4ff9817f9cb4c34760eb878f4">More...</a><br /></td></tr>
<tr class="separator:a8edb03b4ff9817f9cb4c34760eb878f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486006fc1866998ac8c9ae4d808572b1"><td class="memItemLeft" align="right" valign="top">Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a486006fc1866998ac8c9ae4d808572b1">DeleteInstance</a> (std::string const &amp;instance_id)</td></tr>
<tr class="memdesc:a486006fc1866998ac8c9ae4d808572b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the instances in the project.  <a href="#a486006fc1866998ac8c9ae4d808572b1">More...</a><br /></td></tr>
<tr class="separator:a486006fc1866998ac8c9ae4d808572b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1b5e0448cf42d42136f9b72f776b55"><td class="memItemLeft" align="right" valign="top">future&lt; Status &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a8a1b5e0448cf42d42136f9b72f776b55">AsyncDeleteInstance</a> (std::string const &amp;instance_id, CompletionQueue &amp;cq)</td></tr>
<tr class="memdesc:a8a1b5e0448cf42d42136f9b72f776b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an asynchronous request to delete an instance.  <a href="#a8a1b5e0448cf42d42136f9b72f776b55">More...</a><br /></td></tr>
<tr class="separator:a8a1b5e0448cf42d42136f9b72f776b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff94dfb0492c9c6c73e9b29857549020"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ClusterList.html">ClusterList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#aff94dfb0492c9c6c73e9b29857549020">ListClusters</a> ()</td></tr>
<tr class="memdesc:aff94dfb0492c9c6c73e9b29857549020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the list of clusters in an instance.  <a href="#aff94dfb0492c9c6c73e9b29857549020">More...</a><br /></td></tr>
<tr class="separator:aff94dfb0492c9c6c73e9b29857549020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429eacd3239d8e059e72a60f28e9789c"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ClusterList.html">ClusterList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a429eacd3239d8e059e72a60f28e9789c">ListClusters</a> (std::string const &amp;instance_id)</td></tr>
<tr class="memdesc:a429eacd3239d8e059e72a60f28e9789c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the list of clusters in an instance.  <a href="#a429eacd3239d8e059e72a60f28e9789c">More...</a><br /></td></tr>
<tr class="separator:a429eacd3239d8e059e72a60f28e9789c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e888585960bdc2ba9d4091b6f9dba0"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ClusterList.html">ClusterList</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a22e888585960bdc2ba9d4091b6f9dba0">AsyncListClusters</a> (CompletionQueue &amp;cq)</td></tr>
<tr class="memdesc:a22e888585960bdc2ba9d4091b6f9dba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query (asynchronously) the list of clusters in a project.  <a href="#a22e888585960bdc2ba9d4091b6f9dba0">More...</a><br /></td></tr>
<tr class="separator:a22e888585960bdc2ba9d4091b6f9dba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3126a48f82c262375e17c380b42240"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ClusterList.html">ClusterList</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#ada3126a48f82c262375e17c380b42240">AsyncListClusters</a> (CompletionQueue &amp;cq, std::string const &amp;instance_id)</td></tr>
<tr class="memdesc:ada3126a48f82c262375e17c380b42240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query (asynchronously) the list of clusters in an instance.  <a href="#ada3126a48f82c262375e17c380b42240">More...</a><br /></td></tr>
<tr class="separator:ada3126a48f82c262375e17c380b42240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe746ee1bcfd82bcbcf9e96d987e1597"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::Cluster &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#afe746ee1bcfd82bcbcf9e96d987e1597">UpdateCluster</a> (<a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ClusterConfig.html">ClusterConfig</a> cluster_config)</td></tr>
<tr class="memdesc:afe746ee1bcfd82bcbcf9e96d987e1597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update an existing cluster of Cloud Bigtable.  <a href="#afe746ee1bcfd82bcbcf9e96d987e1597">More...</a><br /></td></tr>
<tr class="separator:afe746ee1bcfd82bcbcf9e96d987e1597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcaa9ea86ece7275ca274f9ee7336c28"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::Cluster &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#afcaa9ea86ece7275ca274f9ee7336c28">AsyncUpdateCluster</a> (CompletionQueue &amp;cq, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ClusterConfig.html">ClusterConfig</a> cluster_config)</td></tr>
<tr class="memdesc:afcaa9ea86ece7275ca274f9ee7336c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update an existing cluster (asynchronously).  <a href="#afcaa9ea86ece7275ca274f9ee7336c28">More...</a><br /></td></tr>
<tr class="separator:afcaa9ea86ece7275ca274f9ee7336c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b639029d0568c3cb7b4efc62bceb3c"><td class="memItemLeft" align="right" valign="top">Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#ab1b639029d0568c3cb7b4efc62bceb3c">DeleteCluster</a> (std::string const &amp;instance_id, std::string const &amp;cluster_id)</td></tr>
<tr class="memdesc:ab1b639029d0568c3cb7b4efc62bceb3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the specified cluster of an instance in the project.  <a href="#ab1b639029d0568c3cb7b4efc62bceb3c">More...</a><br /></td></tr>
<tr class="separator:ab1b639029d0568c3cb7b4efc62bceb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf099d530d38e4732726b2df733e81a"><td class="memItemLeft" align="right" valign="top">future&lt; Status &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a3cf099d530d38e4732726b2df733e81a">AsyncDeleteCluster</a> (CompletionQueue &amp;cq, std::string const &amp;instance_id, std::string const &amp;cluster_id)</td></tr>
<tr class="memdesc:a3cf099d530d38e4732726b2df733e81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an asynchronous request to delete a cluster.  <a href="#a3cf099d530d38e4732726b2df733e81a">More...</a><br /></td></tr>
<tr class="separator:a3cf099d530d38e4732726b2df733e81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9f0face63f15e1fa3c741c01ae47b9"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; google::bigtable::admin::v2::Cluster &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#aba9f0face63f15e1fa3c741c01ae47b9">GetCluster</a> (std::string const &amp;instance_id, std::string const &amp;cluster_id)</td></tr>
<tr class="memdesc:aba9f0face63f15e1fa3c741c01ae47b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the specified cluster of an instance in the project.  <a href="#aba9f0face63f15e1fa3c741c01ae47b9">More...</a><br /></td></tr>
<tr class="separator:aba9f0face63f15e1fa3c741c01ae47b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea90d64bae3359a851541cbbab4b38f2"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::Cluster &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#aea90d64bae3359a851541cbbab4b38f2">AsyncGetCluster</a> (CompletionQueue &amp;cq, std::string const &amp;instance_id, std::string const &amp;cluster_id)</td></tr>
<tr class="memdesc:aea90d64bae3359a851541cbbab4b38f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an asynchronous request to get information about existing cluster of an instance.  <a href="#aea90d64bae3359a851541cbbab4b38f2">More...</a><br /></td></tr>
<tr class="separator:aea90d64bae3359a851541cbbab4b38f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7385d33a04215bff6ccfadc65967e64"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; google::bigtable::admin::v2::AppProfile &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#af7385d33a04215bff6ccfadc65967e64">CreateAppProfile</a> (std::string const &amp;instance_id, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1AppProfileConfig.html">AppProfileConfig</a> config)</td></tr>
<tr class="memdesc:af7385d33a04215bff6ccfadc65967e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new application profile.  <a href="#af7385d33a04215bff6ccfadc65967e64">More...</a><br /></td></tr>
<tr class="separator:af7385d33a04215bff6ccfadc65967e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8b58ec1eee4ce18246f34a8e4d09da"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::AppProfile &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#acb8b58ec1eee4ce18246f34a8e4d09da">AsyncCreateAppProfile</a> (CompletionQueue &amp;cq, std::string const &amp;instance_id, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1AppProfileConfig.html">AppProfileConfig</a> config)</td></tr>
<tr class="memdesc:acb8b58ec1eee4ce18246f34a8e4d09da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously create a new application profile.  <a href="#acb8b58ec1eee4ce18246f34a8e4d09da">More...</a><br /></td></tr>
<tr class="separator:acb8b58ec1eee4ce18246f34a8e4d09da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421351a3a87888a58db5afa09fdb872e"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; google::bigtable::admin::v2::AppProfile &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a421351a3a87888a58db5afa09fdb872e">GetAppProfile</a> (std::string const &amp;instance_id, std::string const &amp;profile_id)</td></tr>
<tr class="memdesc:a421351a3a87888a58db5afa09fdb872e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the detailed information about an existing application profile.  <a href="#a421351a3a87888a58db5afa09fdb872e">More...</a><br /></td></tr>
<tr class="separator:a421351a3a87888a58db5afa09fdb872e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f47a7cab41a26fe508c5d104a0e074"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::AppProfile &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a47f47a7cab41a26fe508c5d104a0e074">AsyncGetAppProfile</a> (CompletionQueue &amp;cq, std::string const &amp;instance_id, std::string const &amp;profile_id)</td></tr>
<tr class="memdesc:a47f47a7cab41a26fe508c5d104a0e074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously fetch the information about an existing application profile.  <a href="#a47f47a7cab41a26fe508c5d104a0e074">More...</a><br /></td></tr>
<tr class="separator:a47f47a7cab41a26fe508c5d104a0e074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70ab7a12c9e8c3f8fb405b9fbba3d15"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::AppProfile &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#ab70ab7a12c9e8c3f8fb405b9fbba3d15">UpdateAppProfile</a> (std::string const &amp;instance_id, std::string const &amp;profile_id, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1AppProfileUpdateConfig.html">AppProfileUpdateConfig</a> config)</td></tr>
<tr class="memdesc:ab70ab7a12c9e8c3f8fb405b9fbba3d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates an existing application profile.  <a href="#ab70ab7a12c9e8c3f8fb405b9fbba3d15">More...</a><br /></td></tr>
<tr class="separator:ab70ab7a12c9e8c3f8fb405b9fbba3d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef44a13d8825fd9c849dbe1f2eb4122"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::bigtable::admin::v2::AppProfile &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#aeef44a13d8825fd9c849dbe1f2eb4122">AsyncUpdateAppProfile</a> (CompletionQueue &amp;cq, std::string const &amp;instance_id, std::string const &amp;profile_id, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1AppProfileUpdateConfig.html">AppProfileUpdateConfig</a> config)</td></tr>
<tr class="memdesc:aeef44a13d8825fd9c849dbe1f2eb4122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates an application profile (asynchronously).  <a href="#aeef44a13d8825fd9c849dbe1f2eb4122">More...</a><br /></td></tr>
<tr class="separator:aeef44a13d8825fd9c849dbe1f2eb4122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a815e874b617e9e36eff23f4342fd9"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; std::vector&lt; google::bigtable::admin::v2::AppProfile &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a24a815e874b617e9e36eff23f4342fd9">ListAppProfiles</a> (std::string const &amp;instance_id)</td></tr>
<tr class="memdesc:a24a815e874b617e9e36eff23f4342fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">List the application profiles in an instance.  <a href="#a24a815e874b617e9e36eff23f4342fd9">More...</a><br /></td></tr>
<tr class="separator:a24a815e874b617e9e36eff23f4342fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9fda4ad10fa1afb5dcd65e6493fdb69"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; std::vector&lt; google::bigtable::admin::v2::AppProfile &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#ac9fda4ad10fa1afb5dcd65e6493fdb69">AsyncListAppProfiles</a> (CompletionQueue &amp;cq, std::string const &amp;instance_id)</td></tr>
<tr class="memdesc:ac9fda4ad10fa1afb5dcd65e6493fdb69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query (asynchronously) the list of app profiles in an instance.  <a href="#ac9fda4ad10fa1afb5dcd65e6493fdb69">More...</a><br /></td></tr>
<tr class="separator:ac9fda4ad10fa1afb5dcd65e6493fdb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492dfe843434806a85b74cb8a1030de4"><td class="memItemLeft" align="right" valign="top">Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a492dfe843434806a85b74cb8a1030de4">DeleteAppProfile</a> (std::string const &amp;instance_id, std::string const &amp;profile_id, bool ignore_warnings=true)</td></tr>
<tr class="memdesc:a492dfe843434806a85b74cb8a1030de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an existing application profile.  <a href="#a492dfe843434806a85b74cb8a1030de4">More...</a><br /></td></tr>
<tr class="separator:a492dfe843434806a85b74cb8a1030de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a97cbe3f4d39a0a94f5dde833f0bff"><td class="memItemLeft" align="right" valign="top">future&lt; Status &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#ad4a97cbe3f4d39a0a94f5dde833f0bff">AsyncDeleteAppProfile</a> (CompletionQueue &amp;cq, std::string const &amp;instance_id, std::string const &amp;profile_id, bool ignore_warnings=true)</td></tr>
<tr class="memdesc:ad4a97cbe3f4d39a0a94f5dde833f0bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously delete an existing application profile.  <a href="#ad4a97cbe3f4d39a0a94f5dde833f0bff">More...</a><br /></td></tr>
<tr class="separator:ad4a97cbe3f4d39a0a94f5dde833f0bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0c6da3d4afa4c638f46965515e518f"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; google::cloud::IamPolicy &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a3b0c6da3d4afa4c638f46965515e518f">GetIamPolicy</a> (std::string const &amp;instance_id)</td></tr>
<tr class="memdesc:a3b0c6da3d4afa4c638f46965515e518f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the policy for <code>instance_id</code>.  <a href="#a3b0c6da3d4afa4c638f46965515e518f">More...</a><br /></td></tr>
<tr class="separator:a3b0c6da3d4afa4c638f46965515e518f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e641fea08b9dbfecc160173d98b5ab"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; google::iam::v1::Policy &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a90e641fea08b9dbfecc160173d98b5ab">GetNativeIamPolicy</a> (std::string const &amp;instance_id)</td></tr>
<tr class="memdesc:a90e641fea08b9dbfecc160173d98b5ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the native policy for <code>instance_id</code>.  <a href="#a90e641fea08b9dbfecc160173d98b5ab">More...</a><br /></td></tr>
<tr class="separator:a90e641fea08b9dbfecc160173d98b5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42954b54c93ca7cd5f8c051896adb4a4"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::cloud::IamPolicy &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a42954b54c93ca7cd5f8c051896adb4a4">AsyncGetIamPolicy</a> (CompletionQueue &amp;cq, std::string const &amp;instance_id)</td></tr>
<tr class="memdesc:a42954b54c93ca7cd5f8c051896adb4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the policy for <code>instance_id</code>.  <a href="#a42954b54c93ca7cd5f8c051896adb4a4">More...</a><br /></td></tr>
<tr class="separator:a42954b54c93ca7cd5f8c051896adb4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37538eab822ae149ddf22ebc0a105067"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::iam::v1::Policy &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a37538eab822ae149ddf22ebc0a105067">AsyncGetNativeIamPolicy</a> (CompletionQueue &amp;cq, std::string const &amp;instance_id)</td></tr>
<tr class="memdesc:a37538eab822ae149ddf22ebc0a105067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the native IAM policy for <code>instance_id</code>.  <a href="#a37538eab822ae149ddf22ebc0a105067">More...</a><br /></td></tr>
<tr class="separator:a37538eab822ae149ddf22ebc0a105067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017a3f14072c8b96b473f281167b15b0"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; google::cloud::IamPolicy &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a017a3f14072c8b96b473f281167b15b0">SetIamPolicy</a> (std::string const &amp;instance_id, google::cloud::IamBindings const &amp;iam_bindings, std::string const &amp;etag=std::string{})</td></tr>
<tr class="memdesc:a017a3f14072c8b96b473f281167b15b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the IAM policy for an instance.  <a href="#a017a3f14072c8b96b473f281167b15b0">More...</a><br /></td></tr>
<tr class="separator:a017a3f14072c8b96b473f281167b15b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fb71752cecbb9ea9a4135f1ac4e55e"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; google::iam::v1::Policy &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#ab8fb71752cecbb9ea9a4135f1ac4e55e">SetIamPolicy</a> (std::string const &amp;instance_id, google::iam::v1::Policy const &amp;iam_policy)</td></tr>
<tr class="memdesc:ab8fb71752cecbb9ea9a4135f1ac4e55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the IAM policy for an instance.  <a href="#ab8fb71752cecbb9ea9a4135f1ac4e55e">More...</a><br /></td></tr>
<tr class="separator:ab8fb71752cecbb9ea9a4135f1ac4e55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98706bfd0b652b58224f74cf41b5d5a"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::cloud::IamPolicy &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#af98706bfd0b652b58224f74cf41b5d5a">AsyncSetIamPolicy</a> (CompletionQueue &amp;cq, std::string const &amp;instance_id, google::cloud::IamBindings const &amp;iam_bindings, std::string const &amp;etag=std::string{})</td></tr>
<tr class="memdesc:af98706bfd0b652b58224f74cf41b5d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sets the IAM policy for an instance.  <a href="#af98706bfd0b652b58224f74cf41b5d5a">More...</a><br /></td></tr>
<tr class="separator:af98706bfd0b652b58224f74cf41b5d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e97cb51b2fd1482a0108abd2b09cdfb"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; google::iam::v1::Policy &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a5e97cb51b2fd1482a0108abd2b09cdfb">AsyncSetIamPolicy</a> (CompletionQueue &amp;cq, std::string const &amp;instance_id, google::iam::v1::Policy const &amp;iam_policy)</td></tr>
<tr class="memdesc:a5e97cb51b2fd1482a0108abd2b09cdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sets the IAM policy for an instance.  <a href="#a5e97cb51b2fd1482a0108abd2b09cdfb">More...</a><br /></td></tr>
<tr class="separator:a5e97cb51b2fd1482a0108abd2b09cdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da026ac64422a6d31417155f641a739"><td class="memItemLeft" align="right" valign="top">StatusOr&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a3da026ac64422a6d31417155f641a739">TestIamPermissions</a> (std::string const &amp;instance_id, std::vector&lt; std::string &gt; const &amp;permissions)</td></tr>
<tr class="memdesc:a3da026ac64422a6d31417155f641a739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a permission set that the caller has on the specified instance.  <a href="#a3da026ac64422a6d31417155f641a739">More...</a><br /></td></tr>
<tr class="separator:a3da026ac64422a6d31417155f641a739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb23adb5d79de1e41528c1d621b3fe7b"><td class="memItemLeft" align="right" valign="top">future&lt; StatusOr&lt; std::vector&lt; std::string &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#abb23adb5d79de1e41528c1d621b3fe7b">AsyncTestIamPermissions</a> (CompletionQueue &amp;cq, std::string const &amp;instance_id, std::vector&lt; std::string &gt; const &amp;permissions)</td></tr>
<tr class="memdesc:abb23adb5d79de1e41528c1d621b3fe7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously obtains a permission set that the caller has on the specified instance.  <a href="#abb23adb5d79de1e41528c1d621b3fe7b">More...</a><br /></td></tr>
<tr class="separator:abb23adb5d79de1e41528c1d621b3fe7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements the APIs to administer Cloud Bigtable instances. </p>
<dl class="section user"><dt>Thread-safety</dt><dd>Instances of this class created via copy-construction or copy-assignment share the underlying pool of connections. Access to these copies via multiple threads is guaranteed to work. Two threads operating on the same instance of this class is not guaranteed to work.</dd></dl>
<dl class="section user"><dt>Cost</dt><dd>Creating a new object of type <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html" title="Implements the APIs to administer Cloud Bigtable instances.">InstanceAdmin</a></code> is comparable to creating a few objects of type <code>std::string</code> or a few objects of type <code>std::shared_ptr&lt;int&gt;</code>. The class represents a shallow handle to a remote object.</dd></dl>
<dl class="section user"><dt>Error Handling</dt><dd>This class uses <code>StatusOr&lt;T&gt;</code> to report errors. When an operation fails to perform its work the returned <code>StatusOr&lt;T&gt;</code> contains the error details. If the <code>ok()</code> member function in the <code>StatusOr&lt;T&gt;</code> returns <code>true</code> then it contains the expected result. Operations that do not return a value simply return a <code>google::cloud::Status</code> indicating success or the details of the error Please consult the <a href="#google::cloud::v1::StatusOr"><code>StatusOr&lt;T&gt;</code> documentation</a> for more details.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line"><span class="keyword">namespace </span>btadmin = google::bigtable::admin::v2;</div><div class="line">cbt::TableAdmin admin = ...;</div><div class="line">google::cloud::StatusOr&lt;btadmin::Table&gt; metadata = admin.GetTable(...);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (!metadata) {</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;Error fetching table metadata\n&quot;</span>;</div><div class="line">  <span class="keywordflow">return</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Use &quot;metadata&quot; as a smart pointer here, e.g.:</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The full table name is &quot;</span> &lt;&lt; table-&gt;name() &lt;&lt; <span class="stringliteral">&quot; the table has &quot;</span></div><div class="line">          &lt;&lt; table-&gt;column_families_size() &lt;&lt; <span class="stringliteral">&quot; column families\n&quot;</span>;</div></div><!-- fragment --><p>In addition, the <a class="el" href="index.html">main page</a> contains examples using <code>StatusOr&lt;T&gt;</code> to handle errors.</p>
<dl class="section user"><dt>Retry, Backoff, and Idempotency Policies</dt><dd>The library automatically retries requests that fail with transient errors, and uses <a href="https://cloud.google.com/storage/docs/exponential-backoff">truncated exponential backoff</a> to backoff between retries. The default policies are to continue retrying for up to 10 minutes. On each transient failure the backoff period is doubled, starting with an initial backoff of 100 milliseconds. The backoff period growth is truncated at 60 seconds. The default idempotency policy is to only retry idempotent operations. Note that most operations that change state are <b>not</b> idempotent.</dd></dl>
<p>The application can override these policies when constructing objects of this class. The documentation for the constructors show examples of this in action.</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://cloud.google.com/bigtable/">https://cloud.google.com/bigtable/</a> for an overview of Cloud Bigtable.</dd>
<dd>
<a href="https://cloud.google.com/bigtable/docs/overview">https://cloud.google.com/bigtable/docs/overview</a> for an overview of the Cloud Bigtable data model.</dd>
<dd>
<a href="https://cloud.google.com/bigtable/docs/instances-clusters-nodes">https://cloud.google.com/bigtable/docs/instances-clusters-nodes</a> for an introduction of the <a class="el" href="quickstart_8cc.html#a0ddf1224851353fc92bfbff6f499fa97">main</a> APIs into Cloud Bigtable.</dd>
<dd>
<a href="https://cloud.google.com/bigtable/docs/reference/service-apis-overview">https://cloud.google.com/bigtable/docs/reference/service-apis-overview</a> for an overview of the underlying Cloud Bigtable API.</dd>
<dd>
<a class="elRef" doxygen="/v/cmake-out/ci-fedora-install-31-clang-tidy/google/cloud/cloud.tag:https://googleapis.dev/google-cloud-common/master/" href="https://googleapis.dev/google-cloud-common/master/classgoogle_1_1cloud_1_1v1_1_1StatusOr.html">google::cloud::v1::StatusOr</a> for a description of the error reporting class used by this library.</dd>
<dd>
<code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1LimitedTimeRetryPolicy.html" title="Implement a simple &quot;keep trying for this time&quot; retry policy.">LimitedTimeRetryPolicy</a></code> and <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1LimitedErrorCountRetryPolicy.html" title="Implement a simple &quot;count errors and then stop&quot; retry policy.">LimitedErrorCountRetryPolicy</a></code> for alternative retry policies.</dd>
<dd>
<code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ExponentialBackoffPolicy.html" title="Implement a simple exponential backoff policy.">ExponentialBackoffPolicy</a></code> to configure different parameters for the exponential backoff policy.</dd>
<dd>
<code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1SafeIdempotentMutationPolicy.html" title="Implements a policy that only accepts truly idempotent mutations.">SafeIdempotentMutationPolicy</a></code> and <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1AlwaysRetryMutationPolicy.html" title="Implements a policy that retries all mutations.">AlwaysRetryMutationPolicy</a></code> for alternative idempotency policies. </dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8h_source.html#l00121">121</a> of file <a class="el" href="instance__admin_8h_source.html">instance_admin.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a11b793627d92457a0f7909b31f1dd247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b793627d92457a0f7909b31f1dd247">&#9670;&nbsp;</a></span>InstanceAdmin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::cloud::bigtable::v1::InstanceAdmin::InstanceAdmin </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdminClient.html">InstanceAdminClient</a> &gt;&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>the interface to create grpc stubs, report errors, etc. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8h_source.html#l00126">126</a> of file <a class="el" href="instance__admin_8h_source.html">instance_admin.h</a>.</p>

</div>
</div>
<a id="a35f86c97b5c2f667f98ba53376b9db2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f86c97b5c2f667f98ba53376b9db2d">&#9670;&nbsp;</a></span>InstanceAdmin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Policies&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::cloud::bigtable::v1::InstanceAdmin::InstanceAdmin </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdminClient.html">InstanceAdminClient</a> &gt;&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Policies &amp;&amp;...&#160;</td>
          <td class="paramname"><em>policies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html" title="Implements the APIs to administer Cloud Bigtable instances.">InstanceAdmin</a> using explicit policies to handle RPC errors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>the interface to create grpc stubs, report errors, etc. </td></tr>
    <tr><td class="paramname">policies</td><td>the set of policy overrides for this object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Policies</td><td>the types of the policies to override, the types must derive from one of the following types:<ul>
<li><code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1RPCBackoffPolicy.html" title="Define the interface for controlling how the Bigtable client backsoff from failed RPC operations.">RPCBackoffPolicy</a></code> how to backoff from a failed RPC. Currently only <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ExponentialBackoffPolicy.html" title="Implement a simple exponential backoff policy.">ExponentialBackoffPolicy</a></code> is implemented. You can also create your own policies that backoff using a different algorithm.</li>
<li><code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1RPCRetryPolicy.html" title="Define the interface for controlling how the Bigtable client retries RPC operations.">RPCRetryPolicy</a></code> for how long to retry failed RPCs. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1LimitedErrorCountRetryPolicy.html" title="Implement a simple &quot;count errors and then stop&quot; retry policy.">LimitedErrorCountRetryPolicy</a></code> to limit the number of failures allowed. Use <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1LimitedTimeRetryPolicy.html" title="Implement a simple &quot;keep trying for this time&quot; retry policy.">LimitedTimeRetryPolicy</a></code> to bound the time for any request. You can also create your own policies that combine time and error counts.</li>
<li><code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1PollingPolicy.html" title="Define the interface for providing asynchronous repetitive call rules.">PollingPolicy</a></code> for how long will the class wait for <code>google.longrunning.Operation</code> to complete. This class combines both the backoff policy for checking long running operations and the retry policy.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1GenericPollingPolicy.html" title="Construct a polling policy from existing Retry and Backoff policies.">GenericPollingPolicy</a>, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ExponentialBackoffPolicy.html" title="Implement a simple exponential backoff policy.">ExponentialBackoffPolicy</a>, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1LimitedErrorCountRetryPolicy.html" title="Implement a simple &quot;count errors and then stop&quot; retry policy.">LimitedErrorCountRetryPolicy</a>, <a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1LimitedTimeRetryPolicy.html" title="Implement a simple &quot;keep trying for this time&quot; retry policy.">LimitedTimeRetryPolicy</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8h_source.html#l00161">161</a> of file <a class="el" href="instance__admin_8h_source.html">instance_admin.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af7780db83710aea2ff7f5d7024f5eb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7780db83710aea2ff7f5d7024f5eb34">&#9670;&nbsp;</a></span>AppProfileName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string google::cloud::bigtable::v1::InstanceAdmin::AppProfileName </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>profile_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="instance__admin_8h_source.html#l00184">184</a> of file <a class="el" href="instance__admin_8h_source.html">instance_admin.h</a>.</p>

</div>
</div>
<a id="acb8b58ec1eee4ce18246f34a8e4d09da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb8b58ec1eee4ce18246f34a8e4d09da">&#9670;&nbsp;</a></span>AsyncCreateAppProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; google::bigtable::admin::v2::AppProfile &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::AsyncCreateAppProfile </td>
          <td>(</td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1AppProfileConfig.html">AppProfileConfig</a>&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously create a new application profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_id</td><td>the instance for the new application profile. </td></tr>
    <tr><td class="paramname">config</td><td>the configuration for the new application profile. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The proto describing the new application profile.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string <span class="keyword">const</span>&amp; instance_id, std::string <span class="keyword">const</span>&amp; profile_id) {</div><div class="line">    cbt::AppProfileConfig config =</div><div class="line">        cbt::AppProfileConfig::MultiClusterUseAny(profile_id);</div><div class="line">    future&lt;StatusOr&lt;google::bigtable::admin::v2::AppProfile&gt;&gt; profile_future =</div><div class="line">        instance_admin.AsyncCreateAppProfile(cq, instance_id, config);</div><div class="line"></div><div class="line">    <span class="comment">// Show how to perform additional work while the long running operation</span></div><div class="line">    <span class="comment">// completes. The application could use profile_future.then() instead.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Waiting for app_profile creation to complete &quot;</span> &lt;&lt; std::flush;</div><div class="line">    profile_future.wait_for(std::chrono::seconds(2));</div><div class="line">    std::cout &lt;&lt; <span class="charliteral">&#39;.&#39;</span> &lt;&lt; std::flush;</div><div class="line">    <span class="keyword">auto</span> app_profile = profile_future.get();</div><div class="line">    <span class="keywordflow">if</span> (!app_profile) <span class="keywordflow">throw</span> std::runtime_error(app_profile.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;DONE, details=&quot;</span> &lt;&lt; app_profile-&gt;DebugString() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00573">573</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="ada155307106edf1466bfc31e91f331aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada155307106edf1466bfc31e91f331aa">&#9670;&nbsp;</a></span>AsyncCreateCluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; google::bigtable::admin::v2::Cluster &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::AsyncCreateCluster </td>
          <td>(</td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ClusterConfig.html">ClusterConfig</a>&#160;</td>
          <td class="paramname"><em>cluster_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>cluster_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new cluster (asynchronously). </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">cluster_config</td><td>a description of the new cluster to be created. </td></tr>
    <tr><td class="paramname">instance_id</td><td>the id of the instance in the project </td></tr>
    <tr><td class="paramname">cluster_id</td><td>the id of the cluster in the project that needs to be created. It must be between 6 and 30 characters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future satisfied when either (a) the cluster is created or (b) a permanent error occurs or (c) polling or retry policy has been exhausted.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string <span class="keyword">const</span>&amp; instance_id, std::string <span class="keyword">const</span>&amp; cluster_id,</div><div class="line">     std::string <span class="keyword">const</span>&amp; zone) {</div><div class="line">    cbt::ClusterConfig cluster_config =</div><div class="line">        cbt::ClusterConfig(zone, 3, cbt::ClusterConfig::HDD);</div><div class="line">    future&lt;StatusOr&lt;google::bigtable::admin::v2::Cluster&gt;&gt; cluster_future =</div><div class="line">        instance_admin.AsyncCreateCluster(cq, cluster_config, instance_id,</div><div class="line">                                          cluster_id);</div><div class="line">    <span class="comment">// Show how to perform additional work while the long running operation</span></div><div class="line">    <span class="comment">// completes. The application could use future.then() instead.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Waiting for cluster creation to complete &quot;</span> &lt;&lt; std::flush;</div><div class="line">    cluster_future.wait_for(std::chrono::seconds(2));</div><div class="line">    std::cout &lt;&lt; <span class="charliteral">&#39;.&#39;</span> &lt;&lt; std::flush;</div><div class="line">    <span class="keyword">auto</span> cluster = cluster_future.get();</div><div class="line">    <span class="keywordflow">if</span> (!cluster) <span class="keywordflow">throw</span> std::runtime_error(cluster.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;DONE, details=&quot;</span> &lt;&lt; cluster-&gt;DebugString() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00185">185</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a4ef5f7d5ad7e675efa2ed7d1a359d226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef5f7d5ad7e675efa2ed7d1a359d226">&#9670;&nbsp;</a></span>AsyncCreateInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; google::bigtable::admin::v2::Instance &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::AsyncCreateInstance </td>
          <td>(</td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bigtable::InstanceConfig&#160;</td>
          <td class="paramname"><em>instance_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an instance (asynchronously). </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_config</td><td>the desired configuration of the instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future satisfied when either (a) the cluster is created or (b) a permanent error occurs or (c) polling or retry policy has been exhausted.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string <span class="keyword">const</span>&amp; instance_id, std::string <span class="keyword">const</span>&amp; zone) {</div><div class="line">    std::string display_name(<span class="stringliteral">&quot;Put description here&quot;</span>);</div><div class="line">    std::string cluster_id = instance_id + <span class="stringliteral">&quot;-c1&quot;</span>;</div><div class="line">    cbt::ClusterConfig cluster_config =</div><div class="line">        cbt::ClusterConfig(zone, 3, cbt::ClusterConfig::HDD);</div><div class="line">    cbt::InstanceConfig config(instance_id, display_name,</div><div class="line">                               {{cluster_id, cluster_config}});</div><div class="line">    config.set_type(cbt::InstanceConfig::PRODUCTION);</div><div class="line"></div><div class="line">    future&lt;StatusOr&lt;google::bigtable::admin::v2::Instance&gt;&gt; instance_future =</div><div class="line">        instance_admin.AsyncCreateInstance(cq, config);</div><div class="line">    <span class="comment">// Show how to perform additional work while the long running operation</span></div><div class="line">    <span class="comment">// completes. The application could use future.then() instead.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Waiting for instance creation to complete &quot;</span> &lt;&lt; std::flush;</div><div class="line">    instance_future.wait_for(std::chrono::seconds(2));</div><div class="line">    std::cout &lt;&lt; <span class="charliteral">&#39;.&#39;</span> &lt;&lt; std::flush;</div><div class="line">    <span class="keyword">auto</span> instance = instance_future.get();</div><div class="line">    <span class="keywordflow">if</span> (!instance) <span class="keywordflow">throw</span> std::runtime_error(instance.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;DONE, details=&quot;</span> &lt;&lt; instance-&gt;name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00146">146</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="ad4a97cbe3f4d39a0a94f5dde833f0bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a97cbe3f4d39a0a94f5dde833f0bff">&#9670;&nbsp;</a></span>AsyncDeleteAppProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; Status &gt; google::cloud::bigtable::v1::InstanceAdmin::AsyncDeleteAppProfile </td>
          <td>(</td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>profile_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_warnings</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously delete an existing application profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_id</td><td>the instance to look the profile in. </td></tr>
    <tr><td class="paramname">profile_id</td><td>the id of the profile within that instance. </td></tr>
    <tr><td class="paramname">ignore_warnings</td><td>if true, ignore safety checks when deleting the application profile. This value is to to <code>true</code> by default. Passing <code>false</code> causes this function to fail even when no operations are pending.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future satisfied when either (a) the app profile is deleted or (b) an unretriable error occurs or (c) retry policy has been exhausted.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string <span class="keyword">const</span>&amp; instance_id, std::string <span class="keyword">const</span>&amp; app_profile_id) {</div><div class="line">    future&lt;google::cloud::Status&gt; status_future =</div><div class="line">        instance_admin.AsyncDeleteAppProfile(cq, instance_id, app_profile_id,</div><div class="line">                                             <span class="comment">/*ignore_warnings=*/</span><span class="keyword">true</span>);</div><div class="line"></div><div class="line">    google::cloud::Status status = status_future.get();</div><div class="line">    <span class="keywordflow">if</span> (!status.ok()) <span class="keywordflow">throw</span> std::runtime_error(status.message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Profile &quot;</span> &lt;&lt; app_profile_id &lt;&lt; <span class="stringliteral">&quot; successfully deleted\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00753">753</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a3cf099d530d38e4732726b2df733e81a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf099d530d38e4732726b2df733e81a">&#9670;&nbsp;</a></span>AsyncDeleteCluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; Status &gt; google::cloud::bigtable::v1::InstanceAdmin::AsyncDeleteCluster </td>
          <td>(</td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>cluster_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends an asynchronous request to delete a cluster. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_id</td><td>the id of the instance in the project. </td></tr>
    <tr><td class="paramname">cluster_id</td><td>the id of the cluster in the project that needs to be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future that will be satisfied when the request succeeds or the retry policy expires.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string <span class="keyword">const</span>&amp; instance_id, std::string <span class="keyword">const</span>&amp; cluster_id) {</div><div class="line">    future&lt;google::cloud::Status&gt; status_future =</div><div class="line">        instance_admin.AsyncDeleteCluster(cq, instance_id, cluster_id);</div><div class="line"></div><div class="line">    google::cloud::Status status = status_future.get();</div><div class="line">    <span class="keywordflow">if</span> (!status.ok()) <span class="keywordflow">throw</span> std::runtime_error(status.message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Cluster &quot;</span> &lt;&lt; cluster_id &lt;&lt; <span class="stringliteral">&quot; successfully deleted\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00304">304</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a8a1b5e0448cf42d42136f9b72f776b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1b5e0448cf42d42136f9b72f776b55">&#9670;&nbsp;</a></span>AsyncDeleteInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; Status &gt; google::cloud::bigtable::v1::InstanceAdmin::AsyncDeleteInstance </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes an asynchronous request to delete an instance. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the id of the instance in the project to be deleted. </td></tr>
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string <span class="keyword">const</span>&amp; instance_id) {</div><div class="line">    future&lt;google::cloud::Status&gt; status_future =</div><div class="line">        instance_admin.AsyncDeleteInstance(instance_id, cq);</div><div class="line"></div><div class="line">    google::cloud::Status status = status_future.get();</div><div class="line">    <span class="keywordflow">if</span> (!status.ok()) <span class="keywordflow">throw</span> std::runtime_error(status.message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Instance &quot;</span> &lt;&lt; instance_id &lt;&lt; <span class="stringliteral">&quot; successfully deleted\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00332">332</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a47f47a7cab41a26fe508c5d104a0e074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f47a7cab41a26fe508c5d104a0e074">&#9670;&nbsp;</a></span>AsyncGetAppProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; google::bigtable::admin::v2::AppProfile &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::AsyncGetAppProfile </td>
          <td>(</td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>profile_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously fetch the information about an existing application profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_id</td><td>the instance to look the profile in. </td></tr>
    <tr><td class="paramname">profile_id</td><td>the id of the profile within that instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future satisfied when either (a) the profile is fetched or (b) an unretriable error occurs or (c) retry policy has been exhausted.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is read-only and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string <span class="keyword">const</span>&amp; instance_id, std::string <span class="keyword">const</span>&amp; app_profile_id) {</div><div class="line">    future&lt;void&gt; <span class="keyword">final</span> =</div><div class="line">        instance_admin.AsyncGetAppProfile(cq, instance_id, app_profile_id)</div><div class="line">            .then([](future&lt;StatusOr&lt;google::bigtable::admin::v2::AppProfile&gt;&gt;</div><div class="line">                         f) {</div><div class="line">              <span class="keyword">auto</span> app_profile = f.get();</div><div class="line">              <span class="keywordflow">if</span> (!app_profile) {</div><div class="line">                <span class="keywordflow">throw</span> std::runtime_error(app_profile.status().message());</div><div class="line">              }</div><div class="line">              std::cout &lt;&lt; <span class="stringliteral">&quot;GetAppProfile details : &quot;</span></div><div class="line">                        &lt;&lt; app_profile-&gt;DebugString() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">            });</div><div class="line"></div><div class="line">    <span class="keyword">final</span>.get();  <span class="comment">// block to keep the example simple</span></div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00614">614</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="aea90d64bae3359a851541cbbab4b38f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea90d64bae3359a851541cbbab4b38f2">&#9670;&nbsp;</a></span>AsyncGetCluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; btadmin::Cluster &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::AsyncGetCluster </td>
          <td>(</td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>cluster_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends an asynchronous request to get information about existing cluster of an instance. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the id of the instance in the project. </td></tr>
    <tr><td class="paramname">cluster_id</td><td>the id of the cluster in the project that needs to be retrieved. </td></tr>
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future that will be satisfied when the request succeeds or the retry policy expires. In the first case, the future will contain the response from the service. In the second the future is satisfied with an exception.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is read-only and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string <span class="keyword">const</span>&amp; instance_id, std::string <span class="keyword">const</span>&amp; cluster_id) {</div><div class="line">    future&lt;StatusOr&lt;google::bigtable::admin::v2::Cluster&gt;&gt; cluster_future =</div><div class="line">        instance_admin.AsyncGetCluster(cq, instance_id, cluster_id);</div><div class="line"></div><div class="line">    future&lt;google::cloud::Status&gt; <span class="keyword">final</span> = cluster_future.then(</div><div class="line">        [](future&lt;StatusOr&lt;google::bigtable::admin::v2::Cluster&gt;&gt; f) {</div><div class="line">          StatusOr&lt;google::bigtable::admin::v2::Cluster&gt; cluster = f.get();</div><div class="line">          <span class="keywordflow">if</span> (!cluster) <span class="keywordflow">throw</span> std::runtime_error(cluster.status().message());</div><div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot;GetCluster details : &quot;</span> &lt;&lt; cluster-&gt;DebugString()</div><div class="line">                    &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">          <span class="keywordflow">return</span> google::cloud::Status();</div><div class="line">        });</div><div class="line"></div><div class="line">    <span class="keyword">final</span>.get();  <span class="comment">// block to keep the example simple</span></div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00378">378</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a42954b54c93ca7cd5f8c051896adb4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42954b54c93ca7cd5f8c051896adb4a4">&#9670;&nbsp;</a></span>AsyncGetIamPolicy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; google::cloud::IamPolicy &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::AsyncGetIamPolicy </td>
          <td>(</td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously gets the policy for <code>instance_id</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_id</td><td>the instance to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future satisfied when either (a) the policy is fetched or (b) an unretriable error occurs or (c) retry policy has been exhausted.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>this function is deprecated; it doesn't support conditional bindings and will not support any other features to come; please use <code>AsyncGetNativeIamPolicy</code> instead. TODO(#2857): Use proper deprecation attributes.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is read-only and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string <span class="keyword">const</span>&amp; instance_id) {</div><div class="line">    future&lt;StatusOr&lt;google::cloud::IamPolicy&gt;&gt; policy_future =</div><div class="line">        instance_admin.AsyncGetIamPolicy(cq, instance_id);</div><div class="line"></div><div class="line">    future&lt;void&gt; <span class="keyword">final</span> =</div><div class="line">        policy_future.then([](future&lt;StatusOr&lt;google::cloud::IamPolicy&gt;&gt; f) {</div><div class="line">          StatusOr&lt;google::cloud::IamPolicy&gt; iam_policy = f.get();</div><div class="line">          <span class="keywordflow">if</span> (!iam_policy) {</div><div class="line">            <span class="keywordflow">throw</span> std::runtime_error(iam_policy.status().message());</div><div class="line">          }</div><div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot;IamPolicy details : &quot;</span> &lt;&lt; *iam_policy &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">        });</div><div class="line"></div><div class="line">    <span class="keyword">final</span>.get();  <span class="comment">// block to keep the example simple</span></div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00832">832</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a8edb03b4ff9817f9cb4c34760eb878f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8edb03b4ff9817f9cb4c34760eb878f4">&#9670;&nbsp;</a></span>AsyncGetInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; btadmin::Instance &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::AsyncGetInstance </td>
          <td>(</td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends an asynchronous request to get information about an existing instance. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the id of the instance in the project that to be retrieved. </td></tr>
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future that will be satisfied when the request succeeds or the retry policy expires. In the first case, the future will contain the response from the service. In the second the future is satisfied with an exception.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is read-only and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string <span class="keyword">const</span>&amp; instance_id) {</div><div class="line">    future&lt;StatusOr&lt;google::bigtable::admin::v2::Instance&gt;&gt; instance_future =</div><div class="line">        instance_admin.AsyncGetInstance(cq, instance_id);</div><div class="line"></div><div class="line">    future&lt;google::cloud::Status&gt; <span class="keyword">final</span> = instance_future.then(</div><div class="line">        [](future&lt;StatusOr&lt;google::bigtable::admin::v2::Instance&gt;&gt; f) {</div><div class="line">          <span class="keyword">auto</span> instance = f.get();</div><div class="line">          <span class="keywordflow">if</span> (!instance) <span class="keywordflow">throw</span> std::runtime_error(instance.status().message());</div><div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot;GetInstance details : &quot;</span> &lt;&lt; instance-&gt;DebugString()</div><div class="line">                    &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">          <span class="keywordflow">return</span> google::cloud::Status();</div><div class="line">        });</div><div class="line"></div><div class="line">    <span class="keyword">final</span>.get();  <span class="comment">// block to keep the example simple</span></div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00270">270</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a37538eab822ae149ddf22ebc0a105067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37538eab822ae149ddf22ebc0a105067">&#9670;&nbsp;</a></span>AsyncGetNativeIamPolicy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; google::iam::v1::Policy &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::AsyncGetNativeIamPolicy </td>
          <td>(</td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously gets the native IAM policy for <code>instance_id</code>. </p>
<p>This is the preferred way to <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a42954b54c93ca7cd5f8c051896adb4a4" title="Asynchronously gets the policy for instance_id.">AsyncGetIamPolicy()</a></code>. This is more closely coupled to the underlying protocol, enable more actions and is more likely to tolerate future protocol changes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_id</td><td>the instance to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future satisfied when either (a) the policy is fetched or (b) an unretriable error occurs or (c) retry policy has been exhausted.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is read-only and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  <span class="keyword">using</span> google::iam::v1::Policy;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string <span class="keyword">const</span>&amp; instance_id) {</div><div class="line">    future&lt;StatusOr&lt;google::iam::v1::Policy&gt;&gt; policy_future =</div><div class="line">        instance_admin.AsyncGetNativeIamPolicy(cq, instance_id);</div><div class="line"></div><div class="line">    future&lt;void&gt; <span class="keyword">final</span> =</div><div class="line">        policy_future.then([](future&lt;StatusOr&lt;google::iam::v1::Policy&gt;&gt; f) {</div><div class="line">          StatusOr&lt;google::iam::v1::Policy&gt; iam = f.get();</div><div class="line">          <span class="keywordflow">if</span> (!iam) <span class="keywordflow">throw</span> std::runtime_error(iam.status().message());</div><div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot;IamPolicy details : &quot;</span> &lt;&lt; iam-&gt;DebugString() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">        });</div><div class="line"></div><div class="line">    <span class="keyword">final</span>.get();  <span class="comment">// block to keep the example simple</span></div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00863">863</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="ac9fda4ad10fa1afb5dcd65e6493fdb69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9fda4ad10fa1afb5dcd65e6493fdb69">&#9670;&nbsp;</a></span>AsyncListAppProfiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; std::vector&lt; btadmin::AppProfile &gt; &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::AsyncListAppProfiles </td>
          <td>(</td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query (asynchronously) the list of app profiles in an instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_id</td><td>the instance in a project. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of app profiles.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is read-only and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id) {</div><div class="line">    StatusOr&lt;cbt::ClusterList&gt; clusters =</div><div class="line">        instance_admin.ListClusters(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!clusters) <span class="keywordflow">throw</span> std::runtime_error(clusters.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Cluster Name List\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; cluster : clusters-&gt;clusters) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Cluster Name:&quot;</span> &lt;&lt; cluster.name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (!clusters-&gt;failed_locations.empty()) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;The Cloud Bigtable service reports that the following &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;locations are temporarily unavailable and no information &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;about clusters in these locations can be obtained:\n&quot;</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; failed_location : clusters-&gt;failed_locations) {</div><div class="line">        std::cout &lt;&lt; failed_location &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00710">710</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a22e888585960bdc2ba9d4091b6f9dba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e888585960bdc2ba9d4091b6f9dba0">&#9670;&nbsp;</a></span>AsyncListClusters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ClusterList.html">ClusterList</a> &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::AsyncListClusters </td>
          <td>(</td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query (asynchronously) the list of clusters in a project. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In some circumstances Cloud Bigtable may be unable to obtain the full list of clusters, typically because some transient failure has made specific zones unavailable. In this cases the service returns a separate list of <code>failed_locations</code> that represent the unavailable zones. Applications may want to retry the operation after the transient conditions have cleared.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of clusters. It is possible that some zones are not currently available for querying. In that case this function returns the list of failed locations in the <code>projects/&lt;project&gt;/locations/&lt;zone_id&gt;</code> format.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is read-only and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id) {</div><div class="line">    StatusOr&lt;cbt::ClusterList&gt; clusters =</div><div class="line">        instance_admin.ListClusters(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!clusters) <span class="keywordflow">throw</span> std::runtime_error(clusters.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Cluster Name List\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; cluster : clusters-&gt;clusters) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Cluster Name:&quot;</span> &lt;&lt; cluster.name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (!clusters-&gt;failed_locations.empty()) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;The Cloud Bigtable service reports that the following &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;locations are temporarily unavailable and no information &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;about clusters in these locations can be obtained:\n&quot;</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; failed_location : clusters-&gt;failed_locations) {</div><div class="line">        std::cout &lt;&lt; failed_location &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00449">449</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="ada3126a48f82c262375e17c380b42240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3126a48f82c262375e17c380b42240">&#9670;&nbsp;</a></span>AsyncListClusters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ClusterList.html">ClusterList</a> &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::AsyncListClusters </td>
          <td>(</td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query (asynchronously) the list of clusters in an instance. </p>
<dl class="section note"><dt>Note</dt><dd>In some circumstances Cloud Bigtable may be unable to obtain the full list of clusters, typically because some transient failure has made specific zones unavailable. In this cases the service returns a separate list of <code>failed_locations</code> that represent the unavailable zones. Applications may want to retry the operation after the transient conditions have cleared.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_id</td><td>the instance in a project. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of clusters. It is possible that some zones are not currently available for querying. In that case this function returns the list of failed locations in the <code>projects/&lt;project&gt;/locations/&lt;zone_id&gt;</code> format.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is read-only and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id) {</div><div class="line">    StatusOr&lt;cbt::ClusterList&gt; clusters =</div><div class="line">        instance_admin.ListClusters(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!clusters) <span class="keywordflow">throw</span> std::runtime_error(clusters.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Cluster Name List\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; cluster : clusters-&gt;clusters) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Cluster Name:&quot;</span> &lt;&lt; cluster.name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (!clusters-&gt;failed_locations.empty()) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;The Cloud Bigtable service reports that the following &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;locations are temporarily unavailable and no information &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;about clusters in these locations can be obtained:\n&quot;</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; failed_location : clusters-&gt;failed_locations) {</div><div class="line">        std::cout &lt;&lt; failed_location &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00454">454</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a497b7b67b0682ecf37fbf16e7f85dd12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497b7b67b0682ecf37fbf16e7f85dd12">&#9670;&nbsp;</a></span>AsyncListInstances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceList.html">InstanceList</a> &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::AsyncListInstances </td>
          <td>(</td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query (asynchronously) the list of instances in the project. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In some circumstances Cloud Bigtable may be unable to obtain the full list of instances, typically because some transient failure has made specific zones unavailable. In this cases the service returns a separate list of <code>failed_locations</code> that represent the unavailable zones. Applications may want to retry the operation after the transient conditions have cleared.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of instances. It is possible that some zones are not currently available for querying. In that case this function returns the list of failed locations in the <code>projects/&lt;project&gt;/locations/&lt;zone_id&gt;</code> format.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is read-only and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq) {</div><div class="line">    future&lt;google::cloud::StatusOr&lt;cbt::InstanceList&gt;&gt; instances_future =</div><div class="line">        instance_admin.AsyncListInstances(cq);</div><div class="line"></div><div class="line">    future&lt;void&gt; <span class="keyword">final</span> =</div><div class="line">        instances_future.then([](future&lt;StatusOr&lt;cbt::InstanceList&gt;&gt; f) {</div><div class="line">          <span class="keyword">auto</span> instance_list = f.get();</div><div class="line">          <span class="keywordflow">if</span> (!instance_list) {</div><div class="line">            <span class="keywordflow">throw</span> std::runtime_error(instance_list.status().message());</div><div class="line">          }</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; instance : instance_list-&gt;instances) {</div><div class="line">            std::cout &lt;&lt; instance.name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">          }</div><div class="line">          <span class="keywordflow">if</span> (!instance_list-&gt;failed_locations.empty()) {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;The Cloud Bigtable service reports that it could not &quot;</span></div><div class="line">                         <span class="stringliteral">&quot;retrieve data for the following zones:\n&quot;</span>;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; failed_location :</div><div class="line">                 instance_list-&gt;failed_locations) {</div><div class="line">              std::cout &lt;&lt; failed_location &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">            }</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;This is typically a transient condition, try again &quot;</span></div><div class="line">                         <span class="stringliteral">&quot;later.\n&quot;</span>;</div><div class="line">          }</div><div class="line">        });</div><div class="line">    <span class="keyword">final</span>.get();  <span class="comment">// block to keep the example simple</span></div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00085">85</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="af98706bfd0b652b58224f74cf41b5d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98706bfd0b652b58224f74cf41b5d5a">&#9670;&nbsp;</a></span>AsyncSetIamPolicy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; google::cloud::IamPolicy &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::AsyncSetIamPolicy </td>
          <td>(</td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">google::cloud::IamBindings const &amp;&#160;</td>
          <td class="paramname"><em>iam_bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>etag</em> = <code>std::string{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously sets the IAM policy for an instance. </p>
<p>Applications can provide the <code>etag</code> to implement optimistic concurrency control. If <code>etag</code> is not empty, the server will reject calls where the provided ETag does not match the ETag value stored in the server.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_id</td><td>which instance to set the IAM policy for. </td></tr>
    <tr><td class="paramname">iam_bindings</td><td>IamBindings object containing role and members. </td></tr>
    <tr><td class="paramname">etag</td><td>the expected ETag value for the current policy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future satisfied when either (a) the policy is created or (b) an unretriable error occurs or (c) retry policy has been exhausted.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>this function is deprecated; it doesn't support conditional bindings and will not support any other features to come; please use the overload for <code>google::iam::v1::Policy</code> instead. TODO(#2857): Use proper deprecation attributes.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>ETags are currently not used by Cloud Bigtable.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#a189f3617e1538d77374afc6a30db809f">google::cloud::IamPolicy</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string <span class="keyword">const</span>&amp; instance_id, std::string <span class="keyword">const</span>&amp; role,</div><div class="line">     std::string <span class="keyword">const</span>&amp; member) {</div><div class="line">    future&lt;StatusOr&lt;IamPolicy&gt;&gt; updated_future =</div><div class="line">        instance_admin.AsyncGetIamPolicy(cq, instance_id)</div><div class="line">            .then([cq, instance_admin, role, member, instance_id](</div><div class="line">                      future&lt;StatusOr&lt;IamPolicy&gt;&gt; current_future) <span class="keyword">mutable</span> {</div><div class="line">              <span class="keyword">auto</span> current = current_future.get();</div><div class="line">              <span class="keywordflow">if</span> (!current) {</div><div class="line">                <span class="keywordflow">return</span> google::cloud::make_ready_future&lt;StatusOr&lt;IamPolicy&gt;&gt;(</div><div class="line">                    current.status());</div><div class="line">              }</div><div class="line">              google::cloud::IamBindings bindings = current-&gt;bindings;</div><div class="line">              bindings.AddMember(role, member);</div><div class="line">              <span class="keywordflow">return</span> instance_admin.AsyncSetIamPolicy(cq, instance_id, bindings,</div><div class="line">                                                      current-&gt;etag);</div><div class="line">            });</div><div class="line">    <span class="comment">// Show how to perform additional work while the long running operation</span></div><div class="line">    <span class="comment">// completes. The application could use future.then() instead.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Waiting for IAM policy update to complete &quot;</span> &lt;&lt; std::flush;</div><div class="line">    updated_future.wait_for(std::chrono::seconds(2));</div><div class="line">    <span class="keyword">auto</span> result = updated_future.get();</div><div class="line">    std::cout &lt;&lt; <span class="charliteral">&#39;.&#39;</span> &lt;&lt; std::flush;</div><div class="line">    <span class="keywordflow">if</span> (!result) <span class="keywordflow">throw</span> std::runtime_error(result.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;DONE, the IAM Policy for &quot;</span> &lt;&lt; instance_id &lt;&lt; <span class="stringliteral">&quot; is\n&quot;</span></div><div class="line">              &lt;&lt; *result &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00947">947</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a5e97cb51b2fd1482a0108abd2b09cdfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e97cb51b2fd1482a0108abd2b09cdfb">&#9670;&nbsp;</a></span>AsyncSetIamPolicy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; google::iam::v1::Policy &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::AsyncSetIamPolicy </td>
          <td>(</td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">google::iam::v1::Policy const &amp;&#160;</td>
          <td class="paramname"><em>iam_policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously sets the IAM policy for an instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_id</td><td>which instance to set the IAM policy for. </td></tr>
    <tr><td class="paramname">iam_policy</td><td>google::iam::v1::Policy object containing role and members. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future satisfied when either (a) the policy is created or (b) an unretriable error occurs or (c) retry policy has been exhausted.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>ETags are currently not used by Cloud Bigtable.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  <span class="keyword">using</span> google::iam::v1::Policy;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string <span class="keyword">const</span>&amp; instance_id, std::string <span class="keyword">const</span>&amp; role,</div><div class="line">     std::string <span class="keyword">const</span>&amp; member) {</div><div class="line">    future&lt;StatusOr&lt;google::iam::v1::Policy&gt;&gt; updated_future =</div><div class="line">        instance_admin.AsyncGetNativeIamPolicy(cq, instance_id)</div><div class="line">            .then([cq, instance_admin, role, member,</div><div class="line">                   instance_id](future&lt;StatusOr&lt;google::iam::v1::Policy&gt;&gt;</div><div class="line">                                    current_future) <span class="keyword">mutable</span> {</div><div class="line">              <span class="keyword">auto</span> current = current_future.get();</div><div class="line">              <span class="keywordflow">if</span> (!current) {</div><div class="line">                <span class="keywordflow">return</span> google::cloud::make_ready_future&lt;</div><div class="line">                    StatusOr&lt;google::iam::v1::Policy&gt;&gt;(current.status());</div><div class="line">              }</div><div class="line">              <span class="comment">// This example adds the member to all existing bindings for</span></div><div class="line">              <span class="comment">// that role. If there are no such bindgs, it adds a new one.</span></div><div class="line">              <span class="comment">// This might not be what the user wants, e.g. in case of</span></div><div class="line">              <span class="comment">// conditional bindings.</span></div><div class="line">              <span class="keywordtype">size_t</span> num_added = 0;</div><div class="line">              <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; binding : *current-&gt;mutable_bindings()) {</div><div class="line">                <span class="keywordflow">if</span> (binding.role() == role) {</div><div class="line">                  binding.add_members(member);</div><div class="line">                  ++num_added;</div><div class="line">                }</div><div class="line">              }</div><div class="line">              <span class="keywordflow">if</span> (num_added == 0) {</div><div class="line">                *current-&gt;add_bindings() = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#a97d1cefbc6bd7f002a83344476bd4dc3">cbt::IamBinding</a>(role, {member});</div><div class="line">              }</div><div class="line">              <span class="keywordflow">return</span> instance_admin.AsyncSetIamPolicy(cq, instance_id,</div><div class="line">                                                      *current);</div><div class="line">            });</div><div class="line">    <span class="comment">// Show how to perform additional work while the long running operation</span></div><div class="line">    <span class="comment">// completes. The application could use future.then() instead.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Waiting for IAM policy update to complete &quot;</span> &lt;&lt; std::flush;</div><div class="line">    updated_future.wait_for(std::chrono::seconds(2));</div><div class="line">    <span class="keyword">auto</span> result = updated_future.get();</div><div class="line">    std::cout &lt;&lt; <span class="charliteral">&#39;.&#39;</span> &lt;&lt; std::flush;</div><div class="line">    <span class="keywordflow">if</span> (!result) <span class="keywordflow">throw</span> std::runtime_error(result.status().message());</div><div class="line">    <span class="keyword">using</span> cbt::operator&lt;&lt;;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;DONE, the IAM Policy for &quot;</span> &lt;&lt; instance_id &lt;&lt; <span class="stringliteral">&quot; is\n&quot;</span></div><div class="line">              &lt;&lt; *result &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00989">989</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="abb23adb5d79de1e41528c1d621b3fe7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb23adb5d79de1e41528c1d621b3fe7b">&#9670;&nbsp;</a></span>AsyncTestIamPermissions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; std::vector&lt; std::string &gt; &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::AsyncTestIamPermissions </td>
          <td>(</td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>permissions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously obtains a permission set that the caller has on the specified instance. </p>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is read-only and therefore it is always idempotent.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_id</td><td>the ID of the instance to query. </td></tr>
    <tr><td class="paramname">permissions</td><td>set of permissions to check for the resource.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string <span class="keyword">const</span>&amp; resource, std::vector&lt;std::string&gt; <span class="keyword">const</span>&amp; permissions) {</div><div class="line">    future&lt;StatusOr&lt;std::vector&lt;std::string&gt;&gt;&gt; permissions_future =</div><div class="line">        instance_admin.AsyncTestIamPermissions(cq, resource, permissions);</div><div class="line">    <span class="comment">// Show how to perform additional work while the long running operation</span></div><div class="line">    <span class="comment">// completes. The application could use permissions_future.then() instead.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Waiting for TestIamPermissions &quot;</span> &lt;&lt; std::flush;</div><div class="line">    permissions_future.wait_for(std::chrono::seconds(2));</div><div class="line">    std::cout &lt;&lt; <span class="charliteral">&#39;.&#39;</span> &lt;&lt; std::flush;</div><div class="line">    <span class="keyword">auto</span> result = permissions_future.get();</div><div class="line">    <span class="keywordflow">if</span> (!result) <span class="keywordflow">throw</span> std::runtime_error(result.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;DONE, the current user has the following permissions [&quot;</span>;</div><div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span>* sep = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; p : *result) {</div><div class="line">      std::cout &lt;&lt; sep &lt;&lt; p;</div><div class="line">      sep = <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://cloud.google.com/bigtable/docs/access-control">https://cloud.google.com/bigtable/docs/access-control</a> for a list of valid permissions on Google Cloud Bigtable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l01049">1049</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="aeef44a13d8825fd9c849dbe1f2eb4122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef44a13d8825fd9c849dbe1f2eb4122">&#9670;&nbsp;</a></span>AsyncUpdateAppProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; google::bigtable::admin::v2::AppProfile &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::AsyncUpdateAppProfile </td>
          <td>(</td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>profile_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1AppProfileUpdateConfig.html">AppProfileUpdateConfig</a>&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates an application profile (asynchronously). </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_id</td><td>the instance for the new application profile. </td></tr>
    <tr><td class="paramname">profile_id</td><td>the id (not the full name) of the profile to update. </td></tr>
    <tr><td class="paramname">config</td><td>the configuration for the new application profile.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future satisfied when either (a) the profile is updated or (b) an unretriable error occurs or (c) polling or retry policy has been exhausted.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string <span class="keyword">const</span>&amp; instance_id, std::string <span class="keyword">const</span>&amp; profile_id) {</div><div class="line">    future&lt;StatusOr&lt;google::bigtable::admin::v2::AppProfile&gt;&gt; profile_future =</div><div class="line">        instance_admin.AsyncUpdateAppProfile(</div><div class="line">            cq, instance_id, profile_id,</div><div class="line">            cbt::AppProfileUpdateConfig()</div><div class="line">                .set_description(<span class="stringliteral">&quot;new description&quot;</span>)</div><div class="line">                .set_ignore_warnings(<span class="keyword">true</span>));</div><div class="line"></div><div class="line">    <span class="comment">// Show how to perform additional work while the long running operation</span></div><div class="line">    <span class="comment">// completes. The application could use profile_future.then() instead.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Waiting for app profile update to complete &quot;</span> &lt;&lt; std::flush;</div><div class="line">    profile_future.wait_for(std::chrono::seconds(2));</div><div class="line">    std::cout &lt;&lt; <span class="charliteral">&#39;.&#39;</span> &lt;&lt; std::flush;</div><div class="line">    <span class="keyword">auto</span> app_profile = profile_future.get();</div><div class="line">    <span class="keywordflow">if</span> (!app_profile) <span class="keywordflow">throw</span> std::runtime_error(app_profile.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;DONE, details=&quot;</span> &lt;&lt; app_profile-&gt;DebugString() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00648">648</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="afcaa9ea86ece7275ca274f9ee7336c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcaa9ea86ece7275ca274f9ee7336c28">&#9670;&nbsp;</a></span>AsyncUpdateCluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; google::bigtable::admin::v2::Cluster &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::AsyncUpdateCluster </td>
          <td>(</td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ClusterConfig.html">ClusterConfig</a>&#160;</td>
          <td class="paramname"><em>cluster_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update an existing cluster (asynchronously). </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">cluster_config</td><td>cluster with updated values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future satisfied when either (a) the cluster is updated or (b) an unretriable error occurs or (c) polling or retry policy has been exhausted.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string <span class="keyword">const</span>&amp; instance_id, std::string <span class="keyword">const</span>&amp; cluster_id) {</div><div class="line">    future&lt;void&gt; <span class="keyword">final</span> =</div><div class="line">        instance_admin.AsyncGetCluster(cq, instance_id, cluster_id)</div><div class="line">            .then([instance_admin,</div><div class="line">                   cq](future&lt;StatusOr&lt;google::bigtable::admin::v2::Cluster&gt;&gt;</div><div class="line">                           f) <span class="keyword">mutable</span> {</div><div class="line">              <span class="keyword">auto</span> cluster = f.get();</div><div class="line">              <span class="keywordflow">if</span> (!cluster) {</div><div class="line">                <span class="keywordflow">return</span> google::cloud::make_ready_future(</div><div class="line">                    StatusOr&lt;google::bigtable::admin::v2::Cluster&gt;(</div><div class="line">                        cluster.status()));</div><div class="line">              }</div><div class="line">              <span class="comment">// The state cannot be sent on updates, so clear it first.</span></div><div class="line">              cluster-&gt;clear_state();</div><div class="line">              <span class="comment">// Set the desired cluster configuration.</span></div><div class="line">              cluster-&gt;set_serve_nodes(4);</div><div class="line">              cbt::ClusterConfig modified_config =</div><div class="line">                  cbt::ClusterConfig(std::move(*cluster));</div><div class="line"></div><div class="line">              <span class="keywordflow">return</span> instance_admin.AsyncUpdateCluster(cq, modified_config);</div><div class="line">            })</div><div class="line">            .then([](future&lt;StatusOr&lt;google::bigtable::admin::v2::Cluster&gt;&gt; f) {</div><div class="line">              <span class="keyword">auto</span> cluster = f.get();</div><div class="line">              <span class="keywordflow">if</span> (!cluster) {</div><div class="line">                <span class="keywordflow">throw</span> std::runtime_error(cluster.status().message());</div><div class="line">              }</div><div class="line">              std::cout &lt;&lt; <span class="stringliteral">&quot;DONE, details=&quot;</span> &lt;&lt; cluster-&gt;DebugString() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">            });</div><div class="line">    <span class="keyword">final</span>.get();  <span class="comment">// block to keep example simple.</span></div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00513">513</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="ad43f3ac54f2914e8ffd2f294314fa874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43f3ac54f2914e8ffd2f294314fa874">&#9670;&nbsp;</a></span>AsyncUpdateInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; google::bigtable::admin::v2::Instance &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::AsyncUpdateInstance </td>
          <td>(</td>
          <td class="paramtype">CompletionQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceUpdateConfig.html">InstanceUpdateConfig</a>&#160;</td>
          <td class="paramname"><em>instance_update_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update an existing instance (asynchronously). </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an early version of the asynchronous APIs for Cloud Bigtable. These APIs might be changed in backward-incompatible ways. It is not subject to any SLA or deprecation policy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>the completion queue that will execute the asynchronous calls, the application must ensure that one or more threads are blocked on <code>cq.Run()</code>. </td></tr>
    <tr><td class="paramname">instance_update_config</td><td>config with modified instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future satisfied when either (a) the instance is updated or (b) an unretriable error occurs or (c) polling or retry policy has been exhausted.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, cbt::CompletionQueue cq,</div><div class="line">     std::string <span class="keyword">const</span>&amp; instance_id) {</div><div class="line">    <span class="comment">// Chain a AsyncGetInstance() + AsyncUpdateInstance().</span></div><div class="line">    future&lt;void&gt; <span class="keyword">final</span> =</div><div class="line">        instance_admin.AsyncGetInstance(cq, instance_id)</div><div class="line">            .then([instance_admin,</div><div class="line">                   cq](future&lt;StatusOr&lt;google::bigtable::admin::v2::Instance&gt;&gt;</div><div class="line">                           f) <span class="keyword">mutable</span> {</div><div class="line">              <span class="keyword">auto</span> instance = f.get();</div><div class="line">              <span class="keywordflow">if</span> (!instance) {</div><div class="line">                <span class="keywordflow">throw</span> std::runtime_error(instance.status().message());</div><div class="line">              }</div><div class="line">              <span class="comment">// Modify the instance and prepare the mask with modified</span></div><div class="line">              <span class="comment">// field</span></div><div class="line">              cbt::InstanceUpdateConfig instance_update_config(</div><div class="line">                  std::move(*instance));</div><div class="line">              instance_update_config.set_display_name(<span class="stringliteral">&quot;Modified Display Name&quot;</span>);</div><div class="line"></div><div class="line">              <span class="keywordflow">return</span> instance_admin.AsyncUpdateInstance(cq,</div><div class="line">                                                        instance_update_config);</div><div class="line">            })</div><div class="line">            .then(</div><div class="line">                [](future&lt;StatusOr&lt;google::bigtable::admin::v2::Instance&gt;&gt; f) {</div><div class="line">                  <span class="keyword">auto</span> instance = f.get();</div><div class="line">                  <span class="keywordflow">if</span> (!instance) {</div><div class="line">                    <span class="keywordflow">throw</span> std::runtime_error(instance.status().message());</div><div class="line">                  }</div><div class="line">                  std::cout</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot;DONE, instance details: &quot;</span> &lt;&lt; instance-&gt;DebugString()</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                });</div><div class="line">    <span class="keyword">final</span>.get();  <span class="comment">// block to keep example simple.</span></div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00225">225</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="ac92f07ae5d32b312166a2b71cf50f06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92f07ae5d32b312166a2b71cf50f06e">&#9670;&nbsp;</a></span>ClusterName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string google::cloud::bigtable::v1::InstanceAdmin::ClusterName </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>cluster_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the fully qualified name of the given cluster_id in give instance_id. </p>

<p class="definition">Definition at line <a class="el" href="instance__admin_8h_source.html#l00179">179</a> of file <a class="el" href="instance__admin_8h_source.html">instance_admin.h</a>.</p>

</div>
</div>
<a id="af7385d33a04215bff6ccfadc65967e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7385d33a04215bff6ccfadc65967e64">&#9670;&nbsp;</a></span>CreateAppProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; btadmin::AppProfile &gt; google::cloud::bigtable::v1::InstanceAdmin::CreateAppProfile </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1AppProfileConfig.html">AppProfileConfig</a>&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new application profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the instance for the new application profile. </td></tr>
    <tr><td class="paramname">config</td><td>the configuration for the new application profile. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The proto describing the new application profile.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Multi-cluster Routing Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id,</div><div class="line">     std::string <span class="keyword">const</span>&amp; profile_id) {</div><div class="line">    <span class="keyword">auto</span> config = cbt::AppProfileConfig::MultiClusterUseAny(profile_id);</div><div class="line">    StatusOr&lt;google::bigtable::admin::v2::AppProfile&gt; profile =</div><div class="line">        instance_admin.CreateAppProfile(instance_id, config);</div><div class="line">    <span class="keywordflow">if</span> (!profile) <span class="keywordflow">throw</span> std::runtime_error(profile.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;New profile created with name=&quot;</span> &lt;&lt; profile-&gt;name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Single Cluster Routing Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id,</div><div class="line">     std::string <span class="keyword">const</span>&amp; profile_id, std::string <span class="keyword">const</span>&amp; cluster_id) {</div><div class="line">    <span class="keyword">auto</span> config =</div><div class="line">        cbt::AppProfileConfig::SingleClusterRouting(profile_id, cluster_id);</div><div class="line">    StatusOr&lt;google::bigtable::admin::v2::AppProfile&gt; profile =</div><div class="line">        instance_admin.CreateAppProfile(instance_id, config);</div><div class="line">    <span class="keywordflow">if</span> (!profile) <span class="keywordflow">throw</span> std::runtime_error(profile.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;New profile created with name=&quot;</span> &lt;&lt; profile-&gt;name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00551">551</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a213dd25989a612adf21074ecb8a05d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213dd25989a612adf21074ecb8a05d24">&#9670;&nbsp;</a></span>CreateCluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; btadmin::Cluster &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::CreateCluster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ClusterConfig.html">ClusterConfig</a>&#160;</td>
          <td class="paramname"><em>cluster_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>cluster_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new Cluster of Cloud Bigtable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster_config</td><td>a description of the new cluster to be created. </td></tr>
    <tr><td class="paramname">instance_id</td><td>the id of the instance in the project </td></tr>
    <tr><td class="paramname">cluster_id</td><td>the id of the cluster in the project that needs to be created. It must be between 6 and 30 characters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id,</div><div class="line">     std::string <span class="keyword">const</span>&amp; cluster_id, std::string <span class="keyword">const</span>&amp; zone) {</div><div class="line">    <span class="keyword">auto</span> cluster_config = cbt::ClusterConfig(zone, 3, cbt::ClusterConfig::HDD);</div><div class="line">    future&lt;StatusOr&lt;google::bigtable::admin::v2::Cluster&gt;&gt; cluster_future =</div><div class="line">        instance_admin.CreateCluster(cluster_config, instance_id, cluster_id);</div><div class="line"></div><div class="line">    <span class="comment">// Applications can wait asynchronously, in this example we just block.</span></div><div class="line">    <span class="keyword">auto</span> cluster = cluster_future.get();</div><div class="line">    <span class="keywordflow">if</span> (!cluster) <span class="keywordflow">throw</span> std::runtime_error(cluster.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Successfully created cluster &quot;</span> &lt;&lt; cluster-&gt;name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00170">170</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="ac50920c09a6f964085bb86b14f53d75b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50920c09a6f964085bb86b14f53d75b">&#9670;&nbsp;</a></span>CreateInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; btadmin::Instance &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::CreateInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceConfig.html">InstanceConfig</a>&#160;</td>
          <td class="paramname"><em>instance_config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new instance of Cloud Bigtable. </p>
<dl class="section warning"><dt>Warning</dt><dd>Note that this is operation can take seconds or minutes to complete. The application may prefer to perform other work while waiting for this operation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_config</td><td>a description of the new instance to be created. instance_id and a display_name parameters must be set in instance_config,<ul>
<li>instance_id : must be between 6 and 33 characters.</li>
<li>display_name : must be between 4 and 30 characters. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future that becomes satisfied when (a) the operation has completed successfully, in which case it returns a proto with the Instance details, (b) the operation has failed, in which case the future contains an <code>google::cloud::Status</code> with the details of the failure, or (c) the state of the operation is unknown after the time allocated by the retry policies has expired, in which case the future contains the last error status.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id,</div><div class="line">     std::string <span class="keyword">const</span>&amp; zone) {</div><div class="line">    std::string display_name(<span class="stringliteral">&quot;Put description here&quot;</span>);</div><div class="line">    std::string cluster_id = instance_id + <span class="stringliteral">&quot;-c1&quot;</span>;</div><div class="line">    <span class="keyword">auto</span> cluster_config = cbt::ClusterConfig(zone, 3, cbt::ClusterConfig::HDD);</div><div class="line">    cbt::InstanceConfig config(instance_id, display_name,</div><div class="line">                               {{cluster_id, cluster_config}});</div><div class="line">    config.set_type(cbt::InstanceConfig::PRODUCTION);</div><div class="line"></div><div class="line">    future&lt;StatusOr&lt;google::bigtable::admin::v2::Instance&gt;&gt; instance_future =</div><div class="line">        instance_admin.CreateInstance(config);</div><div class="line">    <span class="comment">// Show how to perform additional work while the long running operation</span></div><div class="line">    <span class="comment">// completes. The application could use future.then() instead.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Waiting for instance creation to complete &quot;</span> &lt;&lt; std::flush;</div><div class="line">    instance_future.wait_for(std::chrono::seconds(1));</div><div class="line">    std::cout &lt;&lt; <span class="charliteral">&#39;.&#39;</span> &lt;&lt; std::flush;</div><div class="line">    <span class="keyword">auto</span> instance = instance_future.get();</div><div class="line">    <span class="keywordflow">if</span> (!instance) <span class="keywordflow">throw</span> std::runtime_error(instance.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;DONE, details=&quot;</span> &lt;&lt; instance-&gt;DebugString() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00133">133</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a492dfe843434806a85b74cb8a1030de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492dfe843434806a85b74cb8a1030de4">&#9670;&nbsp;</a></span>DeleteAppProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Status google::cloud::bigtable::v1::InstanceAdmin::DeleteAppProfile </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>profile_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_warnings</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an existing application profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the instance to look the profile in. </td></tr>
    <tr><td class="paramname">profile_id</td><td>the id of the profile within that instance. </td></tr>
    <tr><td class="paramname">ignore_warnings</td><td>if true, ignore safety checks when deleting the application profile. This value is to to <code>true</code> by default. Passing <code>false</code> causes this function to fail even when no operations are pending.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id,</div><div class="line">     std::string <span class="keyword">const</span>&amp; profile_id, <span class="keywordtype">bool</span> ignore_warnings) {</div><div class="line">    google::cloud::Status status = instance_admin.DeleteAppProfile(</div><div class="line">        instance_id, profile_id, ignore_warnings);</div><div class="line">    <span class="keywordflow">if</span> (!status.ok()) <span class="keywordflow">throw</span> std::runtime_error(status.message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Application Profile deleted\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00735">735</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="ab1b639029d0568c3cb7b4efc62bceb3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b639029d0568c3cb7b4efc62bceb3c">&#9670;&nbsp;</a></span>DeleteCluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Status google::cloud::bigtable::v1::InstanceAdmin::DeleteCluster </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>cluster_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the specified cluster of an instance in the project. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the id of the instance in the project </td></tr>
    <tr><td class="paramname">cluster_id</td><td>the id of the cluster in the project that needs to be deleted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id,</div><div class="line">     std::string <span class="keyword">const</span>&amp; cluster_id) {</div><div class="line">    google::cloud::Status status =</div><div class="line">        instance_admin.DeleteCluster(instance_id, cluster_id);</div><div class="line">    <span class="keywordflow">if</span> (!status.ok()) <span class="keywordflow">throw</span> std::runtime_error(status.message());</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00533">533</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a486006fc1866998ac8c9ae4d808572b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486006fc1866998ac8c9ae4d808572b1">&#9670;&nbsp;</a></span>DeleteInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Status google::cloud::bigtable::v1::InstanceAdmin::DeleteInstance </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the instances in the project. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the id of the instance in the project that needs to be deleted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id) {</div><div class="line">    google::cloud::Status status = instance_admin.DeleteInstance(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!status.ok()) <span class="keywordflow">throw</span> std::runtime_error(status.message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Successfully deleted the instance &quot;</span> &lt;&lt; instance_id &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00289">289</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a421351a3a87888a58db5afa09fdb872e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421351a3a87888a58db5afa09fdb872e">&#9670;&nbsp;</a></span>GetAppProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; btadmin::AppProfile &gt; google::cloud::bigtable::v1::InstanceAdmin::GetAppProfile </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>profile_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the detailed information about an existing application profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the instance to look the profile in. </td></tr>
    <tr><td class="paramname">profile_id</td><td>the id of the profile within that instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The proto describing the application profile.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is read-only and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id,</div><div class="line">     std::string <span class="keyword">const</span>&amp; profile_id) {</div><div class="line">    StatusOr&lt;google::bigtable::admin::v2::AppProfile&gt; profile =</div><div class="line">        instance_admin.GetAppProfile(instance_id, profile_id);</div><div class="line">    <span class="keywordflow">if</span> (!profile) <span class="keywordflow">throw</span> std::runtime_error(profile.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Application Profile details=&quot;</span> &lt;&lt; profile-&gt;DebugString()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00594">594</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="aba9f0face63f15e1fa3c741c01ae47b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9f0face63f15e1fa3c741c01ae47b9">&#9670;&nbsp;</a></span>GetCluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; btadmin::Cluster &gt; google::cloud::bigtable::v1::InstanceAdmin::GetCluster </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>cluster_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the specified cluster of an instance in the project. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the id of the instance in the project </td></tr>
    <tr><td class="paramname">cluster_id</td><td>the id of the cluster in the project that needs to be deleted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a Cluster for given instance_id and cluster_id.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is read-only and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id,</div><div class="line">     std::string <span class="keyword">const</span>&amp; cluster_id) {</div><div class="line">    StatusOr&lt;google::bigtable::admin::v2::Cluster&gt; cluster =</div><div class="line">        instance_admin.GetCluster(instance_id, cluster_id);</div><div class="line">    <span class="keywordflow">if</span> (!cluster) <span class="keywordflow">throw</span> std::runtime_error(cluster.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;GetCluster details : &quot;</span> &lt;&lt; cluster-&gt;DebugString() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00357">357</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a3b0c6da3d4afa4c638f46965515e518f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0c6da3d4afa4c638f46965515e518f">&#9670;&nbsp;</a></span>GetIamPolicy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; google::cloud::IamPolicy &gt; google::cloud::bigtable::v1::InstanceAdmin::GetIamPolicy </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the policy for <code>instance_id</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the instance to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Policy the full IAM policy for the instance.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>this function is deprecated; it doesn't support conditional bindings and will not support any other features to come; please use <code>GetNativeIamPolicy</code> instead. TODO(#2857): Use proper deprecation attributes.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is read-only and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id) {</div><div class="line">    StatusOr&lt;google::cloud::IamPolicy&gt; policy =</div><div class="line">        instance_admin.GetIamPolicy(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!policy) <span class="keywordflow">throw</span> std::runtime_error(policy.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;The IAM Policy for &quot;</span> &lt;&lt; instance_id &lt;&lt; <span class="stringliteral">&quot; is\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; kv : policy-&gt;bindings) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;role &quot;</span> &lt;&lt; kv.first &lt;&lt; <span class="stringliteral">&quot; includes [&quot;</span>;</div><div class="line">      <span class="keywordtype">char</span> <span class="keyword">const</span>* sep = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; member : kv.second) {</div><div class="line">        std::cout &lt;&lt; sep &lt;&lt; member;</div><div class="line">        sep = <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">      }</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00782">782</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a60844ae9110014889b77ee24129de5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60844ae9110014889b77ee24129de5d5">&#9670;&nbsp;</a></span>GetInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; btadmin::Instance &gt; google::cloud::bigtable::v1::InstanceAdmin::GetInstance </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the details of <code>instance_id</code>. </p>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is read-only and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id) {</div><div class="line">    StatusOr&lt;google::bigtable::admin::v2::Instance&gt; instance =</div><div class="line">        instance_admin.GetInstance(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!instance) <span class="keywordflow">throw</span> std::runtime_error(instance.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;GetInstance details : &quot;</span> &lt;&lt; instance-&gt;DebugString() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00246">246</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a90e641fea08b9dbfecc160173d98b5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e641fea08b9dbfecc160173d98b5ab">&#9670;&nbsp;</a></span>GetNativeIamPolicy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; google::iam::v1::Policy &gt; google::cloud::bigtable::v1::InstanceAdmin::GetNativeIamPolicy </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the native policy for <code>instance_id</code>. </p>
<p>This is the preferred way to <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a3b0c6da3d4afa4c638f46965515e518f" title="Gets the policy for instance_id.">GetIamPolicy()</a></code>. This is more closely coupled to the underlying protocol, enable more actions and is more likely to tolerate future protocol changes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the instance to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>google::iam::v1::Policy the full IAM policy for the instance.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is read-only and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id) {</div><div class="line">    StatusOr&lt;google::iam::v1::Policy&gt; policy =</div><div class="line">        instance_admin.GetNativeIamPolicy(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!policy) <span class="keywordflow">throw</span> std::runtime_error(policy.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;The IAM Policy for &quot;</span> &lt;&lt; instance_id &lt;&lt; <span class="stringliteral">&quot; is\n&quot;</span></div><div class="line">              &lt;&lt; policy-&gt;DebugString() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00807">807</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="aefeee609fab315842e014c1cbadb246c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefeee609fab315842e014c1cbadb246c">&#9670;&nbsp;</a></span>InstanceName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string google::cloud::bigtable::v1::InstanceAdmin::InstanceName </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the fully qualified name of the given instance_id. </p>

<p class="definition">Definition at line <a class="el" href="instance__admin_8h_source.html#l00173">173</a> of file <a class="el" href="instance__admin_8h_source.html">instance_admin.h</a>.</p>

</div>
</div>
<a id="a24a815e874b617e9e36eff23f4342fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a815e874b617e9e36eff23f4342fd9">&#9670;&nbsp;</a></span>ListAppProfiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; std::vector&lt; btadmin::AppProfile &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::ListAppProfiles </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List the application profiles in an instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the instance to list the profiles for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::vector with the protos describing any profiles.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is read-only and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id) {</div><div class="line">    StatusOr&lt;std::vector&lt;google::bigtable::admin::v2::AppProfile&gt;&gt; profiles =</div><div class="line">        instance_admin.ListAppProfiles(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!profiles) <span class="keywordflow">throw</span> std::runtime_error(profiles.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;The &quot;</span> &lt;&lt; instance_id &lt;&lt; <span class="stringliteral">&quot; instance has &quot;</span> &lt;&lt; profiles-&gt;size()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; application profiles\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; profile : *profiles) {</div><div class="line">      std::cout &lt;&lt; profile.DebugString() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00672">672</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="aff94dfb0492c9c6c73e9b29857549020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff94dfb0492c9c6c73e9b29857549020">&#9670;&nbsp;</a></span>ListClusters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ClusterList.html">ClusterList</a> &gt; google::cloud::bigtable::v1::InstanceAdmin::ListClusters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the list of clusters in an instance. </p>
<dl class="section note"><dt>Note</dt><dd>In some circumstances Cloud Bigtable may be unable to obtain the full list of clusters, typically because some transient failure has made specific zones unavailable. In this cases the service returns a separate list of <code>failed_locations</code> that represent the unavailable zones. Applications may want to retry the operation after the transient conditions have cleared.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is read-only and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id) {</div><div class="line">    StatusOr&lt;cbt::ClusterList&gt; clusters =</div><div class="line">        instance_admin.ListClusters(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!clusters) <span class="keywordflow">throw</span> std::runtime_error(clusters.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Cluster Name List\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; cluster : clusters-&gt;clusters) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Cluster Name:&quot;</span> &lt;&lt; cluster.name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (!clusters-&gt;failed_locations.empty()) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;The Cloud Bigtable service reports that the following &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;locations are temporarily unavailable and no information &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;about clusters in these locations can be obtained:\n&quot;</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; failed_location : clusters-&gt;failed_locations) {</div><div class="line">        std::cout &lt;&lt; failed_location &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00399">399</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a429eacd3239d8e059e72a60f28e9789c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429eacd3239d8e059e72a60f28e9789c">&#9670;&nbsp;</a></span>ListClusters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ClusterList.html">ClusterList</a> &gt; google::cloud::bigtable::v1::InstanceAdmin::ListClusters </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the list of clusters in an instance. </p>
<dl class="section note"><dt>Note</dt><dd>In some circumstances Cloud Bigtable may be unable to obtain the full list of clusters, typically because some transient failure has made specific zones unavailable. In this cases the service returns a separate list of <code>failed_locations</code> that represent the unavailable zones. Applications may want to retry the operation after the transient conditions have cleared.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is read-only and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id) {</div><div class="line">    StatusOr&lt;cbt::ClusterList&gt; clusters =</div><div class="line">        instance_admin.ListClusters(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!clusters) <span class="keywordflow">throw</span> std::runtime_error(clusters.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Cluster Name List\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; cluster : clusters-&gt;clusters) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Cluster Name:&quot;</span> &lt;&lt; cluster.name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (!clusters-&gt;failed_locations.empty()) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;The Cloud Bigtable service reports that the following &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;locations are temporarily unavailable and no information &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;about clusters in these locations can be obtained:\n&quot;</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; failed_location : clusters-&gt;failed_locations) {</div><div class="line">        std::cout &lt;&lt; failed_location &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00403">403</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a73a4b95b901129d28e74c17b4e293411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a4b95b901129d28e74c17b4e293411">&#9670;&nbsp;</a></span>ListInstances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; <a class="el" href="structgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceList.html">InstanceList</a> &gt; google::cloud::bigtable::v1::InstanceAdmin::ListInstances </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the list of instances in the project. </p>
<dl class="section note"><dt>Note</dt><dd>In some circumstances Cloud Bigtable may be unable to obtain the full list of instances, typically because some transient failure has made specific zones unavailable. In this cases the service returns a separate list of <code>failed_locations</code> that represent the unavailable zones. Applications may want to retry the operation after the transient conditions have cleared.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is read-only and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin) {</div><div class="line">    StatusOr&lt;cbt::InstanceList&gt; instances = instance_admin.ListInstances();</div><div class="line">    <span class="keywordflow">if</span> (!instances) <span class="keywordflow">throw</span> std::runtime_error(instances.status().message());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; instance : instances-&gt;instances) {</div><div class="line">      std::cout &lt;&lt; instance.name() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (!instances-&gt;failed_locations.empty()) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;The Cloud Bigtable service reports that the following &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;locations are temporarily unavailable and no information &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;about instances in these locations can be obtained:\n&quot;</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; failed_location : instances-&gt;failed_locations) {</div><div class="line">        std::cout &lt;&lt; failed_location &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00041">41</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a6b6982c136a05df506dca2f56acfcdeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6982c136a05df506dca2f56acfcdeb">&#9670;&nbsp;</a></span>project_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string const&amp; google::cloud::bigtable::v1::InstanceAdmin::project_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The project id, i.e., <code><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceAdmin.html#a4c7c80489d100c5e2d109819fa7cf608" title="The full name (projects/&lt;project_id&gt;) of the project.">project_name()</a></code> without the <code>projects/</code> prefix. </p>

<p class="definition">Definition at line <a class="el" href="instance__admin_8h_source.html#l00170">170</a> of file <a class="el" href="instance__admin_8h_source.html">instance_admin.h</a>.</p>

</div>
</div>
<a id="a4c7c80489d100c5e2d109819fa7cf608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7c80489d100c5e2d109819fa7cf608">&#9670;&nbsp;</a></span>project_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string const&amp; google::cloud::bigtable::v1::InstanceAdmin::project_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The full name (<code>projects/&lt;project_id&gt;</code>) of the project. </p>

<p class="definition">Definition at line <a class="el" href="instance__admin_8h_source.html#l00168">168</a> of file <a class="el" href="instance__admin_8h_source.html">instance_admin.h</a>.</p>

</div>
</div>
<a id="a017a3f14072c8b96b473f281167b15b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017a3f14072c8b96b473f281167b15b0">&#9670;&nbsp;</a></span>SetIamPolicy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; google::cloud::IamPolicy &gt; google::cloud::bigtable::v1::InstanceAdmin::SetIamPolicy </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">google::cloud::IamBindings const &amp;&#160;</td>
          <td class="paramname"><em>iam_bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>etag</em> = <code>std::string{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the IAM policy for an instance. </p>
<p>Applications can provide the <code>etag</code> to implement optimistic concurrency control. If <code>etag</code> is not empty, the server will reject calls where the provided ETag does not match the ETag value stored in the server.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>which instance to set the IAM policy for. </td></tr>
    <tr><td class="paramname">iam_bindings</td><td>IamBindings object containing role and members. </td></tr>
    <tr><td class="paramname">etag</td><td>the expected ETag value for the current policy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Policy the current IAM bindings for the instance.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>this function is deprecated; it doesn't support conditional bindings and will not support any other features to come; please use the overload for <code>google::iam::v1::Policy</code> instead. TODO(#2857): Use proper deprecation attributes.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>ETags are currently not used by Cloud Bigtable.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id,</div><div class="line">     std::string <span class="keyword">const</span>&amp; role, std::string <span class="keyword">const</span>&amp; member) {</div><div class="line">    StatusOr&lt;google::cloud::IamPolicy&gt; current =</div><div class="line">        instance_admin.GetIamPolicy(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!current) <span class="keywordflow">throw</span> std::runtime_error(current.status().message());</div><div class="line">    <span class="keyword">auto</span> bindings = current-&gt;bindings;</div><div class="line">    bindings.AddMember(role, member);</div><div class="line">    StatusOr&lt;google::cloud::IamPolicy&gt; policy =</div><div class="line">        instance_admin.SetIamPolicy(instance_id, bindings, current-&gt;etag);</div><div class="line">    <span class="keywordflow">if</span> (!policy) <span class="keywordflow">throw</span> std::runtime_error(policy.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;The IAM Policy for &quot;</span> &lt;&lt; instance_id &lt;&lt; <span class="stringliteral">&quot; is\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; kv : policy-&gt;bindings) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;role &quot;</span> &lt;&lt; kv.first &lt;&lt; <span class="stringliteral">&quot; includes [&quot;</span>;</div><div class="line">      <span class="keywordtype">char</span> <span class="keyword">const</span>* sep = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; m : kv.second) {</div><div class="line">        std::cout &lt;&lt; sep &lt;&lt; m;</div><div class="line">        sep = <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">      }</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00883">883</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="ab8fb71752cecbb9ea9a4135f1ac4e55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8fb71752cecbb9ea9a4135f1ac4e55e">&#9670;&nbsp;</a></span>SetIamPolicy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; google::iam::v1::Policy &gt; google::cloud::bigtable::v1::InstanceAdmin::SetIamPolicy </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">google::iam::v1::Policy const &amp;&#160;</td>
          <td class="paramname"><em>iam_policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the IAM policy for an instance. </p>
<p>This is the preferred way to the overload for <code>IamBindings</code>. This is more closely coupled to the underlying protocol, enable more actions and is more likely to tolerate future protocol changes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>which instance to set the IAM policy for. </td></tr>
    <tr><td class="paramname">iam_policy</td><td>google::iam::v1::Policy object containing role and members. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>google::iam::v1::Policy the current IAM policy for the instance.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>ETags are currently not used by Cloud Bigtable.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id,</div><div class="line">     std::string <span class="keyword">const</span>&amp; role, std::string <span class="keyword">const</span>&amp; member) {</div><div class="line">    StatusOr&lt;google::iam::v1::Policy&gt; current =</div><div class="line">        instance_admin.GetNativeIamPolicy(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!current) <span class="keywordflow">throw</span> std::runtime_error(current.status().message());</div><div class="line">    <span class="comment">// This example adds the member to all existing bindings for that role. If</span></div><div class="line">    <span class="comment">// there are no such bindgs, it adds a new one. This might not be what the</span></div><div class="line">    <span class="comment">// user wants, e.g. in case of conditional bindings.</span></div><div class="line">    <span class="keywordtype">size_t</span> num_added = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; binding : *current-&gt;mutable_bindings()) {</div><div class="line">      <span class="keywordflow">if</span> (binding.role() == role) {</div><div class="line">        binding.add_members(member);</div><div class="line">        ++num_added;</div><div class="line">      }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (num_added == 0) {</div><div class="line">      *current-&gt;add_bindings() = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable_1_1v1.html#a97d1cefbc6bd7f002a83344476bd4dc3">cbt::IamBinding</a>(role, {member});</div><div class="line">    }</div><div class="line">    StatusOr&lt;google::iam::v1::Policy&gt; policy =</div><div class="line">        instance_admin.SetIamPolicy(instance_id, *current);</div><div class="line">    <span class="keywordflow">if</span> (!policy) <span class="keywordflow">throw</span> std::runtime_error(policy.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;The IAM Policy for &quot;</span> &lt;&lt; instance_id &lt;&lt; <span class="stringliteral">&quot; is\n&quot;</span></div><div class="line">              &lt;&lt; policy-&gt;DebugString() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00921">921</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a3da026ac64422a6d31417155f641a739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da026ac64422a6d31417155f641a739">&#9670;&nbsp;</a></span>TestIamPermissions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatusOr&lt; std::vector&lt; std::string &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::TestIamPermissions </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>permissions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a permission set that the caller has on the specified instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the ID of the instance to query. </td></tr>
    <tr><td class="paramname">permissions</td><td>set of permissions to check for the resource.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is read-only and therefore it is always idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; resource,</div><div class="line">     std::vector&lt;std::string&gt; <span class="keyword">const</span>&amp; permissions) {</div><div class="line">    StatusOr&lt;std::vector&lt;std::string&gt;&gt; result =</div><div class="line">        instance_admin.TestIamPermissions(resource, permissions);</div><div class="line">    <span class="keywordflow">if</span> (!result) <span class="keywordflow">throw</span> std::runtime_error(result.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;The current user has the following permissions [&quot;</span>;</div><div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span>* sep = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; p : *result) {</div><div class="line">      std::cout &lt;&lt; sep &lt;&lt; p;</div><div class="line">      sep = <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://cloud.google.com/bigtable/docs/access-control">https://cloud.google.com/bigtable/docs/access-control</a> for a list of valid permissions on Google Cloud Bigtable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l01011">1011</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="ab70ab7a12c9e8c3f8fb405b9fbba3d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70ab7a12c9e8c3f8fb405b9fbba3d15">&#9670;&nbsp;</a></span>UpdateAppProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; btadmin::AppProfile &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::UpdateAppProfile </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>profile_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1AppProfileUpdateConfig.html">AppProfileUpdateConfig</a>&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates an existing application profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_id</td><td>the instance for the new application profile. </td></tr>
    <tr><td class="paramname">profile_id</td><td>the id (not the full name) of the profile to update. </td></tr>
    <tr><td class="paramname">config</td><td>the configuration for the new application profile. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The proto describing the new application profile.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Change Description Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id,</div><div class="line">     std::string <span class="keyword">const</span>&amp; profile_id, std::string <span class="keyword">const</span>&amp; description) {</div><div class="line">    future&lt;StatusOr&lt;google::bigtable::admin::v2::AppProfile&gt;&gt; profile_future =</div><div class="line">        instance_admin.UpdateAppProfile(</div><div class="line">            instance_id, profile_id,</div><div class="line">            cbt::AppProfileUpdateConfig().set_description(description));</div><div class="line">    <span class="keyword">auto</span> profile = profile_future.get();</div><div class="line">    <span class="keywordflow">if</span> (!profile) <span class="keywordflow">throw</span> std::runtime_error(profile.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Updated AppProfile: &quot;</span> &lt;&lt; profile-&gt;DebugString() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Change Routing to Any Cluster Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id,</div><div class="line">     std::string <span class="keyword">const</span>&amp; profile_id) {</div><div class="line">    future&lt;StatusOr&lt;google::bigtable::admin::v2::AppProfile&gt;&gt; profile_future =</div><div class="line">        instance_admin.UpdateAppProfile(instance_id, profile_id,</div><div class="line">                                        cbt::AppProfileUpdateConfig()</div><div class="line">                                            .set_multi_cluster_use_any()</div><div class="line">                                            .set_ignore_warnings(<span class="keyword">true</span>));</div><div class="line">    <span class="keyword">auto</span> profile = profile_future.get();</div><div class="line">    <span class="keywordflow">if</span> (!profile) <span class="keywordflow">throw</span> std::runtime_error(profile.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Updated AppProfile: &quot;</span> &lt;&lt; profile-&gt;DebugString() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Change Routing to a Specific Cluster Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id,</div><div class="line">     std::string <span class="keyword">const</span>&amp; profile_id, std::string <span class="keyword">const</span>&amp; cluster_id) {</div><div class="line">    future&lt;StatusOr&lt;google::bigtable::admin::v2::AppProfile&gt;&gt; profile_future =</div><div class="line">        instance_admin.UpdateAppProfile(</div><div class="line">            instance_id, profile_id,</div><div class="line">            cbt::AppProfileUpdateConfig()</div><div class="line">                .set_single_cluster_routing(cluster_id)</div><div class="line">                .set_ignore_warnings(<span class="keyword">true</span>));</div><div class="line">    <span class="keyword">auto</span> profile = profile_future.get();</div><div class="line">    <span class="keywordflow">if</span> (!profile) <span class="keywordflow">throw</span> std::runtime_error(profile.status().message());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Updated AppProfile: &quot;</span> &lt;&lt; profile-&gt;DebugString() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00634">634</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="afe746ee1bcfd82bcbcf9e96d987e1597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe746ee1bcfd82bcbcf9e96d987e1597">&#9670;&nbsp;</a></span>UpdateCluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; google::bigtable::admin::v2::Cluster &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::UpdateCluster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1ClusterConfig.html">ClusterConfig</a>&#160;</td>
          <td class="paramname"><em>cluster_config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update an existing cluster of Cloud Bigtable. </p>
<dl class="section warning"><dt>Warning</dt><dd>Note that this is operation can take seconds or minutes to complete. The application may prefer to perform other work while waiting for this operation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster_config</td><td>cluster with updated values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future that becomes satisfied when (a) the operation has completed successfully, in which case it returns a proto with the Instance details, (b) the operation has failed, in which case the future contains an exception (typically <code>bigtable::GrpcError</code>) with the details of the failure, or (c) the state of the operation is unknown after the time allocated by the retry policies has expired, in which case the future contains an exception of type <code>bigtable::PollTimeout</code>.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id,</div><div class="line">     std::string <span class="keyword">const</span>&amp; cluster_id) {</div><div class="line">    <span class="comment">// GetCluster first and then modify it.</span></div><div class="line">    StatusOr&lt;google::bigtable::admin::v2::Cluster&gt; cluster =</div><div class="line">        instance_admin.GetCluster(instance_id, cluster_id);</div><div class="line">    <span class="keywordflow">if</span> (!cluster) <span class="keywordflow">throw</span> std::runtime_error(cluster.status().message());</div><div class="line"></div><div class="line">    <span class="comment">// The state cannot be sent on updates, so clear it first.</span></div><div class="line">    cluster-&gt;clear_state();</div><div class="line">    <span class="comment">// Set the desired cluster configuration.</span></div><div class="line">    cluster-&gt;set_serve_nodes(4);</div><div class="line">    <span class="keyword">auto</span> modified_config = cbt::ClusterConfig(std::move(*cluster));</div><div class="line"></div><div class="line">    StatusOr&lt;google::bigtable::admin::v2::Cluster&gt; modified_cluster =</div><div class="line">        instance_admin.UpdateCluster(modified_config).get();</div><div class="line">    <span class="keywordflow">if</span> (!modified_cluster) {</div><div class="line">      <span class="keywordflow">throw</span> std::runtime_error(modified_cluster.status().message());</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;cluster details : &quot;</span> &lt;&lt; cluster-&gt;DebugString() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00501">501</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
<a id="a8b562a651dbff16f4d02f83b2172f77d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b562a651dbff16f4d02f83b2172f77d">&#9670;&nbsp;</a></span>UpdateInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future&lt; StatusOr&lt; google::bigtable::admin::v2::Instance &gt; &gt; google::cloud::bigtable::v1::InstanceAdmin::UpdateInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1cloud_1_1bigtable_1_1v1_1_1InstanceUpdateConfig.html">InstanceUpdateConfig</a>&#160;</td>
          <td class="paramname"><em>instance_update_config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update an existing instance of Cloud Bigtable. </p>
<dl class="section warning"><dt>Warning</dt><dd>Note that this is operation can take seconds or minutes to complete. The application may prefer to perform other work while waiting for this operation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_update_config</td><td>config with modified instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future that becomes satisfied when (a) the operation has completed successfully, in which case it returns a proto with the Instance details, (b) the operation has failed, in which case the future contains an exception (typically <code>bigtable::GrpcError</code>) with the details of the failure, or (c) the state of the operation is unknown after the time allocated by the retry policies has expired, in which case the future contains an exception of type <code>bigtable::PollTimeout</code>.</dd></dl>
<dl class="section user"><dt>Idempotency</dt><dd>This operation is always treated as non-idempotent.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">cbt</a> = <a class="code" href="namespacegoogle_1_1cloud_1_1bigtable.html">google::cloud::bigtable</a>;</div><div class="line">  <span class="keyword">using</span> google::cloud::future;</div><div class="line">  <span class="keyword">using</span> google::cloud::StatusOr;</div><div class="line">  [](cbt::InstanceAdmin instance_admin, std::string <span class="keyword">const</span>&amp; instance_id) {</div><div class="line">    <span class="keyword">auto</span> instance = instance_admin.GetInstance(instance_id);</div><div class="line">    <span class="keywordflow">if</span> (!instance) <span class="keywordflow">throw</span> std::runtime_error(instance.status().message());</div><div class="line">    <span class="comment">// Modify the instance and prepare the mask with modified field</span></div><div class="line">    cbt::InstanceUpdateConfig instance_update_config(std::move(*instance));</div><div class="line">    instance_update_config.set_display_name(<span class="stringliteral">&quot;Modified Display Name&quot;</span>);</div><div class="line"></div><div class="line">    future&lt;StatusOr&lt;google::bigtable::admin::v2::Instance&gt;&gt; instance_future =</div><div class="line">        instance_admin.UpdateInstance(std::move(instance_update_config));</div><div class="line">    instance_future</div><div class="line">        .then([](future&lt;StatusOr&lt;google::bigtable::admin::v2::Instance&gt;&gt; f) {</div><div class="line">          <span class="keyword">auto</span> updated_instance = f.get();</div><div class="line">          <span class="keywordflow">if</span> (!updated_instance) {</div><div class="line">            <span class="keywordflow">throw</span> std::runtime_error(updated_instance.status().message());</div><div class="line">          }</div><div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot;UpdateInstance details : &quot;</span></div><div class="line">                    &lt;&lt; updated_instance-&gt;DebugString() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">        })</div><div class="line">        .get();  <span class="comment">// block until done to simplify example</span></div><div class="line">  }</div></div><!-- fragment --></dd></dl>

<p class="definition">Definition at line <a class="el" href="instance__admin_8cc_source.html#l00213">213</a> of file <a class="el" href="instance__admin_8cc_source.html">instance_admin.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
